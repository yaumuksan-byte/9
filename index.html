<!DOCTYPE html>

<html lang="zh-CN">

<head>

    
    <meta name="description" content="Terraria Ultra - Aesthetic Edition - A beautiful 2D sandbox game">

    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
        name="viewport" />
    <meta content="yes" name="apple-mobile-web-app-capable" />
    <meta content="yes" name="mobile-web-app-capable" />
    <meta content="#1a1a2e" name="theme-color" />
    <title>âœ¨ Terraria Ultra - Aesthetic Edition âœ¨</title>

    <style type="text/css">  :root { --joy-size: 140px; --joy-pad: 35px; --btn-size: 70px; --ui-accent: rgba(162, 155, 254, 0.9); } #top-buttons { position: fixed; top: 14px; right: 14px; display: flex; gap: 10px; z-index: 9999; pointer-events: auto; } .top-btn { width: 44px; height: 44px; border-radius: var(--hud-radius); border: 1px solid var(--hud-border); background: linear-gradient(135deg, rgba(30, 30, 60, 0.55), rgba(10, 10, 25, 0.75)); backdrop-filter: blur(var(--hud-blur)); -webkit-backdrop-filter: blur(12px); color: #fff; font-size: 20px; display: grid; place-items: center; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35); cursor: pointer; transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease; } .top-btn:active { transform: scale(0.96); } .top-btn:hover { border-color: rgba(162, 155, 254, 0.55); box-shadow: 0 12px 34px rgba(0, 0, 0, 0.42); }  #toast-container { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); display: flex; flex-direction: column; gap: 10px; z-index: 9999; pointer-events: none; } .toast { min-width: 180px; max-width: 92vw; padding: 10px 12px; border-radius: 14px; color: rgba(255, 255, 255, 0.92); background: rgba(20, 20, 38, 0.72); border: 1px solid rgba(255, 255, 255, 0.12); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); box-shadow: 0 12px 32px rgba(0, 0, 0, 0.35); opacity: 0; transform: translateY(10px); transition: opacity .18s ease, transform .18s ease; font-size: 14px; } .toast.show { opacity: 1; transform: translateY(0); }  .ux-overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10000; background: rgba(0, 0, 0, 0.55); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); pointer-events: auto; contain: layout paint; will-change: opacity; } .ux-overlay.show { display: flex; } .ux-panel { width: min(560px, 92vw); max-height: 85vh; overflow: auto; border-radius: 18px; background: linear-gradient(135deg, rgba(20, 20, 40, 0.88), rgba(12, 12, 24, 0.92)); border: 1px solid rgba(255, 255, 255, 0.12); box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55); padding: 16px 16px 14px; color: rgba(255, 255, 255, 0.92); } .ux-title { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 12px; } .ux-title h2 { margin: 0; font-size: 18px; letter-spacing: .5px; } .ux-close { width: 36px; height: 36px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(255, 255, 255, 0.06); color: #fff; cursor: pointer; } .ux-grid { display: grid; gap: 12px; } .ux-row { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; padding: 10px 12px; border-radius: 14px; background: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.09); } .ux-row label { display: flex; flex-direction: column; gap: 4px; font-size: 14px; } .ux-row small { opacity: .75; font-size: 12px; } .ux-row input[type="range"] { width: 170px; } .ux-row select { width: 180px; padding: 8px 10px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(12, 12, 24, 0.85); color: rgba(255, 255, 255, 0.92); } .ux-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 14px; flex-wrap: wrap; } .ux-action { padding: 10px 12px; border-radius: 14px; border: 1px solid rgba(255, 255, 255, 0.16); background: rgba(255, 255, 255, 0.07); color: rgba(255, 255, 255, 0.92); cursor: pointer; } .ux-action.primary { border-color: rgba(162, 155, 254, 0.5); background: linear-gradient(135deg, rgba(108, 92, 231, 0.55), rgba(162, 155, 254, 0.28)); }  .reduced-motion *, .reduced-motion *::before, .reduced-motion *::after { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; scroll-behavior: auto !important; } .reduced-motion #ambient-particles { display: none !important; }  #btn-bag-toggle { position: fixed; display: none; pointer-events: none; } #inventory-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(12, 12, 30, 0.55); backdrop-filter: none; z-index: 520; display: none; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.25s ease; pointer-events: auto; contain: layout paint; will-change: opacity, transform; } #inventory-overlay.open { display: flex; opacity: 1; } #inventory-panel { width: min(920px, 92vw); height: min(620px, 88vh); background: linear-gradient(135deg, rgba(30, 30, 60, 0.88), rgba(18, 18, 38, 0.96)); border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 26px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.1); display: flex; overflow: hidden; --inv-scale: 0.96; --inv-drag-y: 0px; transform: translate3d(0, var(--inv-drag-y), 0) scale(var(--inv-scale)); transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1); } #inventory-overlay.open #inventory-panel { --inv-scale: 1; } #inventory-panel.dragging { transition: none !important; } .inv-close-btn { position: absolute; top: 14px; right: 14px; width: 36px; height: 36px; border-radius: 12px; background: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.12); color: #fff; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.12s ease, background 0.12s ease; z-index: 3; } .inv-close-btn:hover { transform: translateY(-1px); background: rgba(255, 255, 255, 0.10); } .inv-left { position: relative; flex: 1.35; padding: 22px 22px 18px; background: rgba(0, 0, 0, 0.10); border-right: 1px solid rgba(255, 255, 255, 0.06); display: flex; flex-direction: column; gap: 14px; } .inv-right { position: relative; flex: 0.85; padding: 24px; display: flex; flex-direction: column; gap: 12px; background: radial-gradient(circle at top right, rgba(253, 203, 110, 0.10), transparent 60%); } .inv-topbar { display: flex; align-items: center; justify-content: space-between; gap: 12px; } .inv-title { display: flex; gap: 10px; align-items: center; font-size: 18px; font-weight: 800; color: #fff; letter-spacing: 0.6px; } .inv-capacity { display: flex; align-items: center; gap: 10px; } .inv-capacity-text { font-size: 12px; color: rgba(255, 255, 255, 0.7); } .inv-capacity-bar { width: 120px; height: 8px; border-radius: 999px; background: rgba(255, 255, 255, 0.08); overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.10); } .inv-capacity-bar .fill { height: 100%; width: 0%; background: linear-gradient(90deg, rgba(108, 92, 231, 0.95), rgba(253, 203, 110, 0.85)); } .inv-section { display: flex; flex-direction: column; gap: 8px; } .inv-section-label { display: flex; justify-content: space-between; align-items: center; font-size: 12px; letter-spacing: 0.8px; color: rgba(255, 255, 255, 0.65); text-transform: uppercase; } .inv-grid { display: grid; grid-template-columns: repeat(9, 1fr); gap: 10px; padding: 4px 0; } .inv-slot { position: relative; height: 56px; border-radius: 14px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.12); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.12s ease, background 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease; user-select: none; } .inv-slot:hover { transform: translateY(-2px); background: rgba(255, 255, 255, 0.08); } .inv-slot.empty { opacity: 0.55; } .inv-slot.active { outline: 2px solid rgba(255, 255, 255, 0.6); box-shadow: 0 0 16px rgba(255, 255, 255, 0.25); transform: scale(1.06); } .inv-slot.drag-source { transform: scale(1.1); outline: 2px solid rgba(255, 255, 255, 0.85); box-shadow: 0 0 22px rgba(255, 255, 255, 0.35); } .inv-slot.drag-target { outline: 2px dashed rgba(255, 255, 255, 0.75); box-shadow: 0 0 18px rgba(255, 255, 255, 0.28); } .inv-slot.selected { border-color: rgba(108, 92, 231, 0.80); box-shadow: 0 0 0 2px rgba(108, 92, 231, 0.18); } .inv-slot.drop-target { border-color: rgba(0, 184, 148, 0.80); box-shadow: 0 0 0 2px rgba(0, 184, 148, 0.18); } .inv-slot .key { position: absolute; top: 6px; left: 8px; font-size: 10px; color: rgba(255, 255, 255, 0.45); } .inv-slot canvas { width: 34px; height: 34px; image-rendering: pixelated; filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.45)); } .inv-slot .item-icon { font-size: 26px; filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.45)); } .inv-slot .count { position: absolute; right: 8px; bottom: 6px; font-size: 11px; font-weight: 900; color: #fff; text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7); } .inv-preview-box { width: 88px; height: 88px; border-radius: 22px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.11), rgba(255, 255, 255, 0.05)); border: 1px solid rgba(255, 255, 255, 0.12); box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35); display: flex; align-items: center; justify-content: center; margin-bottom: 4px; } .inv-preview-box canvas { width: 56px; height: 56px; image-rendering: pixelated; filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.45)); } .inv-preview-box .item-icon { font-size: 48px; } .inv-item-name { font-size: 20px; font-weight: 900; color: var(--gold); line-height: 1.1; } .inv-item-meta { font-size: 12px; color: rgba(255, 255, 255, 0.65); margin-top: -4px; } .inv-item-desc { font-size: 12px; color: rgba(255, 255, 255, 0.58); line-height: 1.45; margin-top: 4px; min-height: 44px; } .inv-action-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 6px; } .inv-btn { padding: 10px 12px; border-radius: 14px; border: 1px solid rgba(255, 255, 255, 0.15); background: rgba(255, 255, 255, 0.06); color: #fff; font-weight: 800; cursor: pointer; transition: transform 0.12s ease, background 0.12s ease, filter 0.12s ease; } .inv-btn:hover { background: rgba(255, 255, 255, 0.10); transform: translateY(-1px); } .inv-btn:disabled { opacity: 0.45; cursor: not-allowed; transform: none; } .inv-btn.primary { background: linear-gradient(135deg, rgba(108, 92, 231, 0.95), rgba(162, 155, 254, 0.75)); border-color: rgba(108, 92, 231, 0.55); } .inv-btn.danger { background: linear-gradient(135deg, rgba(214, 48, 49, 0.90), rgba(232, 67, 147, 0.65)); border-color: rgba(214, 48, 49, 0.55); } .inv-btn.danger:hover { filter: brightness(1.05); } .inv-hints { margin-top: auto; font-size: 11px; color: rgba(255, 255, 255, 0.45); line-height: 1.55; } .inv-hints kbd { background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.12); padding: 1px 6px; border-radius: 7px; font-size: 10px; color: rgba(255, 255, 255, 0.75); } #inv-held { position: fixed; left: 0; top: 0; transform: translate(-50%, -50%); width: 52px; height: 52px; border-radius: 16px; background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(var(--glass-blur)); border: 1px solid rgba(255, 255, 255, 0.15); box-shadow: 0 18px 38px rgba(0, 0, 0, 0.45); display: none; align-items: center; justify-content: center; pointer-events: none; z-index: 525; } #inv-held canvas { width: 34px; height: 34px; image-rendering: pixelated; } #inv-held .item-icon { font-size: 28px; } #inv-held .count { position: absolute; right: 8px; bottom: 7px; font-weight: 900; font-size: 11px; color: #fff; text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7); }  html.is-mobile #inventory-panel { width: min(94vw, 940px); height: min(92vh, 720px); flex-direction: column; } html.is-mobile .inv-left { border-right: none; border-bottom: 1px solid rgba(255, 255, 255, 0.06); } html.is-mobile .inv-grid { gap: 8px; } html.is-mobile .inv-slot { height: 48px; border-radius: 13px; } html.is-mobile .inv-slot canvas { width: 30px; height: 30px; } html.is-mobile .inv-slot .item-icon { font-size: 24px; } html.is-mobile .inv-action-row { grid-template-columns: 1fr; } html.is-mobile .inv-preview-box { width: 72px; height: 72px; border-radius: 20px; } html.is-mobile #btn-bag-toggle { display: flex; top: 130px; left: 15px; width: 42px; height: 42px; border-radius: 12px; background: rgba(30, 30, 60, 0.8); backdrop-filter: blur(var(--glass-blur)); border: 1px solid rgba(255, 255, 255, 0.2); justify-content: center; align-items: center; font-size: 20px; pointer-events: auto; color: #fff; z-index: 90; } </style>
    <style>
        :root {
            --primary: #6c5ce7;
            --secondary: #a29bfe;
            --accent: #fd79a8;
            --gold: #ffeaa7;
            --health: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 50%, #d63031 100%);
            --mana: linear-gradient(135deg, #74b9ff 0%, #0984e3 50%, #6c5ce7 100%);
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            /* ç»ç’ƒæ‹Ÿæ€ Tokenï¼ˆå¤ç”¨/é›†ä¸­ï¼‰ */
            --glass-bg: var(--glass);
            --glass-bd: var(--glass-border);
            --glass-blur: 10px;
            --glow-shadow: var(--glow);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --glow: 0 0 20px rgba(108, 92, 231, 0.5);

            /* ç»Ÿä¸€ HUD Tokenï¼ˆæŒ–æ˜æ¡ / è¡€æ¡ / è“æ¡ å¯¹é½ï¼‰ */
            --hud-bg: rgba(15, 18, 40, 0.62);
            --hud-border: rgba(255, 255, 255, 0.18);
            --hud-blur: 12px;
            --hud-radius: 14px;
            --hud-shadow:
                0 12px 35px rgba(0, 0, 0, 0.45),
                0 0 0 1px rgba(255, 255, 255, 0.06) inset,
                0 0 18px rgba(108, 92, 231, 0.25);

            /* ç»Ÿä¸€é‡‘/ç´«æ¸å˜ï¼ˆæ ‡é¢˜/æŒ‰é’®/é«˜äº®ï¼‰ */
            --gold-grad: linear-gradient(135deg, var(--gold) 0%, var(--accent) 50%, var(--secondary) 100%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        button {
            font: inherit;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
            font-family: system-ui, system-ui, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ç»ç’ƒæ€UIå±‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• çŠ¶æ€æ  - ç°ä»£ç»ç’ƒæ€ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #stats {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transform-origin: top left;
        }

        .stat-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(var(--hud-blur));
            -webkit-backdrop-filter: blur(var(--hud-blur));
            background: var(--hud-bg);
            border: 1px solid var(--hud-border);
            border-radius: var(--hud-radius);
            padding: 6px 12px 6px 8px;
            box-shadow: var(--hud-shadow);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .stat-bar:hover {
            transform: scale(1.05);
        }

        .stat-bar .icon {
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .stat-bar .bar {
            width: 130px;
            height: 18px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stat-bar .fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
        }

        .stat-bar .fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            100% {
                left: 100%;
            }
        }

        #health-fill {
            background: var(--health);
        }

        #mana-fill {
            background: var(--mana);
        }

        .stat-bar .value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• å¿«æ·æ  - è±ªåç‰ˆ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #hotbar {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.9), rgba(20, 20, 40, 0.95));
            padding: 10px 14px;
            border-radius: 20px;
            border: 2px solid rgba(108, 92, 231, 0.3);
            box-shadow: var(--shadow), var(--glow), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .slot {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, rgba(50, 50, 80, 0.8), rgba(30, 30, 50, 0.9));
            border: 2px solid rgba(100, 100, 150, 0.4);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: hidden;
        }

        .slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            border-radius: 10px;
            pointer-events: none;
        }

        .slot:hover {
            transform: translateY(-3px);
            border-color: rgba(162, 155, 254, 0.6);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.3);
        }

        .slot.active {
            border-color: var(--gold);
            box-shadow: 0 0 25px rgba(255, 234, 167, 0.6), 0 0 50px rgba(255, 234, 167, 0.3);
            transform: translateY(-5px) scale(1.08);
            background: linear-gradient(145deg, rgba(70, 60, 100, 0.9), rgba(50, 40, 70, 0.95));
        }

        .slot.active::after {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, var(--gold), var(--accent), var(--gold));
            border-radius: 14px;
            z-index: -1;
            animation: borderGlow 2s linear infinite;
        }

        @keyframes borderGlow {

            0%,
            100% {
                opacity: 0.8;
            }

            50% {
                opacity: 1;
            }
        }

        .slot canvas {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .slot .item-icon {
            font-size: 26px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .slot .count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 11px;
            font-weight: 700;
            color: var(--gold);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8), 0 0 10px rgba(255, 234, 167, 0.5);
        }

        .slot .key {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 9px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.5);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .slot.empty {
            opacity: 0.4;
            background: linear-gradient(145deg, rgba(30, 30, 50, 0.6), rgba(20, 20, 30, 0.7));
        }

        .slot.empty:hover {
            opacity: 0.6;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• å°åœ°å›¾ - å…¨æ¯é£æ ¼ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #minimap {
            position: absolute;
            contain: layout paint;
            /* transform åŠ¨ç”»æ›´ GPU å‹å¥½ï¼ˆå±•å¼€/æ”¶èµ·ä¸å†è§¦å‘å¸ƒå±€ï¼‰ */
            --mm-sx: 1;
            --mm-sy: 1;
            will-change: transform;
            right: 15px;
            bottom: 15px;
            top: auto;
            width: 160px;
            height: 100px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.85), rgba(10, 10, 30, 0.9));
            border: 2px solid rgba(108, 92, 231, 0.4);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: var(--shadow), 0 0 30px rgba(108, 92, 231, 0.2);
            cursor: pointer;
            user-select: none;
            pointer-events: auto;
            transition: transform 220ms cubic-bezier(0.2, 0.9, 0.2, 1), border-radius 220ms cubic-bezier(0.2, 0.9, 0.2, 1);
            transform-origin: bottom right;
            transform: translateZ(0) scale(var(--mm-sx), var(--mm-sy));
        }

        #minimap::before {
            content: 'ğŸ—ºï¸ MAP (ç‚¹å‡»å±•å¼€)';
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.55);
            letter-spacing: 2px;
            z-index: 10;
            pointer-events: none;
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            opacity: 0.9;
        }

        #minimap::after {
            content: '';
            position: absolute;
            inset: 0;
            /* åŸæ–‡ä»¶è¿™é‡Œçš„æ¸å˜å†™æ³•æœ‰æˆªæ–­å­—ç¬¦ï¼Œä¿ç•™åŸæ€è·¯å¹¶ä¿®æ­£ä¸ºå¯ç”¨å€¼ */
            background: linear-gradient(180deg, rgba(108, 92, 231, 0.15) 0%, transparent 30%, transparent 70%, rgba(108, 92, 231, 0.10) 100%);
            pointer-events: none;
            border-radius: 14px;
        }

        
        #minimap.minimap-collapsed {
            border-radius: 14px;
        }

        #minimap.minimap-collapsed::before {
            content: 'ğŸ—ºï¸';
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            letter-spacing: 0;
            color: rgba(255, 255, 255, 0.85);
        }

        #minimap.minimap-collapsed canvas {
            opacity: 0;
        }

        #minimap.minimap-expanded {}

        #minimap.minimap-expanded::before {
            content: 'ğŸ—ºï¸ MAP (ç‚¹å‡»æ”¶èµ·)';
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• æŒ–æ˜è¿›åº¦æ¡ (æ–°ç‰ˆ HUD) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #mining-bar {
            --mb-accent: #ffeaa7;
            position: fixed;
            left: 0;
            top: 0;
            transform: translate(-50%, -100%) scale(0.98);
            min-width: 180px;
            max-width: min(240px, 78vw);
            padding: 10px 12px 10px 10px;
            border-radius: var(--hud-radius);
            background: var(--hud-bg);
            border: 1px solid var(--hud-border);
            box-shadow: var(--hud-shadow);
            backdrop-filter: blur(var(--hud-blur));
            -webkit-backdrop-filter: blur(var(--hud-blur));
            pointer-events: none;
            z-index: 9999;
            display: none;
            opacity: 0;
            will-change: transform, opacity, left, top;
            transition: opacity 140ms ease, transform 140ms ease;
        }

        #mining-bar.show {
            opacity: 1;
            transform: translate(-50%, -100%) scale(1);
        }

        #mining-bar::before {
            content: '';
            position: absolute;
            inset: -1px;
            border-radius: inherit;
            pointer-events: none;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
        }

        #mining-bar .mb-top {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        #mining-bar .mb-icon {
            width: 18px;
            height: 18px;
            flex: 0 0 18px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
            image-rendering: pixelated;
        }

        #mining-bar .mb-name {
            flex: 1 1 auto;
            min-width: 0;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.2px;
            color: rgba(255, 255, 255, 0.92);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #mining-bar .mb-percent {
            flex: 0 0 auto;
            font-size: 12px;
            font-variant-numeric: tabular-nums;
            color: rgba(255, 255, 255, 0.72);
        }

        #mining-bar .mb-track {
            position: relative;
            height: 9px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.35);
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.45);
        }

        #mining-bar .fill {
            position: relative;
            height: 100%;
            width: 0%;
            border-radius: 999px;
            background: linear-gradient(90deg,
                    var(--mb-accent) 0%,
                    rgba(255, 255, 255, 0.35) 28%,
                    #fd79a8 58%,
                    #6c5ce7 100%);
            background-size: 200% 100%;
            animation: miningGradient 0.9s linear infinite;
            transition: width 50ms linear;
            box-shadow: 0 0 14px rgba(253, 121, 168, 0.25);
        }

        #mining-bar .fill::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.28) 50%, rgba(255, 255, 255, 0) 100%);
            transform: translateX(-120%);
            animation: miningShine 1.15s ease-in-out infinite;
            opacity: 0.65;
        }

        @keyframes miningGradient {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 200% 50%;
            }
        }

        @keyframes miningShine {
            0% {
                transform: translateX(-120%);
            }

            65% {
                transform: translateX(120%);
            }

            100% {
                transform: translateX(120%);
            }
        }

        html.is-mobile #mining-bar {
            min-width: 160px;
            padding: 9px 11px 9px 9px;
            border-radius: 13px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• åŠ è½½ç•Œé¢ - å²è¯—çº§ */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            overflow: hidden;
        }

        #loading::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at 30% 30%, rgba(108, 92, 231, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(253, 121, 168, 0.1) 0%, transparent 50%);
            animation: bgFloat 20s ease-in-out infinite;
        }

        @keyframes bgFloat {

            0%,
            100% {
                transform: translate(-10%, -10%) rotate(0deg);
            }

            50% {
                transform: translate(10%, 10%) rotate(180deg);
            }
        }

        .loading-content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #loading h1 {
            font-family: system-ui, cursive;
            color: transparent;
            font-size: clamp(32px, 8vw, 64px);
            background: var(--gold-grad);
            -webkit-background-clip: text;
            background-clip: text;
            text-shadow: 0 0 60px rgba(255, 234, 167, 0.5);
            margin-bottom: 10px;
            animation: titleFloat 3s ease-in-out infinite;
            letter-spacing: 2px;
        }

        @keyframes titleFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        #loading .subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            margin-bottom: 40px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        #loading .progress {
            width: min(400px, 85vw);
            height: 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid rgba(108, 92, 231, 0.3);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), var(--glow);
            position: relative;
        }

        #loading .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--gold));
            background-size: 200% 100%;
            animation: progressGlow 2s linear infinite;
            width: 0%;
            transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 20px;
            position: relative;
        }

        #loading .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 20px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6));
            border-radius: 0 20px 20px 0;
        }

        @keyframes progressGlow {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 200% 50%;
            }
        }

        #loading .status {
            color: var(--secondary);
            margin-top: 20px;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .loading-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--gold);
            border-radius: 50%;
            animation: particleFloat 10s linear infinite;
            opacity: 0.6;
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 0.6;
            }

            90% {
                opacity: 0.6;
            }

            100% {
                transform: translateY(-100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ† - å…¨æ¯é£æ ¼ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 150;
        }

        .joystick-container {
            position: absolute;
            bottom: var(--joy-pad, 35px);
            left: var(--joy-pad, 35px);
            width: var(--joy-size, 140px);
            height: var(--joy-size, 140px);
            pointer-events: auto;
        }

        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(108, 92, 231, 0.3) 0%, rgba(30, 30, 60, 0.6) 100%);
            border: 3px solid rgba(162, 155, 254, 0.5);
            border-radius: 50%;
            box-shadow: inset 0 0 30px rgba(108, 92, 231, 0.3), 0 0 40px rgba(108, 92, 231, 0.2);
        }

        .joystick-base::before {
            content: '';
            position: absolute;
            inset: 15%;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }

        .joystick-thumb {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(162, 155, 254, 0.9), rgba(108, 92, 231, 0.8));
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4), 0 0 30px rgba(108, 92, 231, 0.5);
            transition: transform 0.08s ease-out;
        }

        .joystick-thumb::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            width: 30%;
            height: 30%;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
        }

        /* åŠ¨ä½œæŒ‰é’®åŒº */
        .action-buttons {
            position: absolute;
            bottom: 35px;
            right: 35px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            pointer-events: auto;
        }

        .action-row {
            display: flex;
            gap: 18px;
        }

        .action-btn {
            width: var(--btn-size, 70px);
            height: var(--btn-size, 70px);
            background: linear-gradient(135deg, rgba(80, 80, 120, 0.8), rgba(40, 40, 70, 0.9));
            border: 3px solid rgba(150, 150, 200, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--btn-size, 70px) * 0.43);
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4), inset 0 -2px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
        }

        .action-btn::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            width: 30%;
            height: 30%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }

        .action-btn.active {
            transform: scale(0.9);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4), 0 0 30px var(--gold), inset 0 2px 10px rgba(255, 255, 255, 0.2);
            border-color: var(--gold);
        }

        .action-btn.jump {
            background: linear-gradient(135deg, rgba(46, 213, 115, 0.8), rgba(39, 174, 96, 0.9));
            border-color: rgba(46, 213, 115, 0.6);
        }

        .action-btn.mine {
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.8), rgba(243, 156, 18, 0.9));
            border-color: rgba(241, 196, 15, 0.6);
        }

        .action-btn.place {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.8), rgba(41, 128, 185, 0.9));
            border-color: rgba(52, 152, 219, 0.6);
        }

        /* è·³è·ƒæŒ‰é’® - å·¦è¾¹ */
        .jump-container {
            position: absolute;
            bottom: 190px;
            left: 70px;
            pointer-events: auto;
        }

        /* ç›®æ ‡åå­—å‡†å¿ƒ */
        #crosshair {
            position: fixed;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 160;
            display: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: var(--gold);
            box-shadow: 0 0 10px var(--gold), 0 0 20px rgba(255, 234, 167, 0.5);
            border-radius: 2px;
        }

        #crosshair::before {
            width: 3px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 100%;
            height: 3px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• æ¡Œé¢ç«¯ä¿¡æ¯æç¤º â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            background: var(--glass);
            border: 1px solid var(--glass-border);
            padding: 12px 18px;
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            line-height: 1.6;
            box-shadow: var(--shadow);
        }

        #info .highlight {
            color: var(--gold);
            font-weight: 600;
            padding: 2px 6px;
            background: rgba(255, 234, 167, 0.15);
            border-radius: 4px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• å…¨å±æŒ‰é’® â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #fullscreen-btn {
            position: absolute;
            top: 15px;
            right: 185px;
            width: 42px;
            height: 42px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            background: var(--glass);
            border: 2px solid rgba(108, 92, 231, 0.4);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: var(--shadow);
        }

        #fullscreen-btn:hover {
            transform: scale(1.1);
            border-color: var(--secondary);
            box-shadow: var(--shadow), var(--glow);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FPSæ˜¾ç¤º â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #fps {
            position: absolute;
            top: 15px;
            right: 235px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            background: var(--glass);
            border: 1px solid var(--glass-border);
            padding: 8px 14px;
            border-radius: 10px;
            color: #2ecc71;
            font-size: 12px;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            box-shadow: var(--shadow);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• æ—¶é—´æ˜¾ç¤º â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #time-display {
            position: absolute;
            top: 70px;
            right: 15px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            background: var(--glass);
            border: 1px solid var(--glass-border);
            padding: 8px 14px;
            border-radius: 10px;
            color: var(--gold);
            font-size: 12px;
            font-weight: 600;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• å“åº”å¼å¸ƒå±€ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (pointer: coarse) {
            #mobile-controls {
                display: block;
            }

            #info {
                display: none;
            }

            #crosshair {
                display: block;
            }

            .slot {
                width: 42px;
                height: 42px;
            }

            .slot canvas {
                width: 26px;
                height: 26px;
            }

            .slot .key {
                display: none;
            }

            .slot .item-icon {
                font-size: 22px;
            }

            #hotbar {
                padding: 8px 10px;
                gap: 4px;
                border-radius: 16px;
            }

            #stats {
                transform: scale(0.9);
            }

            #minimap {
                width: 120px;
                height: 75px;
                border-radius: 12px;
                right: 20px;
                bottom: 130px;
                top: auto;
            }

            #fullscreen-btn {
                right: 145px;
                width: 38px;
                height: 38px;
            }

            #fps {
                right: 195px;
                padding: 6px 10px;
                font-size: 10px;
            }

            #time-display {
                top: 100px;
                right: 15px;
                font-size: 10px;
                padding: 6px 10px;
            }
        }

        @media (max-width: 480px) {
            .slot {
                width: 36px;
                height: 36px;
                border-radius: 10px;
            }

            .slot canvas {
                width: 22px;
                height: 22px;
            }

            .slot .count {
                font-size: 9px;
            }

            .slot .item-icon {
                font-size: 18px;
            }

            #hotbar {
                padding: 6px 8px;
                gap: 3px;
                border-radius: var(--hud-radius);
            }

            .joystick-container {
                position: absolute;
                bottom: var(--joy-pad, 35px);
                left: var(--joy-pad, 35px);
                width: var(--joy-size, 140px);
                height: var(--joy-size, 140px);
                pointer-events: auto;
            }

            .joystick-thumb {
                width: 50px;
                height: 50px;
            }

            .action-btn {
                width: 60px;
                height: 60px;
                font-size: 26px;
            }

            .action-buttons {
                bottom: 25px;
                right: 25px;
                gap: 12px;
            }

            .action-row {
                gap: 12px;
            }

            .jump-container {
                bottom: 160px;
                left: 55px;
            }

            #minimap {
                width: 90px;
                height: 55px;
            }

            #stats {
                transform: scale(0.8);
            }
        }

        /* JS å¼ºåˆ¶ç§»åŠ¨ç«¯æ¨¡å¼ï¼ˆå½“æŸäº›æµè§ˆå™¨åª’ä½“æŸ¥è¯¢/UA åˆ¤æ–­å¼‚å¸¸æ—¶ä½œä¸ºå…œåº•ï¼‰ */
        html.is-mobile #mobile-controls {
            display: block;
        }

        html.is-mobile #info {
            display: none;
        }

        html.is-mobile #crosshair {
            display: block;
        }

        html.is-mobile .slot {
            width: 42px;
            height: 42px;
        }

        html.is-mobile .slot canvas {
            width: 26px;
            height: 26px;
        }

        html.is-mobile .slot .key {
            display: none;
        }

        html.is-mobile .slot .item-icon {
            font-size: 22px;
        }

        html.is-mobile #hotbar {
            padding: 8px 10px;
            gap: 4px;
            border-radius: 16px;
        }

        html.is-mobile #stats {
            transform: scale(0.9);
        }

        html.is-mobile #minimap {
            width: 120px;
            height: 75px;
            border-radius: 12px;
            right: 20px;
            bottom: 130px;
            top: auto;
        }

        html.is-mobile #fullscreen-btn {
            right: 145px;
            width: 38px;
            height: 38px;
        }

        html.is-mobile #fps {
            right: 195px;
            padding: 6px 10px;
            font-size: 10px;
        }

        html.is-mobile #time-display {
            top: 100px;
            right: 15px;
            font-size: 10px;
            padding: 6px 10px;
        }

        /* ç§»åŠ¨ç«¯åˆæˆæŒ‰é’®/é¢æ¿ï¼ˆåœ¨â€œæ¨ªå± + å¤§å±æ‰‹æœºâ€æ—¶ï¼Œé¿å…ä»ç„¶èµ°æ¡Œé¢å¸ƒå±€ï¼‰ */
        html.is-mobile #btn-craft-toggle {
            display: flex;
            top: 80px;
            left: 15px;
            width: 42px;
            height: 42px;
            border-radius: 12px;
            background: rgba(30, 30, 60, 0.8);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid rgba(255, 255, 255, 0.2);
            justify-content: center;
            align-items: center;
            font-size: 20px;
            pointer-events: auto;
            color: #fff;
            z-index: 90;
        }

        html.is-mobile #crafting-panel {
            flex-direction: column;
            height: 90%;
        }

        html.is-mobile .craft-list-container {
            border-right: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        html.is-mobile .craft-details {
            padding: 20px;
        }

        html.is-mobile .preview-box {
            width: 60px;
            height: 60px;
        }

        /* iPad/å¤§å±è®¾å¤‡ï¼šç«–å±æ—¶ä¹Ÿæç¤ºæ¨ªå± */
        @media (orientation: portrait) {
            html.is-mobile #rotate-hint {
                display: flex !important;
            }
        }

        /* æ¨ªå±é”å®šæç¤º */
        @media (orientation: portrait) and (max-width: 768px) {
            #rotate-hint {
                display: flex !important;
            }
        }

        #rotate-hint {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0c0c1e, #1a1a2e);
            z-index: 2000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
        }

        #rotate-hint .icon {
            font-size: 80px;
            animation: rotatePhone 2s ease-in-out infinite;
            filter: drop-shadow(0 0 20px var(--secondary));
        }

        #rotate-hint p {
            margin-top: 30px;
            font-size: 18px;
            color: var(--secondary);
            letter-spacing: 1px;
        }

        @keyframes rotatePhone {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(90deg);
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• åˆæˆç•Œé¢ - ç»ˆæç¾å­¦ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #crafting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(12, 12, 30, 0.6);
            backdrop-filter: none;
            z-index: 500;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: auto;
            contain: layout paint;
            will-change: opacity, transform;
        }

        #crafting-overlay.open {
            display: flex;
            opacity: 1;
        }

        #crafting-panel {
            width: min(700px, 90%);
            height: min(500px, 85%);
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.9), rgba(20, 20, 40, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #crafting-overlay.open #crafting-panel {
            transform: scale(1);
        }

        /* å·¦ä¾§åˆ—è¡¨åŒº */
        .craft-list-container {
            flex: 1.2;
            padding: 20px;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.1);
        }

        .craft-header {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .craft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .craft-grid::-webkit-scrollbar {
            width: 4px;
        }

        .craft-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .craft-slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .craft-slot:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .craft-slot.selected {
            background: linear-gradient(135deg, rgba(108, 92, 231, 0.2), rgba(108, 92, 231, 0.1));
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(108, 92, 231, 0.3);
        }

        .craft-slot.can-craft::after {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background: #00b894;
            border-radius: 50%;
            box-shadow: 0 0 5px #00b894;
        }

        .craft-slot canvas {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }

        /* å³ä¾§è¯¦æƒ…åŒº */
        .craft-details {
            flex: 1;
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            background: radial-gradient(circle at top right, rgba(108, 92, 231, 0.1), transparent 60%);
        }

        .preview-box {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border-radius: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .preview-box canvas {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
            filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.5));
        }

        .item-title {
            font-size: 20px;
            color: var(--gold);
            font-weight: 700;
            margin-bottom: 5px;
            text-align: center;
        }

        .item-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.4;
        }

        .ingredients-list {
            width: 100%;
            margin-bottom: auto;
        }

        .ingredient {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid transparent;
        }

        .ingredient.missing {
            border-color: rgba(255, 107, 107, 0.3);
            background: rgba(255, 107, 107, 0.05);
        }

        .ing-name {
            font-size: 12px;
            color: #fff;
        }

        .ing-count {
            font-size: 12px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.8);
        }

        .ing-count.ok {
            color: #55efc4;
        }

        .ing-count.bad {
            color: #ff7675;
        }

        .craft-btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(90deg, #6c5ce7, #a29bfe);
            color: white;
            font-size: 14px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .craft-btn:disabled {
            background: #2d3436;
            color: #636e72;
            cursor: not-allowed;
            box-shadow: none;
        }

        .craft-btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.5);
        }

        .craft-btn:not(:disabled):active {
            transform: translateY(0);
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: #fff;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        /* ç§»åŠ¨ç«¯åˆæˆæŒ‰é’® */
        #btn-craft-toggle {
            position: absolute;
            top: 15px;
            left: 15px;
            /* å·¦ä¸Šè§’ï¼Œstatsä¸‹é¢ä¸€ç‚¹? æˆ–è€…statså³è¾¹ */
            display: none;
        }

        @media (max-width: 768px) {
            #btn-craft-toggle {
                display: flex;
                top: 80px;
                left: 15px;
                /* Statsä¸‹é¢ */
                width: 42px;
                height: 42px;
                border-radius: 12px;
                background: rgba(30, 30, 60, 0.8);
                backdrop-filter: blur(var(--glass-blur));
                border: 1px solid rgba(255, 255, 255, 0.2);
                justify-content: center;
                align-items: center;
                font-size: 20px;
                pointer-events: auto;
                color: #fff;
                z-index: 90;
            }

            #crafting-panel {
                flex-direction: column;
                height: 90%;
            }

            .craft-list-container {
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .craft-details {
                padding: 20px;
            }

            .preview-box {
                width: 60px;
                height: 60px;
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ç¯å¢ƒç²’å­ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #ambient-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            overflow: hidden;
        }

        .firefly {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--gold);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--gold), 0 0 20px var(--gold);
            animation: fireflyFloat 8s ease-in-out infinite;
            opacity: 0;
        }

        @keyframes fireflyFloat {

            0%,
            100% {
                opacity: 0;
                transform: translateY(0) translateX(0);
            }

            10% {
                opacity: 0.8;
            }

            50% {
                opacity: 0.4;
                transform: translateY(-100px) translateX(50px);
            }

            90% {
                opacity: 0.8;
            }
        }

        
        .raindrop {
            position: absolute;
            width: 2px;
            height: 14px;
            border-radius: 2px;
            background: linear-gradient(to bottom, rgba(180, 220, 255, 0), rgba(180, 220, 255, 0.9));
            opacity: 0.6;
            transform: translate3d(0, -20vh, 0) rotate(12deg);
            animation: rainFall 0.9s linear infinite;
            pointer-events: none;
        }

        @keyframes rainFall {
            from {
                transform: translate3d(0, -20vh, 0) rotate(12deg);
            }

            to {
                transform: translate3d(0, 120vh, 0) rotate(12deg);
            }
        }

        .snowflake {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.55);
            opacity: 0.85;
            transform: translate3d(0, -10vh, 0);
            animation: snowFall 7s linear infinite;
            pointer-events: none;
        }

        @keyframes snowFall {
            from {
                transform: translate3d(0, -10vh, 0);
            }

            to {
                transform: translate3d(var(--drift, 0px), 120vh, 0);
            }
        }

        
        :root {
            --weather-hue: 0deg;
            --weather-sat: 1;
            --weather-bright: 1;
            --weather-contrast: 1;
        }

        body.weather-on #game {
            filter: hue-rotate(var(--weather-hue)) saturate(var(--weather-sat)) brightness(var(--weather-bright)) contrast(var(--weather-contrast));
        }

        body:not(.weather-on) #game {
            filter: none;
        }

        

        .ux-val {
            display: inline-block;
            margin-left: 6px;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.92);
            background: rgba(255, 255, 255, 0.10);
            border: 1px solid rgba(255, 255, 255, 0.14);
            vertical-align: middle;
        }

        /* é€‰ä¸­ç‰©å“æç¤ºï¼ˆé¡¶éƒ¨çƒ­é”®æ ä¸‹æ–¹ï¼‰ */
        .item-hint {
            position: absolute;
            top: 72px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            padding: 6px 10px;
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.38);
            border: 1px solid rgba(255, 255, 255, 0.16);
            color: rgba(255, 255, 255, 0.92);
            font-size: 12px;
            letter-spacing: 0.2px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.55);
            opacity: 0;
            transition: opacity 0.18s ease;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            max-width: min(380px, 86vw);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .item-hint.show {
            opacity: 1;
        }

        html.is-mobile .item-hint {
            top: 76px;
            font-size: 11px;
        }

        /* å¸®åŠ©é¢æ¿ï¼šæŒ‰è®¾å¤‡æ˜¾ç¤º */
        #help-overlay .help-mobile {
            display: none;
        }

        html.is-mobile #help-overlay .help-mobile {
            display: grid;
        }

        html.is-mobile #help-overlay .help-desktop {
            display: none;
        }
    </style>

    <style id="tu-frost-theme">
        /* ---------------------------------------------------------
   Frosted Glass UI v2 (ç»Ÿä¸€ç£¨ç ‚æ¯›ç»ç’ƒé£æ ¼ï¼šæš‚åœ/è®¾ç½®/èƒŒåŒ…/åˆæˆ/æŒ‰é’®)
   ç›®æ ‡ï¼šè®©æ‰€æœ‰é¢æ¿çœ‹èµ·æ¥æ›´æ¥è¿‘â€œæŒ–æ˜è¿›åº¦æ¡â€çš„åŠé€æ˜ç£¨ç ‚è´¨æ„Ÿ
----------------------------------------------------------*/
        :root {
            --tu-glass-bg: rgba(15, 18, 40, 0.62);
            --tu-glass-bg-strong: rgba(12, 14, 32, 0.82);
            --tu-glass-border: rgba(255, 255, 255, 0.18);
            --tu-glass-border-soft: rgba(255, 255, 255, 0.12);
            --tu-glass-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
            --tu-glass-blur: 14px;
            --tu-glass-radius: 18px;

            --tu-text: rgba(255, 255, 255, 0.92);
            --tu-muted: rgba(255, 255, 255, 0.68);

            --tu-accent: rgba(108, 92, 231, 0.75);
            --tu-accent2: rgba(253, 121, 168, 0.55);
        }

        body.tu-modal-open {
            overflow: hidden;
            overscroll-behavior: none;
            touch-action: none;
        }

        /* ç»Ÿä¸€é®ç½©ï¼šæ›´æŸ”å’Œçš„æš—åŒ– + æ›´æ˜æ˜¾çš„æ¯›ç»ç’ƒ */
        .ux-overlay {
            background: rgba(0, 0, 0, 0.48) !important;
            backdrop-filter: blur(10px) saturate(1.25) !important;
            -webkit-backdrop-filter: blur(10px) saturate(1.25) !important;
        }

        /* ç»Ÿä¸€é¢æ¿ï¼šæ›´è´´è¿‘æŒ–æ˜è¿›åº¦æ¡çš„ç£¨ç ‚åŠé€æ˜ */
        .ux-panel,
        #inventory-panel,
        #crafting-panel {
            background: var(--tu-glass-bg) !important;
            border: 1px solid var(--tu-glass-border) !important;
            border-radius: var(--tu-glass-radius) !important;
            box-shadow: var(--tu-glass-shadow), 0 0 0 1px rgba(255, 255, 255, 0.06) inset !important;
            backdrop-filter: blur(var(--tu-glass-blur)) saturate(1.25) !important;
            -webkit-backdrop-filter: blur(var(--tu-glass-blur)) saturate(1.25) !important;
            position: relative;
        }

        /* å†…å±‚â€œé«˜å…‰â€æè¾¹ï¼ˆæ›´åƒç£¨ç ‚ç»ç’ƒæŠ˜å°„ï¼‰ */
        .ux-panel::before,
        #inventory-panel::before,
        #crafting-panel::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: inherit;
            pointer-events: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.03));
            opacity: 0.85;
            mix-blend-mode: screen;
        }

        /* æ ‡é¢˜æ æ›´â€œHUDåŒ–â€ */
        .ux-title {
            padding-bottom: 10px !important;
            margin-bottom: 12px !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.10) !important;
        }

        .ux-title h2 {
            color: var(--tu-text) !important;
            letter-spacing: 0.3px;
        }

        /* ç»Ÿä¸€æŒ‰é’®ï¼ˆåŒ…å«æš‚åœ/è®¾ç½®/å¸®åŠ©é¢æ¿æŒ‰é’®ã€èƒŒåŒ…/åˆæˆæŒ‰é’®ï¼‰ */
        .ux-action,
        .inv-btn,
        .craft-btn,
        #craft-action-btn {
            background: rgba(255, 255, 255, 0.08) !important;
            border: 1px solid rgba(255, 255, 255, 0.18) !important;
            color: var(--tu-text) !important;
            backdrop-filter: blur(12px) saturate(1.15) !important;
            -webkit-backdrop-filter: blur(12px) saturate(1.15) !important;
            box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35) !important;
            transition: transform 0.12s ease, background 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease !important;
        }

        .ux-action:hover,
        .inv-btn:hover,
        .craft-btn:hover,
        #craft-action-btn:hover {
            transform: translateY(-1px);
            border-color: rgba(255, 255, 255, 0.26) !important;
            box-shadow: 0 14px 30px rgba(0, 0, 0, 0.42) !important;
        }

        .ux-action:active,
        .inv-btn:active,
        .craft-btn:active,
        #craft-action-btn:active {
            transform: translateY(0px);
        }

        /* Primary æŒ‰é’®ï¼šæŸ”å’Œæ¸å˜å¼ºè°ƒï¼ˆæ›´è´´è¿‘æŒ–æ˜æ¡çš„é«˜äº®ï¼‰ */
        .ux-action.primary,
        .inv-btn.primary,
        #craft-action-btn.primary {
            background: linear-gradient(135deg, rgba(108, 92, 231, 0.58), rgba(253, 121, 168, 0.22)) !important;
            border-color: rgba(162, 155, 254, 0.56) !important;
        }

        /* Close/å°æŒ‰é’®ï¼šæ›´åƒHUDä¸Šçš„ç£¨ç ‚å°ç‰‡ */
        .ux-close,
        .inv-close-btn,
        .close-btn {
            background: rgba(255, 255, 255, 0.08) !important;
            border: 1px solid rgba(255, 255, 255, 0.16) !important;
            color: var(--tu-text) !important;
            backdrop-filter: blur(12px) saturate(1.2) !important;
            -webkit-backdrop-filter: blur(12px) saturate(1.2) !important;
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.38) !important;
        }

        .ux-close:hover,
        .inv-close-btn:hover,
        .close-btn:hover {
            border-color: rgba(255, 255, 255, 0.26) !important;
        }

        /* è¡¨å•æ§ä»¶ï¼šç»Ÿä¸€ç£¨ç ‚ */
        .ux-panel select,
        .ux-panel input[type="text"],
        .ux-panel input[type="number"] {
            background: rgba(255, 255, 255, 0.06) !important;
            border: 1px solid rgba(255, 255, 255, 0.16) !important;
            color: var(--tu-text) !important;
            border-radius: 12px !important;
            backdrop-filter: blur(12px) !important;
            -webkit-backdrop-filter: blur(12px) !important;
        }

        .ux-panel small {
            color: var(--tu-muted) !important;
        }

        /* Rangeï¼šè®©è½¨é“/æ»‘å—æ›´ç²¾è‡´ */
        .ux-panel input[type="range"] {
            accent-color: rgba(162, 155, 254, 0.95);
        }

        .ux-panel input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.10);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .ux-panel input[type="range"]::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            margin-top: -6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 0, 0, 0.18);
        }

        /* èƒŒåŒ…æ ¼å­ï¼šå¾®è°ƒæ›´æ¥è¿‘â€œç»ç’ƒå°å—â€ */
        .inv-slot {
            background: rgba(255, 255, 255, 0.06) !important;
            border: 1px solid rgba(255, 255, 255, 0.14) !important;
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
        }

        .inv-slot:hover {
            border-color: rgba(255, 255, 255, 0.22) !important;
        }

        /* åˆæˆåˆ—è¡¨æ ¼å­åŒç† */
        .craft-grid .craft-item,
        .craft-grid button {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.14);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
        }

        /* Toast æ›´åƒ HUD */
        .toast {
            background: rgba(15, 18, 40, 0.66) !important;
            border: 1px solid rgba(255, 255, 255, 0.18) !important;
            backdrop-filter: blur(14px) saturate(1.2) !important;
            -webkit-backdrop-filter: blur(14px) saturate(1.2) !important;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55) !important;
        }

        
        html.no-backdrop .top-btn,
        html.no-backdrop .toast,
        html.no-backdrop .ux-panel,
        html.no-backdrop #inventory-panel,
        html.no-backdrop #crafting-panel,
        html.no-backdrop #hotbar,
        html.no-backdrop #minimap,
        html.no-backdrop #info,
        html.no-backdrop #mining-bar,
        html.no-backdrop .stat-bar,
        html.no-backdrop #inv-held {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            background: rgba(15, 18, 40, 0.92) !important;
            border-color: rgba(255, 255, 255, 0.18) !important;
        }

        html.no-backdrop .ux-overlay,
        html.no-backdrop #inventory-overlay,
        html.no-backdrop #crafting-overlay {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
    </style>
    <style id="tu-perf-mode">
        /* ---------------------------------------------------------
   Performance UI downgrade (AutoQuality / Low Power)
   - html.tu-low-power: QualityManager è¿›å…¥åå°æˆ–è‡ªåŠ¨é™æ¡£æ—¶å¯ç”¨
   - html.tu-quality-low: ä½“éªŒå±‚é™æ¡£ï¼ˆfps ä½ï¼‰æ—¶å¯ç”¨
   ç›®æ ‡ï¼šåœ¨ä¸å½±å“ç©æ³•çš„å‰æä¸‹ï¼Œæ˜¾è‘—å‡å°‘ GPU/åˆæˆå¼€é”€ï¼ˆbackdrop-filter / å¤§é˜´å½± / çº¯è£…é¥°åŠ¨ç”»ï¼‰
----------------------------------------------------------*/

        html.tu-low-power {
            /* åå°/ä½åŠŸè€—ï¼šå°½é‡â€œçœç”µä¼˜å…ˆâ€ */
            --hud-blur: 0px;
            --glass-blur: 0px;
            --tu-glass-blur: 0px;
            --glow: 0 0 0 rgba(0, 0, 0, 0);
            --glow-shadow: none;
            --hud-shadow: 0 10px 24px rgba(0, 0, 0, 0.42), 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
        }

        html.tu-quality-low {
            /* ä½å¸§ï¼šåœ¨ä¿ç•™å°‘é‡è´¨æ„Ÿçš„åŒæ—¶é™ä½æˆæœ¬ */
            --hud-blur: 6px;
            --glass-blur: 6px;
            --tu-glass-blur: 8px;
            --hud-shadow: 0 10px 28px rgba(0, 0, 0, 0.46), 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
        }

        /* å…³é—­æœ€åƒæ€§èƒ½çš„ backdrop-filterï¼ˆä»… UI é¢æ¿å±‚ï¼‰ */
        html.tu-low-power .top-btn,
        html.tu-low-power .toast,
        html.tu-low-power .ux-panel,
        html.tu-low-power #inventory-panel,
        html.tu-low-power #crafting-panel,
        html.tu-low-power #hotbar,
        html.tu-low-power #minimap,
        html.tu-low-power #info,
        html.tu-low-power #mining-bar,
        html.tu-low-power .stat-bar,
        html.tu-low-power #inv-held,
        html.tu-quality-low .top-btn,
        html.tu-quality-low .toast,
        html.tu-quality-low .ux-panel,
        html.tu-quality-low #inventory-panel,
        html.tu-quality-low #crafting-panel,
        html.tu-quality-low #hotbar,
        html.tu-quality-low #minimap,
        html.tu-quality-low #info,
        html.tu-quality-low #mining-bar,
        html.tu-quality-low .stat-bar,
        html.tu-quality-low #inv-held {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        /* çº¯è£…é¥°åŠ¨ç”»ï¼šåœ¨ä½åŠŸè€—/ä½æ¡£ä¸‹å…³é—­ */
        html.tu-low-power #health-fill::after,
        html.tu-low-power #mana-fill::after,
        html.tu-low-power .slot.active::before,
        html.tu-low-power #mining-bar .fill,
        html.tu-low-power #mining-bar .fill::after,
        html.tu-quality-low #health-fill::after,
        html.tu-quality-low #mana-fill::after,
        html.tu-quality-low .slot.active::before,
        html.tu-quality-low #mining-bar .fill,
        html.tu-quality-low #mining-bar .fill::after {
            animation: none !important;
        }

        /* ç¯å¢ƒ DOM ç²’å­ï¼šä½åŠŸè€—/ä½æ¡£ç›´æ¥å…³é—­ï¼ˆCanvas å·²æœ‰ç²’å­ç³»ç»Ÿï¼‰ */
        html.tu-low-power #ambient-particles,
        html.tu-quality-low #ambient-particles {
            display: none !important;
        }

        /* å›¾æ ‡ drop-shadowï¼šå¯çœä¸€ç‚¹åˆæˆå¼€é”€ */
        html.tu-low-power .stat-bar .icon,
        html.tu-quality-low .stat-bar .icon {
            filter: none !important;
        }
    </style>

    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CSSæ€§èƒ½ä¼˜åŒ– â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #game {
            will-change: transform;
        }

        .stat-bar,
        .hotbar-slot,
        .inv-slot {
            will-change: transform, opacity;
        }

        #minimap {
            will-change: contents;
        }

        .toast {
            will-change: transform, opacity;
        }

        /* å‡å°‘é‡ç»˜ */
        .action-btn,
        .top-btn {
            contain: layout style;
        }

        /* GPUåŠ é€Ÿ */
        #joystick,
        #joystick-thumb,
        #crosshair {
            transform: translateZ(0);
            backface-visibility: hidden;
        }
    </style>

    <style id="deep-optimization-styles-v3">
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• æ·±åº¦CSSä¼˜åŒ– v3 â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #game,
        .stat-bar,
        .hotbar-slot,
        #minimap,
        .action-btn {
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .inv-slot,
        .craft-item,
        .toast {
            contain: layout style paint;
        }

        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        .inv-grid,
        .craft-grid {
            will-change: scroll-position;
        }

        #stats,
        #hotbar,
        .action-buttons {
            contain: layout;
        }

        body {
            text-rendering: optimizeSpeed;
        }
    </style>

    <style>
        .low-perf #ambient-particles, .low-perf .vfx-layer { display: none !important; }
        #tu-perf-stats { font-family: monospace; }
    </style>

</head>
<body>
    <canvas id="game"></canvas>
    <!-- ç¯å¢ƒç²’å­ -->
    <div id="ambient-particles"></div>
    <!-- åŠ è½½ç•Œé¢ -->
    <div id="loading">
        <div class="loading-particles"></div>
        <div class="loading-content">
            <h1>âœ¨ TERRARIA ULTRA âœ¨</h1>
            <p class="subtitle">Aesthetic Edition</p>
            <div class="progress">
                <div class="progress-fill" id="load-progress"></div>
            </div>
            <div class="status" id="load-status">åˆå§‹åŒ–é­”æ³•å¼•æ“...</div>
        </div>
    </div>
    <!-- æ¨ªå±æç¤º -->
    <div id="rotate-hint">
        <div class="icon">ğŸ“±</div>
        <p>è¯·æ¨ªå±æ¸¸ç©ä»¥è·å¾—æœ€ä½³ä½“éªŒ</p>
    </div>
    <!-- åˆæˆç•Œé¢ -->
    <div id="crafting-overlay">
        <div id="crafting-panel">
            <div class="close-btn" id="craft-close">âœ•</div>
            <div class="craft-list-container">
                <div class="craft-header">
                    <span>ğŸ”¨ åˆ¶é€ </span>
                </div>
                <div class="craft-grid" id="craft-grid">
                    <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            <div class="craft-details">
                <div class="preview-box" id="craft-preview"></div>
                <div class="item-title" id="craft-title">é€‰æ‹©ç‰©å“</div>
                <div class="item-desc" id="craft-desc">ç‚¹å‡»å·¦ä¾§åˆ—è¡¨æŸ¥çœ‹é…æ–¹</div>
                <div class="ingredients-list" id="craft-ingredients">
                    <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>
                <button class="craft-btn" disabled="" id="craft-action-btn">åˆ¶é€ </button>
            </div>
        </div>
    </div>
    <!-- èƒŒåŒ…ç•Œé¢ -->
    <div aria-hidden="true" id="inventory-overlay">
        <div aria-label="èƒŒåŒ…" id="inventory-panel" role="dialog">
            <div class="inv-close-btn" id="inv-close" title="å…³é—­ (Esc)">âœ•</div>
            <div class="inv-left">
                <div class="inv-topbar">
                    <div class="inv-title">ğŸ’ èƒŒåŒ…</div>
                    <div class="inv-capacity">
                        <span class="inv-capacity-text" id="inv-capacity-text">0/36</span>
                        <div class="inv-capacity-bar">
                            <div class="fill" id="inv-capacity-fill"></div>
                        </div>
                    </div>
                </div>
                <div class="inv-section">
                    <div class="inv-section-label">å¿«æ·æ  <span style="opacity:.6">(1-9)</span></div>
                    <div class="inv-grid" id="inv-hotbar-grid"></div>
                </div>
                <div class="inv-section">
                    <div class="inv-section-label">èƒŒåŒ…</div>
                    <div class="inv-grid" id="inv-backpack-grid"></div>
                </div>
            </div>
            <div class="inv-right">
                <div class="inv-preview-box" id="inv-preview"></div>
                <div class="inv-item-name" id="inv-item-name">æœªé€‰æ‹©</div>
                <div class="inv-item-meta" id="inv-item-meta"></div>
                <div class="inv-item-desc" id="inv-item-desc">ç‚¹å‡»æ ¼å­æŸ¥çœ‹ï¼Œæˆ–æ‹–æ‹½/ç‚¹å‡»äº¤æ¢ã€‚</div>
                <div class="inv-action-row">
                    <button class="inv-btn primary" id="inv-sort">ğŸ§¹ æ•´ç†</button>
                    <button class="inv-btn" id="inv-to-hotbar">â†” æ”¾å…¥å¿«æ·æ </button>
                    <button class="inv-btn" id="inv-put-back">â†© æ”¾å›</button>
                    <button class="inv-btn danger" id="inv-drop">ğŸ—‘ ä¸¢å¼ƒ</button>
                </div>
                <div class="inv-hints">
                    <div><kbd>å·¦é”®</kbd> æ‹¿èµ·/æ”¾ä¸‹ã€€<kbd>å³é”®</kbd> æ‹†åˆ†/æ”¾ 1 ä¸ª</div>
                    <div><kbd>Shift</kbd>+<kbd>ç‚¹å‡»</kbd> å¿«é€Ÿç§»åŠ¨ã€€<kbd>B</kbd>/<kbd>I</kbd> æ‰“å¼€èƒŒåŒ…ã€€<kbd>Esc</kbd> å…³é—­</div>
                </div>
            </div>
        </div>
        <!-- å…‰æ ‡ç‰©å“ -->
        <div aria-hidden="true" id="inv-held"></div>
    </div>
    <!-- UX+ï¼šæš‚åœ / è®¾ç½® / å­˜æ¡£ -->
    <div aria-hidden="true" class="ux-overlay" id="pause-overlay">
        <div class="ux-panel">
            <div class="ux-title">
                <h2>â¸ å·²æš‚åœ</h2>
                <button aria-label="å…³é—­" class="ux-close" id="pause-close">âœ•</button>
            </div>
            <div class="ux-grid">
                <div class="ux-row">
                    <label>
                        <b>æç¤º</b>
                        <small>æš‚åœæ—¶æ¸¸æˆä¸ä¼šæ›´æ–°ï¼›ä½ ä»å¯æŸ¥çœ‹ç•Œé¢å¹¶è°ƒæ•´è®¾ç½®ã€‚</small>
                    </label>
                    <span> </span>
                </div>
            </div>
            <div class="ux-actions">
                <button class="ux-action" id="pause-newworld">ğŸ§¹ æ–°ä¸–ç•Œ</button>
                <button class="ux-action" id="pause-save">ğŸ’¾ ä¿å­˜</button>
                <button class="ux-action" id="pause-fullscreen">ğŸ–¥ å…¨å±</button>
                <button class="ux-action primary" id="pause-resume">â–¶ ç»§ç»­</button>
            </div>
        </div>
    </div>
    <div aria-hidden="true" class="ux-overlay" id="settings-overlay">
        <div class="ux-panel">
            <div class="ux-title">
                <h2>âš™ï¸ è®¾ç½®</h2>
                <button aria-label="å…³é—­" class="ux-close" id="settings-close">âœ•</button>
            </div>
            <div class="ux-grid">
                <div class="ux-row">
                    <label>
                        ç”»è´¨ / åˆ†è¾¨ç‡å€ç‡
                        <small>é™ä½å¯æ˜¾è‘—æå‡ä½ç«¯è®¾å¤‡å¸§ç‡ï¼ˆå»ºè®®ï¼šç§»åŠ¨ç«¯é€‰â€œçœç”µâ€ï¼‰ã€‚</small>
                    </label>
                    <select id="opt-dpr">
                        <option value="1">çœç”µ (1x)</option>
                        <option value="1.5">å‡è¡¡ (1.5x)</option>
                        <option value="2">é«˜æ¸… (2x)</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        ç²’å­æ•ˆæœ
                        <small>å…³é—­å¯å‡å°‘å¡é¡¿ä¸å‘çƒ­ã€‚</small>
                    </label>
                    <select id="opt-particles">
                        <option value="1">å¼€å¯</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        ç¯å¢ƒç‰¹æ•ˆï¼ˆè¤ç«è™«/èƒŒæ™¯ç²’å­ï¼‰
                        <small>å…³é—­å¯å‡å°‘ DOM åŠ¨ç”»å‹åŠ›ã€‚</small>
                    </label>
                    <select id="opt-ambient">
                        <option value="1">å¼€å¯</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>

                <div class="ux-row">
                    <label>
                        èƒŒæ™¯å¢™å±±è„‰ï¼ˆè¿œæ™¯ï¼‰
                        <span class="ux-tip">å…³é—­å¯å‡å°‘èƒŒæ™¯æ¸²æŸ“ä¸è¿‡åº¦ç»˜åˆ¶ï¼Œä½ç«¯æœºæ›´æµç•…</span>
                    </label>
                    <select id="opt-bgmountains">
                        <option value="1">å¼€å¯</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        åæœŸç”»é¢å¢å¼ºï¼ˆBloom/è‰²å½©/æš—è§’ï¼‰
                        <small>æå‡â€œé«˜çº§æ„Ÿâ€å’Œæ°›å›´ï¼›ä½ç«¯è®¾å¤‡å¯é€‰â€œè½»é‡/å…³é—­â€ã€‚</small>
                    </label>
                    <select id="opt-postfx">
                        <option value="2">æè‡´</option>
                        <option value="1">è½»é‡</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        å°åœ°å›¾
                        <small>ä¸éœ€è¦æ—¶å¯å…³é—­æå‡æ€§èƒ½ã€‚</small>
                    </label>
                    <select id="opt-minimap">
                        <option value="1">å¼€å¯</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        è§¦æ§è¾…åŠ©ç„å‡†
                        <small>ç§»åŠ¨ç«¯æ›´å®¹æ˜“é€‰ä¸­æ–¹å—ï¼ˆæŒ‰æ–¹å—ä¸­å¿ƒå¸é™„ï¼‰ã€‚</small>
                    </label>
                    <select id="opt-aimassist">
                        <option value="1">å¼€å¯</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        éœ‡åŠ¨åé¦ˆ
                        <small>æŒ–æ˜/æ”¾ç½®/åˆ‡æ¢ç‰©å“æ—¶è½»å¾®éœ‡åŠ¨ï¼ˆéœ€è®¾å¤‡æ”¯æŒï¼‰ã€‚</small>
                    </label>
                    <select id="opt-vibration">
                        <option value="1">å¼€å¯</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        è‡ªåŠ¨æ€§èƒ½è°ƒèŠ‚
                        <small>å¸§ç‡é™ä½æ—¶è‡ªåŠ¨é™ä½è¾‰å…‰/ç²’å­ï¼Œä¼˜å…ˆä¿è¯æµç•…ã€‚</small>
                    </label>
                    <select id="opt-autoquality">
                        <option value="1">å¼€å¯</option>
                        <option value="0">å…³é—­</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        æ˜¾ç¤º FPS
                        <small>è°ƒè¯•ç”¨ï¼Œå…³é—­æ›´æ¸…çˆ½ã€‚</small>
                    </label>
                    <select id="opt-showfps">
                        <option value="0">å…³é—­</option>
                        <option value="1">å¼€å¯</option>
                    </select>
                </div>
                <div class="ux-row">
                    <label>
                        é•œå¤´å¹³æ»‘ <span class="ux-val" id="val-camsmooth"></span>
                        <small>è¶Šå¤§è¶Šé¡ºæ»‘ä½†æ›´â€œæ…¢è·Ÿâ€ï¼›è¶Šå°è¶Šè·Ÿæ‰‹ä½†æ›´æŠ–ã€‚</small>
                    </label>
                    <input id="opt-camsmooth" max="18" min="3" step="1" type="range" />
                </div>
                <div class="ux-row">
                    <label>
                        é•œå¤´å‰ç» <span class="ux-val" id="val-lookahead"></span>
                        <small>å¥”è·‘æ—¶è§†é‡æ›´é å‰ï¼ŒæŒ–æ˜/æˆ˜æ–—æ›´èˆ’æœã€‚</small>
                    </label>
                    <input id="opt-lookahead" max="150" min="0" step="5" type="range" />
                </div>
                <div class="ux-row">
                    <label>
                        è¿ç»­æ”¾ç½®é€Ÿåº¦ <span class="ux-val" id="val-placeinterval"></span>
                        <small>æ•°å€¼è¶Šå°è¶Šå¿«ï¼ˆä¹Ÿæ›´è€—æ€§èƒ½ï¼‰ã€‚</small>
                    </label>
                    <input id="opt-placeinterval" max="160" min="40" step="5" type="range" />
                </div>
                <div class="ux-row">
                    <label>
                        è§¦æ§æ‘‡æ†å°ºå¯¸ <span class="ux-val" id="val-joy"></span>
                        <small>é€‚é…ä¸åŒå±å¹•ä¸æ‰‹å‹ã€‚</small>
                    </label>
                    <input id="opt-joy" max="190" min="110" step="5" type="range" />
                </div>
                <div class="ux-row">
                    <label>
                        è§¦æ§æŒ‰é”®å°ºå¯¸ <span class="ux-val" id="val-btn"></span>
                        <small>æŒ–æ˜/æ”¾ç½®/è·³è·ƒæŒ‰é’®å¤§å°ã€‚</small>
                    </label>
                    <input id="opt-btn" max="92" min="58" step="2" type="range" />
                </div>
                <div class="ux-row">
                    <label>
                        éŸ³æ•ˆéŸ³é‡ <span class="ux-val" id="val-sfx"></span>
                        <small>æ— éœ€èµ„æºæ–‡ä»¶ï¼Œä½¿ç”¨è½»é‡ WebAudioã€‚</small>
                    </label>
                    <input id="opt-sfx" max="100" min="0" step="1" type="range" />
                </div>
                <div class="ux-row">
                    <label>
                        å‡å°‘åŠ¨æ€æ•ˆæœ
                        <small>å‡å°‘åŠ¨ç”»/è¿‡æ¸¡ï¼Œç¼“è§£çœ©æ™•å¹¶æå‡æ€§èƒ½ã€‚</small>
                    </label>
                    <select id="opt-reduce-motion">
                        <option value="0">å…³é—­</option>
                        <option value="1">å¼€å¯</option>
                    </select>
                </div>
            </div>
            <div class="ux-actions">
                <button class="ux-action" id="settings-reset">â†© æ¢å¤é»˜è®¤</button>
                <button class="ux-action" id="settings-clear-save">ğŸ—‘ åˆ é™¤å­˜æ¡£</button>
                <button class="ux-action primary" id="settings-apply">âœ… åº”ç”¨</button>
            </div>
        </div>
    </div>
    <!-- å¸®åŠ© / æ–°æ‰‹æŒ‡å¼• -->
    <div aria-hidden="true" class="ux-overlay" id="help-overlay">
        <div class="ux-panel">
            <div class="ux-title">
                <h2>â” æ“ä½œä¸æŠ€å·§</h2>
                <button aria-label="å…³é—­" class="ux-close" id="help-close">âœ•</button>
            </div>
            <div class="ux-grid">
                <div class="ux-row help-desktop">
                    <label>
                        <b>é”®ç›˜é¼ æ ‡</b>
                        <small>
                            <span class="highlight">A/D</span> ç§»åŠ¨ï¼Œ<span class="highlight">W/ç©ºæ ¼</span> è·³è·ƒï¼Œ<span
                                class="highlight">Shift</span> å†²åˆº<br />
                            <span class="highlight">å·¦é”®</span> æŒ–æ˜ï¼Œ<span class="highlight">å³é”®</span> æ”¾ç½®ï¼Œ<span
                                class="highlight">1-9</span> åˆ‡æ¢ç‰©å“<br />
                            <span class="highlight">E</span> æ‰“å¼€å·¥ä½œå° / åˆæˆï¼Œ<span class="highlight">Esc</span> æš‚åœ
                        </small>
                    </label>
                    <span></span>
                </div>
                <div class="ux-row help-mobile">
                    <label>
                        <b>è§¦æ§</b>
                        <small>
                            å·¦ä¸‹ <span class="highlight">æ‘‡æ†</span> ç§»åŠ¨ï¼›å³ä¸‹æŒ‰é’®ï¼š<span class="highlight">â¤´</span> è·³è·ƒ / <span
                                class="highlight">âš’ï¸</span> æŒ–æ˜ / <span class="highlight">ğŸ§±</span> æ”¾ç½®<br />
                            åœ¨å±å¹•ä¸Š <span class="highlight">æ‹–åŠ¨</span> ä»¥ç§»åŠ¨å‡†æ˜Ÿï¼›æ‘‡æ†æ¨åˆ°åº•è‡ªåŠ¨å†²åˆº<br />
                            é¡¶éƒ¨å¿«æ·æ å¯ <span class="highlight">æ»‘åŠ¨</span> åˆ‡æ¢ç‰©å“
                        </small>
                    </label>
                    <span></span>
                </div>
                <div class="ux-row">
                    <label>
                        <b>å°åœ°å›¾</b>
                        <small>å³ä¸‹è§’å°åœ°å›¾ï¼šç‚¹å‡»å¯å±•å¼€/æŠ˜å ã€‚æŠ˜å åæ›´çœç”µã€‚</small>
                    </label>
                    <span></span>
                </div>
                <div class="ux-row">
                    <label>
                        <b>å­˜æ¡£</b>
                        <small>é¡¶éƒ¨ <span class="highlight">ğŸ’¾</span> æ‰‹åŠ¨ä¿å­˜ï¼›åˆ‡åå°ä¹Ÿä¼šè‡ªåŠ¨ä¿å­˜ã€‚</small>
                    </label>
                    <span></span>
                </div>
                <div class="ux-row">
                    <label>
                        <b>æ¨èè®¾ç½®ï¼ˆç§»åŠ¨ç«¯ï¼‰</b>
                        <small>å¼€å¯ <span class="highlight">è¾…åŠ©ç„å‡†</span>ï¼›å¡é¡¿æ—¶æŠŠ <span class="highlight">ç”»è´¨</span>
                            è°ƒåˆ°â€œçœç”µâ€ã€‚</small>
                    </label>
                    <span></span>
                </div>
            </div>
            <div class="ux-actions">
                <button class="ux-action" id="help-dontshow">âœ… ä¸å†æç¤º</button>
                <button class="ux-action primary" id="help-ok">çŸ¥é“äº†</button>
            </div>
        </div>
    </div>
    <!-- ç»§ç»­æ¸¸æˆ/æ–°ä¸–ç•Œæç¤ºï¼ˆä»…å½“æ£€æµ‹åˆ°å­˜æ¡£æ—¶æ˜¾ç¤ºï¼‰ -->
    <div aria-hidden="true" class="ux-overlay" id="save-prompt-overlay">
        <div class="ux-panel">
            <div class="ux-title">
                <h2>ğŸ—‚ æ£€æµ‹åˆ°å­˜æ¡£</h2>
                <button aria-label="å…³é—­" class="ux-close" id="save-prompt-close">âœ•</button>
            </div>
            <div class="ux-grid">
                <div class="ux-row">
                    <label>
                        ä½ æƒ³ç»§ç»­ä¸Šæ¬¡è¿›åº¦å—ï¼Ÿ
                        <small>ç»§ç»­ï¼šè¯»å–å­˜æ¡£ï¼›æ–°ä¸–ç•Œï¼šé‡æ–°ç”Ÿæˆå¹¶è¦†ç›–æ—§å­˜æ¡£ã€‚</small>
                    </label>
                    <span></span>
                </div>
            </div>
            <div class="ux-actions">
                <button class="ux-action" id="save-prompt-new">ğŸŒ± æ–°ä¸–ç•Œ</button>
                <button class="ux-action primary" id="save-prompt-continue">â–¶ ç»§ç»­</button>
            </div>
        </div>
    </div>
    <!-- ç§»åŠ¨ç«¯åˆæˆå…¥å£ (æ‚¬æµ®çƒ) -->
    <button id="btn-craft-toggle" aria-label="æ‰“å¼€åˆæˆ (E)" aria-keyshortcuts="E">âš’ï¸</button>
    <!-- ç§»åŠ¨ç«¯èƒŒåŒ…å…¥å£ (æ‚¬æµ®çƒ) -->
    <button id="btn-bag-toggle" style="position: absolute; top: 60%; right: 10px;" aria-label="æ‰“å¼€èƒŒåŒ… (B/I)"
        aria-keyshortcuts="B I">ğŸ’</button>
    <!-- UIå±‚ -->
    <div id="ui">
        <div id="top-buttons">
            <button class="top-btn" id="btn-pause" title="æš‚åœ/ç»§ç»­" aria-label="æš‚åœ/ç»§ç»­ (Esc/P)"
                aria-keyshortcuts="Escape P">â¸</button>
            <button class="top-btn" id="btn-settings" title="è®¾ç½®" aria-label="è®¾ç½® (O)" aria-keyshortcuts="O">âš™ï¸</button>
            <button class="top-btn" id="btn-save" title="æ‰‹åŠ¨ä¿å­˜" aria-label="ä¿å­˜ (Ctrl+S)"
                aria-keyshortcuts="Control+S Meta+S">ğŸ’¾</button>
            <button class="top-btn" id="btn-inventory" title="èƒŒåŒ… (B/I)" aria-label="èƒŒåŒ… (B/I)"
                aria-keyshortcuts="B I">ğŸ’</button>
            <button class="top-btn" id="btn-help" title="å¸®åŠ©/æ“ä½œ" aria-label="å¸®åŠ©/æ“ä½œ (H)" aria-keyshortcuts="H">â”</button>
        </div>
        <div id="toast-container"></div>
        <div id="hotbar"></div>
        <div aria-hidden="true" class="item-hint" id="item-hint"></div>
        <div id="stats">
            <div class="stat-bar">
                <span class="icon">ğŸ’–</span>
                <div class="bar">
                    <div class="fill" id="health-fill" style="width:100%"></div>
                    <span class="value" id="health-value">100/100</span>
                </div>
            </div>
            <div class="stat-bar">
                <span class="icon">ğŸ’«</span>
                <div class="bar">
                    <div class="fill" id="mana-fill" style="width:100%"></div>
                    <span class="value" id="mana-value">50/50</span>
                </div>
            </div>
        </div>
        <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
        <div id="fps" style="position: absolute; top: 70px; right: 100px;">60 FPS</div>
        <button id="fullscreen-btn" style="position: absolute; top: 50%; right: 10px; transform: translateY(-50%);"
            aria-label="å…¨å± (F)" aria-keyshortcuts="F">â›¶</button>
        <div id="time-display" style="position: absolute; top: 70px; right: 15px;"><span id="time-icon">â˜€ï¸</span> <span
                id="time-text">12:00</span></div>
        <div id="info">
            <span class="highlight">AD</span> ç§»åŠ¨ |
            <span class="highlight">Wå’Œç©ºæ ¼</span> è·³è·ƒ |
            <span class="highlight">å·¦é”®</span> æŒ–æ˜ |
            <span class="highlight">å³é”®</span> æ”¾ç½® |
            <span class="highlight">E</span> å·¥ä½œå° |
            <span class="highlight">B</span> èƒŒåŒ… |
            <span class="highlight">1-9</span> åˆ‡æ¢
        </div>
        <div aria-hidden="true" id="mining-bar">
            <div class="mb-top">
                <canvas class="mb-icon" height="18" id="mining-icon" width="18"></canvas>
                <div class="mb-name" id="mining-name">æŒ–æ˜ä¸­â€¦</div>
                <div class="mb-percent" id="mining-percent">0%</div>
            </div>
            <div class="mb-track">
                <div class="fill"></div>
            </div>
        </div>
    </div>
    <!-- ç§»åŠ¨ç«¯æ§åˆ¶å™¨ -->
    <div id="mobile-controls">
        <div class="joystick-container" id="joystick">
            <div class="joystick-base"></div>
            <div class="joystick-thumb" id="joystick-thumb"></div>
        </div>
        <div class="jump-container">
            <div class="action-btn jump" id="btn-jump">â¬†ï¸</div>
        </div>
        <div class="action-buttons">
            <div class="action-row">
                <div class="action-btn mine" id="btn-mine">â›ï¸</div>
                <div class="action-btn place" id="btn-place">ğŸ§±</div>
            </div>
        </div>
    </div>
    <!-- åå­—å‡†å¿ƒ -->
    <div id="crosshair"></div>
    <!-- ========================= GLOBAL NAMESPACE ========================= -->

    <!-- ========================= SECTION: Namespace & Global Guards ========================= -->

    <!-- ========================= MODULE: core/tu_namespace ========================= -->

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TERRARIA ULTRA - Aesthetic Edition (Refactored)
// Consolidated single-script architecture. All patches merged into class defs.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"use strict";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 1: SafeUtils - Lightweight utility module
//   (Replaces redundant TU_Defensive v1-v4, TU_SAFE, SafeAccess, etc.)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const SafeUtils = (() => {
    // Error tracking
    let errorCount = 0;
    const MAX_ERRORS = 100;

    window.onerror = (msg, url, line, col, error) => {
        errorCount++;
        console.error('[Error #' + errorCount + ']', { msg, url, line, col, error });
        if (errorCount > MAX_ERRORS) {
            console.error('[CRITICAL] Error threshold exceeded');
            if (window.game && typeof window.game.pause === 'function') window.game.pause();
        }
        return false;
    };

    window.addEventListener('unhandledrejection', (e) => {
        errorCount++;
        console.error('[Unhandled Rejection #' + errorCount + ']', e.reason);
        e.preventDefault();
    });

    return Object.freeze({
        // Math
        clamp: (v, min, max) => v < min ? min : v > max ? max : v,
        clampInt: (v, min, max) => { v = v | 0; return v < min ? min : v > max ? max : v; },
        lerp: (a, b, t) => a + (b - a) * t,
        divFloor: (n, d) => d === 0 ? 0 : Math.floor(n / d),
        toInt32: (v) => { const n = Number(v); return Number.isFinite(n) ? n | 0 : 0; },

        // Type checks
        isNum: (v) => typeof v === 'number' && !isNaN(v) && isFinite(v),
        isInt: (v) => Number.isInteger(v),
        isFunc: (v) => typeof v === 'function',
        isObj: (v) => v !== null && typeof v === 'object' && !Array.isArray(v),

        // World access
        getTile: (world, x, y, def = 0) => {
            if (!world || !world.tiles) return def;
            x = x | 0; y = y | 0;
            if (x < 0 || x >= world.w || y < 0 || y >= world.h) return def;
            const col = world.tiles[x];
            return col ? (col[y] !== undefined ? col[y] : def) : def;
        },
        setTile: (world, x, y, value) => {
            if (!world || !world.tiles) return false;
            x = x | 0; y = y | 0;
            if (x < 0 || x >= world.w || y < 0 || y >= world.h) return false;
            const col = world.tiles[x];
            if (!col) return false;
            col[y] = value;
            return true;
        },
        getLight: (world, x, y, def = 0) => {
            if (!world || !world.light) return def;
            x = x | 0; y = y | 0;
            if (x < 0 || x >= world.w || y < 0 || y >= world.h) return def;
            const col = world.light[x];
            return col ? (col[y] !== undefined ? col[y] : def) : def;
        },
        setLight: (world, x, y, value) => {
            if (!world || !world.light) return false;
            x = x | 0; y = y | 0;
            if (x < 0 || x >= world.w || y < 0 || y >= world.h) return false;
            const col = world.light[x];
            if (!col) return false;
            col[y] = value;
            return true;
        },

        // JSON
        jsonParse: (str, def = null) => { try { return JSON.parse(str); } catch { return def; } },
        jsonStringify: (obj, def = '{}') => { try { return JSON.stringify(obj); } catch { return def; } },

        // Error reporting (rate-limited)
        _errors: [],
        _lastReport: 0,
        reportError: (error, ctx = {}) => {
            const now = Date.now();
            if (now - SafeUtils._lastReport < 100) return;
            if (SafeUtils._errors.length >= 50) return;
            SafeUtils._lastReport = now;
            SafeUtils._errors.push({ message: error?.message || String(error), context: ctx, timestamp: now });
            console.error('[Error]', error?.message || error, ctx);
        },

        // Resource cleanup
        _intervals: [],
        _timeouts: [],
        _rafs: [],
        registerInterval: (id) => { SafeUtils._intervals.push(id); return id; },
        registerTimeout: (id) => { SafeUtils._timeouts.push(id); return id; },
        registerRAF: (id) => { SafeUtils._rafs.push(id); return id; },
        disposeAll: () => {
            SafeUtils._intervals.forEach(id => clearInterval(id));
            SafeUtils._timeouts.forEach(id => clearTimeout(id));
            SafeUtils._rafs.forEach(id => cancelAnimationFrame(id));
            SafeUtils._intervals.length = 0;
            SafeUtils._timeouts.length = 0;
            SafeUtils._rafs.length = 0;
        }
    });
})();

// Global convenience functions (backward compat)
const clamp = SafeUtils.clamp;
const lerp = SafeUtils.lerp;
const safeGet = (arr, idx, def) => (!arr || idx < 0 || idx >= arr.length) ? def : arr[idx];
const safeGetProp = (obj, prop, def) => (obj && typeof obj === 'object') ? (obj[prop] !== undefined ? obj[prop] : def) : def;
const safeJSONParse = SafeUtils.jsonParse;
const safeJSONStringify = SafeUtils.jsonStringify;
const worldGetTile = SafeUtils.getTile;
const worldSetTile = SafeUtils.setTile;
const worldGetLight = SafeUtils.getLight;
const worldSetLight = SafeUtils.setLight;

// Legacy compat aliases
window.TU_Defensive = SafeUtils;
window.TU_DEFENSIVE = SafeUtils;
window.TU_SAFE = { reportError: SafeUtils.reportError };

// Loading screen stuck protection
(() => {
    const TIMEOUT = 30000, CHECK_MS = 1000;
    let startTime = Date.now(), lastProgress = 0, stuckCount = 0;
    const check = () => {
        const el = document.getElementById('loading');
        if (!el || el.style.display === 'none') return;
        const prog = document.getElementById('load-progress');
        const cur = prog ? parseInt(prog.style.width || '0') : 0;
        if (cur === lastProgress) stuckCount++; else { stuckCount = 0; lastProgress = cur; }
        if (Date.now() - startTime > TIMEOUT || stuckCount > 10) {
            const status = document.getElementById('load-status');
            if (status) status.textContent = 'Loading issue - please refresh';
            const btn = document.createElement('button');
            btn.textContent = 'Retry'; btn.style.cssText = 'margin-top:20px;padding:10px 20px;font-size:16px;cursor:pointer;';
            btn.onclick = () => location.reload();
            const content = document.querySelector('.loading-content');
            if (content && !document.getElementById('loading-retry-btn')) { btn.id = 'loading-retry-btn'; content.appendChild(btn); }
        } else setTimeout(check, CHECK_MS);
    };
    setTimeout(check, CHECK_MS);
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 2: Core Utility Classes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class EventManager {
    constructor() {
        this.listeners = [];
        this._destroyed = false;
    }
    add(target, event, handler, options) {
        if (this._destroyed) return;
        target.addEventListener(event, handler, options);
        this.listeners.push({target, event, handler, options});
    }
    removeAll() {
        for (const {target, event, handler} of this.listeners) {
            try { target.removeEventListener(event, handler); } catch (e) {}
        }
        this.listeners = [];
    }
    destroy() {
        this.removeAll();
        this._destroyed = true;
    }
}

// Safe utilities for robust code
// Only define simple safe helpers if more robust versions haven't been
// provided by TU_Defensive. These fallbacks are intentionally minimal and
// should not override the enhanced implementations (e.g. those bound to
// BoundaryChecks or SafeAccess) defined earlier. If `window.safeGet` or
// other helpers already exist, we leave them intact.
if (typeof window.safeGet === 'undefined') {
    window.safeGet = function(arr, index, defaultValue) {
        if (!arr || index < 0 || index >= arr.length) return defaultValue;
        return arr[index];
    };
}
if (typeof window.safeGetProp === 'undefined') {
    window.safeGetProp = function(obj, prop, defaultValue) {
        if (!obj || typeof obj !== 'object') return defaultValue;
        return obj[prop] !== undefined ? obj[prop] : defaultValue;
    };
}
if (typeof window.safeJSONParse === 'undefined') {
    window.safeJSONParse = function(str, defaultValue) {
        try { return JSON.parse(str); } catch (e) { return defaultValue; };
    };
}
if (typeof window.clamp === 'undefined') {
    window.clamp = function(v, min, max) {
        return Math.max(min, Math.min(max, v));
    };
}
if (typeof window.lerp === 'undefined') {
    window.lerp = function(a, b, t) {
        return a + (b - a) * t;
    };
}

// Ring buffer for input prediction
class RingBuffer {
    constructor(size) {
        this.size = size;
        this.buffer = new Array(size);
        this.head = 0;
        this.count = 0;
    }
    push(item) {
        this.buffer[this.head] = item;
        this.head = (this.head + 1) % this.size;
        if (this.count < this.size) this.count++;
    }
    get(index) {
        if (index < 0 || index >= this.count) return null;
        const i = (this.head - this.count + index + this.size) % this.size;
        return this.buffer[i];
    }
    clear() {
        this.head = 0;
        this.count = 0;
    }
}

class ParticlePool {
    constructor(maxSize = 500) {
        this.maxSize = maxSize;
        this.pool = [];
        this.active = [];
        this._createPool();
    }
    _createPool() {
        for (let i = 0; i < this.maxSize; i++) {
            this.pool.push({x:0, y:0, vx:0, vy:0, life:0, maxLife:0, color:'', size:0, active:false});
        }
    }
    spawn(x, y, vx, vy, color, size, life) {
        let particle = this.pool.length > 0 ? this.pool.pop() :
                      (this.active.length > 0 ? this.active.shift() : null);
        if (!particle) return null;
        particle.x = x; particle.y = y; particle.vx = vx; particle.vy = vy;
        particle.color = color; particle.size = size; particle.life = life;
        particle.maxLife = life; particle.active = true;
        this.active.push(particle);
        return particle;
    }
    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) {
                p.active = false;
                this.active.splice(i, 1);
                this.pool.push(p);
            }
        }
    }
    render(ctx, camX, camY) {
        for (const p of this.active) {
            ctx.globalAlpha = p.life / p.maxLife;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - camX, p.y - camY, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }
}

window.PERF_MONITOR = {
    frames: [], maxFrames: 60,
    record(ft) { this.frames.push(ft); if (this.frames.length > this.maxFrames) this.frames.shift(); },
    getAverageFPS() { return this.frames.length ? Math.round(1000 / (this.frames.reduce((a,b) => a + b, 0) / this.frames.length)) : 60; }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 3: Object Pools
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const ObjectPool = {
            _pools: new Map(),
            _typeCount: 0,
            MAX_TYPES: 100,
            MAX_POOL_SIZE: 500,

            get(type, factory) {
                // éªŒè¯ç±»å‹å‚æ•°
                if (typeof type !== 'string' || type.length === 0) {
                    console.warn('[ObjectPool] Invalid type parameter');
                    return factory();
                }

                let pool = this._pools.get(type);
                if (!pool) {
                    // é…é¢é™åˆ¶æ£€æŸ¥
                    if (this._typeCount >= this.MAX_TYPES) {
                        console.warn('[ObjectPool] Type quota exceeded');
                        return factory();
                    }
                    pool = [];
                    this._pools.set(type, pool);
                    this._typeCount++;
                }

                if (pool.length > 0) {
                    const obj = pool.pop();
                    // æ¸…ç†å¯¹è±¡å¼•ç”¨ä»¥é˜²æ­¢å†…å­˜æ³„æ¼
                    if (obj && typeof obj === 'object') {
                        Object.keys(obj).forEach(key => { obj[key] = null; });
                    }
                    return obj;
                }
                return factory();
            },

            release(type, obj) {
                // éªŒè¯å‚æ•°
                if (!obj || typeof obj !== 'object') {
                    console.warn('[ObjectPool] Invalid object to release');
                    return;
                }

                if (typeof type !== 'string') {
                    console.warn('[ObjectPool] Invalid type for release');
                    return;
                }

                let pool = this._pools.get(type);
                if (!pool) {
                    if (this._typeCount >= this.MAX_TYPES) return;
                    pool = [];
                    this._pools.set(type, pool);
                    this._typeCount++;
                }

                if (pool.length < this.MAX_POOL_SIZE) {
                    pool.push(obj);
                }
            },

            clear(type) {
                if (type) {
                    if (this._pools.has(type)) {
                        this._pools.delete(type);
                        this._typeCount = Math.max(0, this._typeCount - 1);
                    }
                } else {
                    this._pools.clear();
                    this._typeCount = 0;
                }
            },

            getStats() {
                let totalObjects = 0;
                this._pools.forEach(pool => { totalObjects += pool.length; });
                return {
                    typeCount: this._typeCount,
                    totalObjects: totalObjects,
                    maxTypes: this.MAX_TYPES,
                    maxPoolSize: this.MAX_POOL_SIZE
                };
            }
        };
window.ObjectPool = ObjectPool;

        const VecPool = {
            _pool: [],
            _maxSize: 200,
            _releasedCount: 0,
            _acquiredCount: 0,

            get(x = 0, y = 0) {
                // éªŒè¯åæ ‡å‚æ•°
                const safeX = Number.isFinite(x) ? x : 0;
                const safeY = Number.isFinite(y) ? y : 0;

                this._acquiredCount++;

                if (this._pool.length > 0) {
                    const v = this._pool.pop();
                    // éªŒè¯è¿”å›çš„å¯¹è±¡
                    if (v && typeof v === 'object') {
                        v.x = safeX;
                        v.y = safeY;
                        return v;
                    }
                }
                return { x: safeX, y: safeY };
            },

            release(v) {
                // ä¸¥æ ¼éªŒè¯
                if (!v || typeof v !== 'object') {
                    console.warn('[VecPool] Attempted to release non-object');
                    return;
                }

                // é˜²æ­¢é‡å¤é‡Šæ”¾åŒä¸€å¯¹è±¡
                if (this._pool.includes(v)) {
                    console.warn('[VecPool] Attempted double-release');
                    return;
                }

                this._releasedCount++;

                if (this._pool.length < this._maxSize) {
                    // æ¸…ç†å¼•ç”¨
                    v.x = 0;
                    v.y = 0;
                    this._pool.push(v);
                }
            },

            getStats() {
                return {
                    poolSize: this._pool.length,
                    maxSize: this._maxSize,
                    acquired: this._acquiredCount,
                    released: this._releasedCount
                };
            },

            clear() {
                this._pool = [];
                this._acquiredCount = 0;
                this._releasedCount = 0;
            }
        };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 4: Loading Particles
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        (function initLoadingParticles() {
            const container = document.querySelector('.loading-particles');
            if (!container) return;
            const frag = document.createDocumentFragment();
            const colors = ['#ffeaa7', '#fd79a8', '#a29bfe', '#74b9ff'];
            // åŠ¨æ€ç²’å­æ•°é‡ï¼šç»¼åˆç¡¬ä»¶çº¿ç¨‹æ•°ä¸ DPRï¼Œä½ç«¯/é«˜ DPR è®¾å¤‡æ›´çœç”µ
            const cores = navigator.hardwareConcurrency || 4;
            const dpr = window.devicePixelRatio || 1;
            const reduce = (() => {
                try { return !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches); } catch { return false; }
            })();
initLoadingParticles();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 5: Constants & Utilities
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const __hexToRgbCache = new Map();
        const __rgb0 = Object.freeze({ r: 0, g: 0, b: 0 });

        const Utils = {
            clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
            lerp: (a, b, t) => a + (b - a) * t,
            smoothstep: (edge0, edge1, x) => {
                if (edge0 === edge1) return x < edge0 ? 0 : 1;
                const t = Utils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
                return t * t * (3 - 2 * t);
            },
            lerpColor: (hexA, hexB, t) => {
                const a = Utils.hexToRgb(hexA);
                const b = Utils.hexToRgb(hexB);
                const r = Math.round(Utils.lerp(a.r, b.r, t));
                const g = Math.round(Utils.lerp(a.g, b.g, t));
                const b2 = Math.round(Utils.lerp(a.b, b.b, t));
                return Utils.rgbToHex(r, g, b2);
            },
            // 0=ç™½å¤©, 1=æ·±å¤œï¼›åœ¨é»æ˜/é»„æ˜é™„è¿‘åš smoothstep è¿‡æ¸¡
            nightFactor: (time, dawnStart = 0.18, dawnEnd = 0.28, duskStart = 0.72, duskEnd = 0.82) => {
                const n1 = 1 - Utils.smoothstep(dawnStart, dawnEnd, time);
                const n2 = Utils.smoothstep(duskStart, duskEnd, time);
                return Utils.clamp(n1 + n2, 0, 1);
            },
            dist: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1),
            isMobile: () => {
                try {
                    // âœ… æ‰‹åŠ¨å¼ºåˆ¶ï¼š?forceMobile=1 / ?forceDesktop=1ï¼ˆæˆ– ?mobile=1 / ?desktop=1ï¼‰
                    const qs = new URLSearchParams(window.location.search);
                    if (qs.get('forceDesktop') === '1' || qs.get('desktop') === '1') return false;
                    if (qs.get('forceMobile') === '1' || qs.get('mobile') === '1') return true;

                    // âœ… ä¼˜å…ˆï¼šUser-Agent Client Hintsï¼ˆChromium ç³»å†…æµè§ˆå™¨ï¼‰
                    if (navigator.userAgentData && typeof navigator.userAgentData.mobile === 'boolean') {
                        return navigator.userAgentData.mobile;
                    }

                    const ua = (navigator.userAgent || '').toLowerCase();
                    const platform = (navigator.platform || '').toLowerCase();

                    // âœ… iPadOS 13+ï¼šå¯èƒ½ä¼ªè£…æˆ â€œMacintoshâ€ï¼Œä½†é€šå¸¸ platform=MacIntel ä¸”å…·å¤‡å¤šç‚¹è§¦æ§
                    const maxTouchPoints = navigator.maxTouchPoints || navigator.msMaxTouchPoints || 0;
                    const isIPadOS = (platform === 'macintel' || ua.includes('macintosh')) && maxTouchPoints > 1;

                    // âœ… å¸¸è§ç§»åŠ¨/å¹³æ¿/é˜…è¯»å™¨ UA å…³é”®å­—ï¼ˆéƒ¨åˆ†â€œæ¡Œé¢æ¨¡å¼â€ä¹Ÿå¯èƒ½å¸¦ Mobile/Tabletï¼‰
                    const uaLooksMobile = /android|iphone|ipod|ipad|windows phone|iemobile|blackberry|bb10|opera mini|opera mobi|mobile|webos|silk|kindle|kfapwi|kftt|tablet|playbook/.test(ua);

                    if (isIPadOS || uaLooksMobile) return true;

                    // âœ… è§¦æ§èƒ½åŠ›å…œåº•ï¼ˆæœ‰äº›æµè§ˆå™¨ UA ä¼šä¼ªè£…æˆæ¡Œé¢ï¼‰
                    const hasTouch = ('ontouchstart' in window) || maxTouchPoints > 0;

                    // âœ… åª’ä½“æŸ¥è¯¢ç‰¹å¾ï¼ˆéƒ¨åˆ†æ—§ WebView ä¸æ”¯æŒï¼Œåšä¿æŠ¤ï¼‰
                    const mql = (q) => (window.matchMedia ? window.matchMedia(q).matches : false);
                    const coarsePointer = mql('(pointer: coarse)') || mql('(any-pointer: coarse)');
                    const noHover = mql('(hover: none)') || mql('(any-hover: none)');

                    // âœ… è§†å£å°ºå¯¸å…œåº•ï¼šå¤§å±æ‰‹æœºæ¨ªå±æ—¶ width å¯èƒ½ > 768ï¼Œå–â€œçŸ­è¾¹â€æ›´å¯é 
                    const vw = window.innerWidth || 0;
                    const vh = window.innerHeight || 0;
                    const minSide = Math.min(vw, vh);
                    const smallViewport = minSide > 0 && minSide <= 900;

                    if (hasTouch && (coarsePointer || noHover)) return true;
                    if (hasTouch && smallViewport) return true;

                    return false;
                } catch (e) {
                    // æœ€ç»ˆå…œåº•ï¼šåªè¦èƒ½è§¦æ§ï¼Œå°±å½“ä½œéœ€è¦ç§»åŠ¨ç«¯ UI
                    return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
                }
            },

            /** ç»™ <html> æ‰“ä¸Š is-mobile / is-desktopï¼Œè§£å†³éƒ¨åˆ†æœºå‹åª’ä½“æŸ¥è¯¢/UA å¼‚å¸¸å¯¼è‡´çš„â€œæ˜¾ç¤ºç”µè„‘ç«¯ç•Œé¢â€ */
            applyDeviceClass: () => {
                const root = document.documentElement;
                if (!root) return;
                const mobile = Utils.isMobile();
                root.classList.toggle('is-mobile', mobile);
                root.classList.toggle('is-desktop', !mobile);
            },

            hexToRgb: (hex) => {
                if (typeof hex !== 'string') return __rgb0;
                // Normalize: '#rrggbb'
                let key = hex;
                if (key[0] !== '#') key = '#' + key;
                if (key.length !== 7) {
                    // best-effort normalize (rare path)
                    key = ('#' + key.replace('#', '').toLowerCase().padStart(6, '0')).slice(0, 7);
                } else {
                    key = key.toLowerCase();
                }
                let c = __hexToRgbCache.get(key);
                if (c) return c;
                const r = parseInt(key.slice(1, 3), 16) || 0;
                const g = parseInt(key.slice(3, 5), 16) || 0;
                const b = parseInt(key.slice(5, 7), 16) || 0;
                c = Object.freeze({ r, g, b });
                __hexToRgbCache.set(key, c);
                return c;
            },
            rgbToHex: (r, g, b) => '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join(''),
            resetGameInput: (game) => {
                try {
                    if (!game || !game.input) return;
                    const inp = game.input;
                    inp.left = false; inp.right = false; inp.jump = false; inp.sprint = false;
                    if ('mouseLeft' in inp) inp.mouseLeft = false;
                    if ('mouseRight' in inp) inp.mouseRight = false;
                    if ('mouseMiddle' in inp) inp.mouseMiddle = false;
                    const im = game.services && game.services.input;
                    if (im) {
                        if ('_holdLeftMs' in im) im._holdLeftMs = 0;
                        if ('_holdRightMs' in im) im._holdRightMs = 0;
                        if ('_holdSprint' in im) im._holdSprint = false;
                        if ('_holdDir' in im) im._holdDir = 0;
                        if ('_holdJustStarted' in im) im._holdJustStarted = false;
                    }
                } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
            },
            easeOutBack: (t) => 1 + 2.7 * Math.pow(t - 1, 3) + 1.7 * Math.pow(t - 1, 2)
        };

        // è®¾å¤‡æ¨¡å¼æ ‡è®°ï¼šå°½æ—©æ‰“ä¸Š classï¼Œå…¼å®¹éƒ¨åˆ†æœºå‹/æµè§ˆå™¨â€œæ¡Œé¢æ¨¡å¼â€å¯¼è‡´çš„ç§»åŠ¨ç«¯è¯†åˆ«å¼‚å¸¸
        Utils.applyDeviceClass();
        // æ—‹è½¬/å°ºå¯¸å˜åŒ–æ—¶åŒæ­¥æ›´æ–°ï¼ˆåªå½±å“ CSS/UIï¼Œä¸ä¼šæ‰“æ–­æ¸¸æˆè¿›ç¨‹ï¼‰
        // æ—‹è½¬/å°ºå¯¸å˜åŒ–æ—¶åŒæ­¥æ›´æ–°ï¼ˆèŠ‚æµåˆ° rAFï¼Œé¿å… resize è¿ç»­è§¦å‘å¯¼è‡´é‡å¤è®¡ç®—ï¼‰
        let __tuDeviceClassRaf = 0;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• å¢å¼ºè¾¹ç•Œæ£€æŸ¥å·¥å…· â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const SafeAccess = {
            getTile(world, x, y, defaultValue = BLOCK.AIR) {
                if (!world || !world.tiles) return defaultValue;
                if (x < 0 || y < 0 || x >= world.w || y >= world.h) return defaultValue;
                return world.tiles[x][y];
            },

            setTile(world, x, y, value) {
                if (!world || !world.tiles) return false;
                if (x < 0 || y < 0 || x >= world.w || y >= world.h) return false;
                world.tiles[x][y] = value;
                return true;
            },

            getLight(world, x, y, defaultValue = 0) {
                if (!world || !world.light) return defaultValue;
                if (x < 0 || y < 0 || x >= world.w || y >= world.h) return defaultValue;
                return world.light[x][y];
            },

            setLight(world, x, y, value) {
                if (!world || !world.light) return false;
                if (x < 0 || y < 0 || x >= world.w || y >= world.h) return false;
                world.light[x][y] = value;
                return true;
            }
        };

        const __tuDeviceClassRafCb = () => {
            __tuDeviceClassRaf = 0;
            Utils.applyDeviceClass();
        };
        const __tuScheduleDeviceClass = () => {
            if (__tuDeviceClassRaf) return;
            __tuDeviceClassRaf = requestAnimationFrame(__tuDeviceClassRafCb);
        };
        const __tuScheduleDeviceClassDelayed = () => { setTimeout(__tuScheduleDeviceClass, 50); };
        window.addEventListener('resize', __tuScheduleDeviceClass, { passive: true });
        window.addEventListener('orientationchange', __tuScheduleDeviceClassDelayed, { passive: true });

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        //                           DOM å·¥å…·ä¸é›†ä¸­å¸¸é‡ï¼ˆå¯ç»´æŠ¤æ€§å¢å¼ºï¼‰
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        /** ç»Ÿä¸€ DOM è®¿é—®ï¼Œå‡å°‘æ•£è½çš„ getElementById / querySelector */
        const DOM = Object.freeze({
            byId: (id) => document.getElementById(id),
            qs: (sel, root = document) => root.querySelector(sel),
            qsa: (sel, root = document) => Array.from(root.querySelectorAll(sel)),
        });

        /** é¡µé¢å…ƒç´  IDï¼ˆé›†ä¸­ç®¡ç†ï¼Œé¿å… magic stringï¼‰ */
        const UI_IDS = Object.freeze({
            loading: 'loading',
            loadProgress: 'load-progress',
            loadStatus: 'load-status',
            fullscreenBtn: 'fullscreen-btn',
        });

        /** è¾“å…¥æ˜ å°„ï¼ˆé›†ä¸­ç®¡ç†ï¼Œä¾¿äºæ‰©å±•/æ”¹é”®ï¼‰ */
        const INPUT_KEYS = Object.freeze({
            LEFT: new Set(['KeyA', 'ArrowLeft']),
            RIGHT: new Set(['KeyD', 'ArrowRight']),
            JUMP: new Set(['KeyW', 'ArrowUp', 'Space']),
            SPRINT: new Set(['ShiftLeft', 'ShiftRight'])
        });

        const MOUSE_BUTTON = Object.freeze({ LEFT: 0, RIGHT: 2 });

        /** èƒŒåŒ…é™åˆ¶ï¼ˆé›†ä¸­ç®¡ç†ï¼‰ */
        const INVENTORY_LIMITS = Object.freeze({
            MAX_SIZE: 36,
            MAX_STACK: 999
        });

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { Utils, DOM, UI_IDS, INPUT_KEYS, MOUSE_BUTTON, INVENTORY_LIMITS });

// PatchManager removed - all patches merged directly into class definitions

(function detectBackdropFilterSupport() {
    try {
        const ok = !!(window.CSS && (CSS.supports('backdrop-filter: blur(1px)') || CSS.supports('-webkit-backdrop-filter: blur(1px)')));
        document.documentElement.classList.toggle('no-backdrop', !ok);
    } catch { document.documentElement.classList.add('no-backdrop'); }
})();

        const CONFIG = Object.freeze({
            TILE_SIZE: 16,
            WORLD_WIDTH: 600,
            WORLD_HEIGHT: 300,
            GRAVITY: 0.42,
            MAX_FALL_SPEED: 14,
            PLAYER_SPEED: 3.2,
            SPRINT_MULT: 1.5,
            // Sprint feel
            // - Hold A/D to sprint after this delay (ms)
            SPRINT_HOLD_MS: 180,
            // - Short burst of extra acceleration when sprint starts (ms)
            SPRINT_BOOST_MS: 220,
            // - Acceleration multiplier during the boost window
            SPRINT_BOOST_ACCEL_MULT: 1.65,
            // - Small initial velocity kick when sprint starts (px/frame-ish)
            SPRINT_KICK: 1.6,
            // - Visual FX "speed feel" duration after sprint start (ms)
            SPRINT_VFX_MS: 280,
            // Sprint â†” Air polish
            // - Landing "perfect timing" window: within this time after landing, holding a direction can instantly resume sprint (ms)
            PERFECT_LAND_MS: 100,
            // - In air keep a bit of ground-sprint inertia (no extra accel), but cap it lower than full sprint
            AIR_INERTIA_MULT: 1.18,
            // - Sprint start lean animation
            SPRINT_LEAN_MS: 160,
            SPRINT_LEAN_ANGLE: 0.20,
            // - Sprint landing feedback
            LAND_DUST_COUNT: 12,
            LAND_SHAKE_AMP: 1.8,
            LAND_SHAKE_MS: 110,
            JUMP_FORCE: 9.0,
            AIR_CONTROL: 0.65,
            FRICTION: 0.83,
            REACH_DISTANCE: 5,
            LIGHT_LEVELS: 16,
            DAY_LENGTH: 120000,
            SURFACE_LEVEL: 0.25,
            UNDERGROUND_LEVEL: 0.38,
            CAVERN_LEVEL: 0.58,
            UNDERWORLD_LEVEL: 0.90
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // é…ç½®åˆ«åå…¼å®¹ï¼ˆæŸäº›è¡¥ä¸ä½¿ç”¨ CFG è€Œé CONFIGï¼‰
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const CFG = CONFIG;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                  æ–¹å—ç³»ç»Ÿ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const BLOCK = Object.freeze({
            AIR: 0, DIRT: 1, GRASS: 2, STONE: 3, WOOD: 4, LEAVES: 5,
            SAND: 6, SNOW: 7, ICE: 8, MUD: 9, CLAY: 10, LOG: 11,
            COPPER_ORE: 12, IRON_ORE: 13, SILVER_ORE: 14, GOLD_ORE: 15,
            DIAMOND_ORE: 16, HELLSTONE: 17, OBSIDIAN: 18,
            COBBLESTONE: 19, MOSSY_STONE: 20, GRANITE: 21, MARBLE: 22,
            PLANKS: 23, BRICK: 24, GLASS: 25, TORCH: 26,
            WATER: 27, LAVA: 28, ASH: 29, BEDROCK: 30,
            MUSHROOM: 31, FLOWER_RED: 32, FLOWER_YELLOW: 33, TALL_GRASS: 34,
            CACTUS: 35, SNOW_GRASS: 36, JUNGLE_GRASS: 37, CRYSTAL: 38,
            // æ–°å¢æ–¹å—ç±»å‹
            AMETHYST: 39, RUBY_ORE: 40, EMERALD_ORE: 41, SAPPHIRE_ORE: 42,
            GLOWSTONE: 43, MUSHROOM_GIANT: 44, VINE: 45, CORAL: 46,
            SANDSTONE: 47, RED_SAND: 48, GRAVEL: 49, LIMESTONE: 50,
            SLATE: 51, BASALT: 52, FROZEN_STONE: 53, MOSS: 54,
            SPIDER_WEB: 55, BONE: 56, TREASURE_CHEST: 57, LANTERN: 58,
            PINK_FLOWER: 59, BLUE_FLOWER: 60, SUNFLOWER: 61, FERN: 62,
            BAMBOO: 63, PALM_LOG: 64, PALM_LEAVES: 65, CHERRY_LOG: 66,
            CHERRY_LEAVES: 67, PINE_LOG: 68, PINE_LEAVES: 69, STALAGMITE: 70,
            STALACTITE: 71, UNDERGROUND_MUSHROOM: 72, GLOWING_MOSS: 73,
            // æ›´å¤šæ–°å¢æ–¹å— - è¶…çº§ä¸°å¯Œç‰ˆ
            METEORITE: 74, TITANIUM_ORE: 75, COBALT_ORE: 76, MYTHRIL_ORE: 77,
            ORICHALCUM_ORE: 78, ADAMANTITE_ORE: 79, CHLOROPHYTE_ORE: 80,
            LUMINITE_ORE: 81, CRIMSON_STONE: 82, CORRUPTION_STONE: 83,
            HALLOW_STONE: 84, PEARLSTONE: 85, EBONSTONE: 86,
            JUNGLE_TEMPLE_BRICK: 87, LIHZAHRD_BRICK: 88, DUNGEON_BRICK: 89,
            CLOUD: 90, RAIN_CLOUD: 91, SNOW_CLOUD: 92,
            LIVING_WOOD: 93, LIVING_LEAF: 94, MAHOGANY_LOG: 95, MAHOGANY_LEAVES: 96,
            BOREAL_LOG: 97, SHADEWOOD_LOG: 98, PEARLWOOD_LOG: 99,
            HONEY_BLOCK: 100, HIVE: 101, BEE_NEST: 102,
            SPIDER_NEST: 103, COBALT_BRICK: 104, MYTHRIL_BRICK: 105,
            GOLD_BRICK: 106, SILVER_BRICK: 107, COPPER_BRICK: 108,
            PLATINUM_ORE: 109, TUNGSTEN_ORE: 110, LEAD_ORE: 111, TIN_ORE: 112,
            METEORITE_BRICK: 113, HELLSTONE_BRICK: 114,
            LIFE_CRYSTAL: 115, MANA_CRYSTAL: 116, HEART_CRYSTAL: 117,
            ALTAR: 118, DEMON_ALTAR: 119, CRIMSON_ALTAR: 120,
            SUNPLATE: 121, MOONPLATE: 122, STARFALL: 123,
            ROSE: 124, TULIP: 125, ORCHID: 126, LILY: 127,
            SEAWEED: 128, KELP: 129, SEA_OATS: 130,
            PALM_TREE_TOP: 131, GIANT_TREE_LOG: 132,
            HONEY_DRIP: 133, SLIME_BLOCK: 134, GEL_BLOCK: 135,
            RAINBOW_BRICK: 136, CONFETTI_BLOCK: 137, PARTY_BLOCK: 138,
            PUMPKIN: 139, HAY: 140, SCARECROW: 141,
            GRAVESTONE: 142, CROSS: 143, SKULL_BLOCK: 144,
            ROPE: 145, CHAIN: 146, WEB_ROPE: 147,
            PLATFORMS_WOOD: 148, PLATFORMS_STONE: 149, PLATFORMS_METAL: 150,
            MUSHROOM_GRASS: 151, JUNGLE_SPORE: 152, NATURE_SHRINE: 153,
            FIRE_BLOSSOM: 154, MOONGLOW: 155, DAYBLOOM: 156, WATERLEAF: 157,
            DEATHWEED: 158, BLINKROOT: 159, SHIVERTHORN: 160, FIREBLOSSOM: 161
        });

        const Constants = Object.freeze({ CONFIG, BLOCK });
        window.Constants = Constants;

        const BLOCK_DATA = {
            [BLOCK.AIR]: { name: 'ç©ºæ°”', solid: false, transparent: true, light: 0, hardness: 0 },
            [BLOCK.DIRT]: { name: 'åœŸå—', solid: true, transparent: false, light: 0, hardness: 1, color: '#8B6914' },
            [BLOCK.GRASS]: { name: 'è‰åœ°', solid: true, transparent: false, light: 0, hardness: 1, color: '#4CAF50' },
            [BLOCK.STONE]: { name: 'çŸ³å—', solid: true, transparent: false, light: 0, hardness: 3, color: '#78909C' },
            [BLOCK.WOOD]: { name: 'æœ¨æ', solid: true, transparent: false, light: 0, hardness: 2, color: '#A1887F' },
            [BLOCK.LEAVES]: { name: 'æ ‘å¶', solid: false, transparent: true, light: 0, hardness: 0.5, color: '#66BB6A' },
            [BLOCK.SAND]: { name: 'æ²™å­', solid: true, transparent: false, light: 0, hardness: 0.8, color: '#FFE082' },
            [BLOCK.SNOW]: { name: 'é›ªå—', solid: true, transparent: false, light: 0, hardness: 0.5, color: '#ECEFF1' },
            [BLOCK.ICE]: { name: 'å†°å—', solid: true, transparent: true, light: 0, hardness: 1.5, color: '#81D4FA' },
            [BLOCK.MUD]: { name: 'æ³¥å·´', solid: true, transparent: false, light: 0, hardness: 0.8, color: '#6D4C41' },
            [BLOCK.CLAY]: { name: 'ç²˜åœŸ', solid: true, transparent: false, light: 0, hardness: 1.2, color: '#BCAAA4' },
            [BLOCK.LOG]: { name: 'åŸæœ¨', solid: true, transparent: false, light: 0, hardness: 2, color: '#5D4037' },
            [BLOCK.COPPER_ORE]: { name: 'é“œçŸ¿', solid: true, transparent: false, light: 0, hardness: 4, color: '#FF7043' },
            [BLOCK.IRON_ORE]: { name: 'é“çŸ¿', solid: true, transparent: false, light: 0, hardness: 5, color: '#90A4AE' },
            [BLOCK.SILVER_ORE]: { name: 'é“¶çŸ¿', solid: true, transparent: false, light: 1, hardness: 5.5, color: '#CFD8DC' },
            [BLOCK.GOLD_ORE]: { name: 'é‡‘çŸ¿', solid: true, transparent: false, light: 2, hardness: 6, color: '#FFD54F' },
            [BLOCK.DIAMOND_ORE]: { name: 'é’»çŸ³çŸ¿', solid: true, transparent: false, light: 4, hardness: 8, color: '#4DD0E1' },
            [BLOCK.HELLSTONE]: { name: 'ç‹±å²©', solid: true, transparent: false, light: 6, hardness: 10, color: '#FF5722' },
            [BLOCK.OBSIDIAN]: { name: 'é»‘æ›œçŸ³', solid: true, transparent: false, light: 0, hardness: 15, color: '#37474F' },
            [BLOCK.COBBLESTONE]: { name: 'åœ†çŸ³', solid: true, transparent: false, light: 0, hardness: 3, color: '#78909C' },
            [BLOCK.MOSSY_STONE]: { name: 'è‹”çŸ³', solid: true, transparent: false, light: 0, hardness: 3, color: '#689F38' },
            [BLOCK.GRANITE]: { name: 'èŠ±å²—å²©', solid: true, transparent: false, light: 0, hardness: 4, color: '#A1887F' },
            [BLOCK.MARBLE]: { name: 'å¤§ç†çŸ³', solid: true, transparent: false, light: 1, hardness: 4, color: '#FAFAFA' },
            [BLOCK.PLANKS]: { name: 'æœ¨æ¿', solid: true, transparent: false, light: 0, hardness: 2, color: '#BCAAA4' },
            [BLOCK.BRICK]: { name: 'ç –å—', solid: true, transparent: false, light: 0, hardness: 4, color: '#E57373' },
            [BLOCK.GLASS]: { name: 'ç»ç’ƒ', solid: true, transparent: true, light: 0, hardness: 0.3, color: '#E1F5FE' },
            [BLOCK.TORCH]: { name: 'ç«æŠŠ', solid: false, transparent: true, light: 14, hardness: 0.1, color: '#FFEB3B' },
            [BLOCK.WATER]: { name: 'æ°´', solid: false, transparent: true, light: 0, hardness: 0, liquid: true, color: '#42A5F5' },
            [BLOCK.LAVA]: { name: 'ç†”å²©', solid: false, transparent: true, light: 15, hardness: 0, liquid: true, color: '#FF6D00' },
            [BLOCK.ASH]: { name: 'ç°çƒ¬', solid: true, transparent: false, light: 0, hardness: 0.8, color: '#455A64' },
            [BLOCK.BEDROCK]: { name: 'åŸºå²©', solid: true, transparent: false, light: 0, hardness: Infinity, color: '#263238' },
            [BLOCK.MUSHROOM]: { name: 'è˜‘è‡', solid: false, transparent: true, light: 2, hardness: 0, color: '#EC407A' },
            [BLOCK.FLOWER_RED]: { name: 'çº¢èŠ±', solid: false, transparent: true, light: 0, hardness: 0, color: '#EF5350' },
            [BLOCK.FLOWER_YELLOW]: { name: 'é»„èŠ±', solid: false, transparent: true, light: 0, hardness: 0, color: '#FFEE58' },
            [BLOCK.TALL_GRASS]: { name: 'é«˜è‰', solid: false, transparent: true, light: 0, hardness: 0, color: '#9CCC65' },
            [BLOCK.CACTUS]: { name: 'ä»™äººæŒ', solid: true, transparent: false, light: 0, hardness: 1, color: '#7CB342' },
            [BLOCK.SNOW_GRASS]: { name: 'é›ªè‰', solid: true, transparent: false, light: 0, hardness: 1, color: '#ECEFF1' },
            [BLOCK.JUNGLE_GRASS]: { name: 'ä¸›æ—è‰', solid: true, transparent: false, light: 0, hardness: 1, color: '#43A047' },
            [BLOCK.CRYSTAL]: { name: 'æ°´æ™¶', solid: true, transparent: true, light: 8, hardness: 5, color: '#CE93D8' },
            // æ–°å¢æ–¹å—æ•°æ®
            [BLOCK.AMETHYST]: { name: 'ç´«æ°´æ™¶', solid: true, transparent: true, light: 6, hardness: 6, color: '#9C27B0' },
            [BLOCK.RUBY_ORE]: { name: 'çº¢å®çŸ³çŸ¿', solid: true, transparent: false, light: 3, hardness: 7, color: '#E91E63' },
            [BLOCK.EMERALD_ORE]: { name: 'ç¥–æ¯ç»¿çŸ¿', solid: true, transparent: false, light: 3, hardness: 7, color: '#4CAF50' },
            [BLOCK.SAPPHIRE_ORE]: { name: 'è“å®çŸ³çŸ¿', solid: true, transparent: false, light: 3, hardness: 7, color: '#2196F3' },
            [BLOCK.GLOWSTONE]: { name: 'è¤çŸ³', solid: true, transparent: true, light: 12, hardness: 2, color: '#FFC107' },
            [BLOCK.MUSHROOM_GIANT]: { name: 'å·¨å‹è˜‘è‡', solid: true, transparent: false, light: 3, hardness: 1, color: '#8E24AA' },
            [BLOCK.VINE]: { name: 'è—¤è”“', solid: false, transparent: true, light: 0, hardness: 0.1, color: '#2E7D32' },
            [BLOCK.CORAL]: { name: 'çŠç‘š', solid: true, transparent: false, light: 2, hardness: 1, color: '#FF7043' },
            [BLOCK.SANDSTONE]: { name: 'ç ‚å²©', solid: true, transparent: false, light: 0, hardness: 2.5, color: '#D4A574' },
            [BLOCK.RED_SAND]: { name: 'çº¢æ²™', solid: true, transparent: false, light: 0, hardness: 0.8, color: '#C75B39' },
            [BLOCK.GRAVEL]: { name: 'ç ¾çŸ³', solid: true, transparent: false, light: 0, hardness: 1, color: '#757575' },
            [BLOCK.LIMESTONE]: { name: 'çŸ³ç° ite', solid: true, transparent: false, light: 0, hardness: 2, color: '#E8DCC4' },
            [BLOCK.SLATE]: { name: 'æ¿å²©', solid: true, transparent: false, light: 0, hardness: 3, color: '#546E7A' },
            [BLOCK.BASALT]: { name: 'ç„æ­¦å²©', solid: true, transparent: false, light: 0, hardness: 4, color: '#37474F' },
            [BLOCK.FROZEN_STONE]: { name: 'å†»çŸ³', solid: true, transparent: true, light: 1, hardness: 3, color: '#B3E5FC' },
            [BLOCK.MOSS]: { name: 'è‹”è—“', solid: false, transparent: true, light: 0, hardness: 0.1, color: '#558B2F' },
            [BLOCK.SPIDER_WEB]: { name: 'èœ˜è››ç½‘', solid: false, transparent: true, light: 0, hardness: 0.1, color: '#EEEEEE' },
            [BLOCK.BONE]: { name: 'éª¨å¤´', solid: true, transparent: false, light: 0, hardness: 2, color: '#EFEBE9' },
            [BLOCK.TREASURE_CHEST]: { name: 'å®ç®±', solid: true, transparent: false, light: 4, hardness: 3, color: '#8D6E63' },
            [BLOCK.LANTERN]: { name: 'ç¯ç¬¼', solid: false, transparent: true, light: 14, hardness: 0.5, color: '#FF9800' },
            [BLOCK.PINK_FLOWER]: { name: 'ç²‰èŠ±', solid: false, transparent: true, light: 0, hardness: 0, color: '#F48FB1' },
            [BLOCK.BLUE_FLOWER]: { name: 'è“èŠ±', solid: false, transparent: true, light: 0, hardness: 0, color: '#64B5F6' },
            [BLOCK.SUNFLOWER]: { name: 'å‘æ—¥è‘µ', solid: false, transparent: true, light: 1, hardness: 0, color: '#FFEB3B' },
            [BLOCK.FERN]: { name: 'è•¨ç±»', solid: false, transparent: true, light: 0, hardness: 0, color: '#66BB6A' },
            [BLOCK.BAMBOO]: { name: 'ç«¹å­', solid: true, transparent: false, light: 0, hardness: 1, color: '#7CB342' },
            [BLOCK.PALM_LOG]: { name: 'æ£•æ¦ˆæœ¨', solid: true, transparent: false, light: 0, hardness: 2, color: '#A1887F' },
            [BLOCK.PALM_LEAVES]: { name: 'æ£•æ¦ˆå¶', solid: false, transparent: true, light: 0, hardness: 0.3, color: '#8BC34A' },
            [BLOCK.CHERRY_LOG]: { name: 'æ¨±èŠ±æœ¨', solid: true, transparent: false, light: 0, hardness: 2, color: '#795548' },
            [BLOCK.CHERRY_LEAVES]: { name: 'æ¨±èŠ±å¶', solid: false, transparent: true, light: 1, hardness: 0.3, color: '#F8BBD9' },
            [BLOCK.PINE_LOG]: { name: 'æ¾æœ¨', solid: true, transparent: false, light: 0, hardness: 2, color: '#4E342E' },
            [BLOCK.PINE_LEAVES]: { name: 'æ¾é’ˆ', solid: false, transparent: true, light: 0, hardness: 0.3, color: '#1B5E20' },
            [BLOCK.STALAGMITE]: { name: 'çŸ³ç¬‹', solid: true, transparent: false, light: 0, hardness: 2, color: '#8D6E63' },
            [BLOCK.STALACTITE]: { name: 'é’Ÿä¹³çŸ³', solid: true, transparent: false, light: 0, hardness: 2, color: '#A1887F' },
            [BLOCK.UNDERGROUND_MUSHROOM]: { name: 'åœ°ä¸‹è˜‘è‡', solid: false, transparent: true, light: 5, hardness: 0, color: '#7E57C2' },
            [BLOCK.GLOWING_MOSS]: { name: 'å‘å…‰è‹”è—“', solid: false, transparent: true, light: 8, hardness: 0.1, color: '#00E676' },
            // è¶…çº§ä¸°å¯Œç‰ˆæ–°å¢æ–¹å—æ•°æ®
            [BLOCK.METEORITE]: { name: 'é™¨çŸ³', solid: true, transparent: false, light: 4, hardness: 12, color: '#8B4513' },
            [BLOCK.TITANIUM_ORE]: { name: 'é’›çŸ¿', solid: true, transparent: false, light: 2, hardness: 9, color: '#4A6670' },
            [BLOCK.COBALT_ORE]: { name: 'é’´çŸ¿', solid: true, transparent: false, light: 2, hardness: 8, color: '#2E86AB' },
            [BLOCK.MYTHRIL_ORE]: { name: 'ç§˜é“¶çŸ¿', solid: true, transparent: false, light: 3, hardness: 9, color: '#66BB6A' },
            [BLOCK.ORICHALCUM_ORE]: { name: 'å±±é“œçŸ¿', solid: true, transparent: false, light: 3, hardness: 9, color: '#FF69B4' },
            [BLOCK.ADAMANTITE_ORE]: { name: 'ç²¾é‡‘çŸ¿', solid: true, transparent: false, light: 4, hardness: 10, color: '#DC143C' },
            [BLOCK.CHLOROPHYTE_ORE]: { name: 'å¶ç»¿çŸ¿', solid: true, transparent: false, light: 5, hardness: 11, color: '#32CD32' },
            [BLOCK.LUMINITE_ORE]: { name: 'å¤œæ˜çŸ¿', solid: true, transparent: false, light: 10, hardness: 15, color: '#00FFFF' },
            [BLOCK.CRIMSON_STONE]: { name: 'çŒ©çº¢çŸ³', solid: true, transparent: false, light: 1, hardness: 4, color: '#8B0000' },
            [BLOCK.CORRUPTION_STONE]: { name: 'è…åŒ–çŸ³', solid: true, transparent: false, light: 1, hardness: 4, color: '#4B0082' },
            [BLOCK.HALLOW_STONE]: { name: 'ç¥åœ£çŸ³', solid: true, transparent: false, light: 3, hardness: 4, color: '#FFD700' },
            [BLOCK.PEARLSTONE]: { name: 'çç çŸ³', solid: true, transparent: false, light: 2, hardness: 4, color: '#FFF0F5' },
            [BLOCK.EBONSTONE]: { name: 'é»‘æª€çŸ³', solid: true, transparent: false, light: 0, hardness: 5, color: '#2F1B41' },
            [BLOCK.JUNGLE_TEMPLE_BRICK]: { name: 'ä¸›æ—ç¥åº™ç –', solid: true, transparent: false, light: 0, hardness: 8, color: '#4A7023' },
            [BLOCK.LIHZAHRD_BRICK]: { name: 'ä¸›æ—èœ¥èœ´ç –', solid: true, transparent: false, light: 1, hardness: 10, color: '#8B7355' },
            [BLOCK.DUNGEON_BRICK]: { name: 'åœ°ç‰¢ç –', solid: true, transparent: false, light: 0, hardness: 6, color: '#4169E1' },
            [BLOCK.CLOUD]: { name: 'äº‘', solid: true, transparent: true, light: 0, hardness: 0.2, color: '#F5F5F5' },
            [BLOCK.RAIN_CLOUD]: { name: 'é›¨äº‘', solid: true, transparent: true, light: 0, hardness: 0.2, color: '#708090' },
            [BLOCK.SNOW_CLOUD]: { name: 'é›ªäº‘', solid: true, transparent: true, light: 0, hardness: 0.2, color: '#E0FFFF' },
            [BLOCK.LIVING_WOOD]: { name: 'ç”Ÿå‘½æœ¨', solid: true, transparent: false, light: 1, hardness: 3, color: '#8B4513' },
            [BLOCK.LIVING_LEAF]: { name: 'ç”Ÿå‘½å¶', solid: false, transparent: true, light: 2, hardness: 0.3, color: '#228B22' },
            [BLOCK.MAHOGANY_LOG]: { name: 'çº¢æœ¨', solid: true, transparent: false, light: 0, hardness: 2.5, color: '#C04000' },
            [BLOCK.MAHOGANY_LEAVES]: { name: 'çº¢æœ¨å¶', solid: false, transparent: true, light: 0, hardness: 0.3, color: '#006400' },
            [BLOCK.BOREAL_LOG]: { name: 'åŒ—æ–¹æœ¨', solid: true, transparent: false, light: 0, hardness: 2, color: '#D2B48C' },
            [BLOCK.SHADEWOOD_LOG]: { name: 'æš—å½±æœ¨', solid: true, transparent: false, light: 0, hardness: 2, color: '#4A3B5C' },
            [BLOCK.PEARLWOOD_LOG]: { name: 'çç æœ¨', solid: true, transparent: false, light: 1, hardness: 2, color: '#FFDEAD' },
            [BLOCK.HONEY_BLOCK]: { name: 'èœ‚èœœå—', solid: true, transparent: true, light: 2, hardness: 0.5, color: '#FFB347' },
            [BLOCK.HIVE]: { name: 'èœ‚å·¢', solid: true, transparent: false, light: 1, hardness: 2, color: '#DAA520' },
            [BLOCK.BEE_NEST]: { name: 'èœ‚çª', solid: true, transparent: false, light: 2, hardness: 1.5, color: '#F0E68C' },
            [BLOCK.SPIDER_NEST]: { name: 'èœ˜è››å·¢', solid: true, transparent: false, light: 0, hardness: 2, color: '#2F2F2F' },
            [BLOCK.COBALT_BRICK]: { name: 'é’´ç –', solid: true, transparent: false, light: 1, hardness: 5, color: '#1E90FF' },
            [BLOCK.MYTHRIL_BRICK]: { name: 'ç§˜é“¶ç –', solid: true, transparent: false, light: 1, hardness: 5, color: '#3CB371' },
            [BLOCK.GOLD_BRICK]: { name: 'é‡‘ç –', solid: true, transparent: false, light: 2, hardness: 5, color: '#FFD700' },
            [BLOCK.SILVER_BRICK]: { name: 'é“¶ç –', solid: true, transparent: false, light: 1, hardness: 5, color: '#C0C0C0' },
            [BLOCK.COPPER_BRICK]: { name: 'é“œç –', solid: true, transparent: false, light: 0, hardness: 4, color: '#B87333' },
            [BLOCK.PLATINUM_ORE]: { name: 'é“‚é‡‘çŸ¿', solid: true, transparent: false, light: 2, hardness: 7, color: '#E5E4E2' },
            [BLOCK.TUNGSTEN_ORE]: { name: 'é’¨çŸ¿', solid: true, transparent: false, light: 1, hardness: 6, color: '#5C5C5C' },
            [BLOCK.LEAD_ORE]: { name: 'é“…çŸ¿', solid: true, transparent: false, light: 0, hardness: 5, color: '#3D3D3D' },
            [BLOCK.TIN_ORE]: { name: 'é”¡çŸ¿', solid: true, transparent: false, light: 0, hardness: 4, color: '#D3D3D3' },
            [BLOCK.METEORITE_BRICK]: { name: 'é™¨çŸ³ç –', solid: true, transparent: false, light: 3, hardness: 6, color: '#CD5C5C' },
            [BLOCK.HELLSTONE_BRICK]: { name: 'ç‹±å²©ç –', solid: true, transparent: false, light: 5, hardness: 7, color: '#FF4500' },
            [BLOCK.LIFE_CRYSTAL]: { name: 'ç”Ÿå‘½æ°´æ™¶', solid: true, transparent: true, light: 10, hardness: 3, color: '#FF1493' },
            [BLOCK.MANA_CRYSTAL]: { name: 'é­”åŠ›æ°´æ™¶', solid: true, transparent: true, light: 10, hardness: 3, color: '#00BFFF' },
            [BLOCK.HEART_CRYSTAL]: { name: 'å¿ƒä¹‹æ°´æ™¶', solid: true, transparent: true, light: 12, hardness: 4, color: '#FF69B4' },
            [BLOCK.ALTAR]: { name: 'ç¥­å›', solid: true, transparent: false, light: 5, hardness: 8, color: '#4B0082' },
            [BLOCK.DEMON_ALTAR]: { name: 'æ¶é­”ç¥­å›', solid: true, transparent: false, light: 6, hardness: 10, color: '#8B008B' },
            [BLOCK.CRIMSON_ALTAR]: { name: 'çŒ©çº¢ç¥­å›', solid: true, transparent: false, light: 6, hardness: 10, color: '#DC143C' },
            [BLOCK.SUNPLATE]: { name: 'æ—¥ç›˜', solid: true, transparent: false, light: 8, hardness: 4, color: '#FFD700' },
            [BLOCK.MOONPLATE]: { name: 'æœˆç›˜', solid: true, transparent: false, light: 6, hardness: 4, color: '#C0C0C0' },
            [BLOCK.STARFALL]: { name: 'æ˜Ÿè½', solid: false, transparent: true, light: 10, hardness: 0, color: '#FFFF00' },
            [BLOCK.ROSE]: { name: 'ç«ç‘°', solid: false, transparent: true, light: 0, hardness: 0, color: '#FF007F' },
            [BLOCK.TULIP]: { name: 'éƒé‡‘é¦™', solid: false, transparent: true, light: 0, hardness: 0, color: '#FF6347' },
            [BLOCK.ORCHID]: { name: 'å…°èŠ±', solid: false, transparent: true, light: 1, hardness: 0, color: '#DA70D6' },
            [BLOCK.LILY]: { name: 'ç™¾åˆ', solid: false, transparent: true, light: 0, hardness: 0, color: '#FFFAF0' },
            [BLOCK.SEAWEED]: { name: 'æµ·è‰', solid: false, transparent: true, light: 0, hardness: 0, color: '#2E8B57' },
            [BLOCK.KELP]: { name: 'æµ·å¸¦', solid: false, transparent: true, light: 0, hardness: 0, color: '#556B2F' },
            [BLOCK.SEA_OATS]: { name: 'æµ·ç‡•éº¦', solid: false, transparent: true, light: 0, hardness: 0, color: '#F4A460' },
            [BLOCK.PALM_TREE_TOP]: { name: 'æ£•æ¦ˆæ ‘é¡¶', solid: false, transparent: true, light: 0, hardness: 0.3, color: '#32CD32' },
            [BLOCK.GIANT_TREE_LOG]: { name: 'å·¨æ ‘åŸæœ¨', solid: true, transparent: false, light: 0, hardness: 4, color: '#5D4037' },
            [BLOCK.HONEY_DRIP]: { name: 'èœ‚èœœæ»´', solid: false, transparent: true, light: 2, hardness: 0, color: '#FFB90F' },
            [BLOCK.SLIME_BLOCK]: { name: 'å²è±å§†å—', solid: true, transparent: true, light: 2, hardness: 1, color: '#00FF7F' },
            [BLOCK.GEL_BLOCK]: { name: 'å‡èƒ¶å—', solid: true, transparent: true, light: 1, hardness: 0.5, color: '#7FFFD4' },
            [BLOCK.RAINBOW_BRICK]: { name: 'å½©è™¹ç –', solid: true, transparent: false, light: 6, hardness: 4, color: '#FF69B4' },
            [BLOCK.CONFETTI_BLOCK]: { name: 'äº”å½©çº¸å±‘', solid: false, transparent: true, light: 0, hardness: 0, color: '#FFD700' },
            [BLOCK.PARTY_BLOCK]: { name: 'æ´¾å¯¹å—', solid: true, transparent: false, light: 4, hardness: 2, color: '#FF1493' },
            [BLOCK.PUMPKIN]: { name: 'å—ç“œ', solid: true, transparent: false, light: 2, hardness: 1, color: '#FF7F00' },
            [BLOCK.HAY]: { name: 'å¹²è‰', solid: true, transparent: false, light: 0, hardness: 0.5, color: '#DAA520' },
            [BLOCK.SCARECROW]: { name: 'ç¨»è‰äºº', solid: true, transparent: false, light: 0, hardness: 1, color: '#8B4513' },
            [BLOCK.GRAVESTONE]: { name: 'å¢“ç¢‘', solid: true, transparent: false, light: 0, hardness: 3, color: '#696969' },
            [BLOCK.CROSS]: { name: 'åå­—æ¶', solid: true, transparent: false, light: 0, hardness: 2, color: '#808080' },
            [BLOCK.SKULL_BLOCK]: { name: 'å¤´éª¨å—', solid: true, transparent: false, light: 0, hardness: 2, color: '#FFFAF0' },
            [BLOCK.ROPE]: { name: 'ç»³ç´¢', solid: false, transparent: true, light: 0, hardness: 0.1, color: '#DEB887' },
            [BLOCK.CHAIN]: { name: 'é”é“¾', solid: false, transparent: true, light: 0, hardness: 1, color: '#A9A9A9' },
            [BLOCK.WEB_ROPE]: { name: 'è››ä¸ç»³', solid: false, transparent: true, light: 0, hardness: 0.1, color: '#F5F5F5' },
            [BLOCK.PLATFORMS_WOOD]: { name: 'æœ¨å¹³å°', solid: false, transparent: true, light: 0, hardness: 0.5, color: '#DEB887' },
            [BLOCK.PLATFORMS_STONE]: { name: 'çŸ³å¹³å°', solid: false, transparent: true, light: 0, hardness: 1, color: '#808080' },
            [BLOCK.PLATFORMS_METAL]: { name: 'é‡‘å±å¹³å°', solid: false, transparent: true, light: 0, hardness: 1.5, color: '#C0C0C0' },
            [BLOCK.MUSHROOM_GRASS]: { name: 'è˜‘è‡è‰', solid: true, transparent: false, light: 3, hardness: 1, color: '#4169E1' },
            [BLOCK.JUNGLE_SPORE]: { name: 'ä¸›æ—å­¢å­', solid: false, transparent: true, light: 4, hardness: 0, color: '#00FF00' },
            [BLOCK.NATURE_SHRINE]: { name: 'è‡ªç„¶ç¥é¾›', solid: true, transparent: false, light: 8, hardness: 5, color: '#228B22' },
            [BLOCK.FIRE_BLOSSOM]: { name: 'ç«ç„°èŠ±', solid: false, transparent: true, light: 6, hardness: 0, color: '#FF4500' },
            [BLOCK.MOONGLOW]: { name: 'æœˆå…‰è‰', solid: false, transparent: true, light: 5, hardness: 0, color: '#87CEEB' },
            [BLOCK.DAYBLOOM]: { name: 'å¤ªé˜³èŠ±', solid: false, transparent: true, light: 3, hardness: 0, color: '#FFFF00' },
            [BLOCK.WATERLEAF]: { name: 'æ°´å¶è‰', solid: false, transparent: true, light: 2, hardness: 0, color: '#00CED1' },
            [BLOCK.DEATHWEED]: { name: 'æ­»äº¡è‰', solid: false, transparent: true, light: 1, hardness: 0, color: '#2F4F4F' },
            [BLOCK.BLINKROOT]: { name: 'é—ªçƒæ ¹', solid: false, transparent: true, light: 4, hardness: 0, color: '#ADFF2F' },
            [BLOCK.SHIVERTHORN]: { name: 'å¯’é¢¤è†æ£˜', solid: false, transparent: true, light: 2, hardness: 0, color: '#E0FFFF' },
            [BLOCK.FIREBLOSSOM]: { name: 'çƒˆç„°èŠ±', solid: false, transparent: true, light: 8, hardness: 0, color: '#FF6347' }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                       Block lookup tables (æ€§èƒ½ä¼˜åŒ–)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // è¯´æ˜ï¼šæŠŠ BLOCK_DATA ä¸­é«˜é¢‘è®¿é—®çš„å±æ€§æ˜ å°„åˆ°å®šé•¿æ•°ç»„ï¼Œå‡å°‘å¯¹è±¡æŸ¥æ‰¾/å¯é€‰é“¾å¼€é”€ã€‚
        // ä¸æ”¹å˜ä»»ä½•æ•°å€¼ä¸ç”»é¢é€»è¾‘ï¼Œåªæ˜¯æŠŠè¯»å–è·¯å¾„å˜å¿«ã€‚

        const BLOCK_MAX_ID = 256; // tiles/light ä½¿ç”¨ Uint8Arrayï¼ŒID èŒƒå›´å¤©ç„¶åœ¨ 0~255
        const BLOCK_SOLID = new Uint8Array(BLOCK_MAX_ID);
        const BLOCK_TRANSPARENT = new Uint8Array(BLOCK_MAX_ID);
        const BLOCK_LIQUID = new Uint8Array(BLOCK_MAX_ID);
        const BLOCK_LIGHT = new Uint8Array(BLOCK_MAX_ID);
        const BLOCK_HARDNESS = new Float32Array(BLOCK_MAX_ID);
        const BLOCK_COLOR = new Array(BLOCK_MAX_ID);

        // å¤ªé˜³å…‰æŸ±å‘ä¸‹è¡°å‡ï¼ˆä¸åŸ Game._updateLight è§„åˆ™ä¿æŒä¸€è‡´ï¼‰ï¼š0 / 1 / 3
        const SUN_DECAY = new Uint8Array(BLOCK_MAX_ID);

        // è¿·ä½ åœ°å›¾ç”¨ï¼šæŠŠé¢œè‰²é¢„å…ˆæ‰“åŒ…æˆ 0xRRGGBBï¼Œé¿å…æ¯åƒç´  hexToRgb + å¯¹è±¡åˆ†é…
        const BLOCK_COLOR_PACKED = new Uint32Array(BLOCK_MAX_ID);
        const BLOCK_WALKABLE = new Uint8Array(BLOCK_MAX_ID);

        (function buildBlockTables() {
            // fallback ä¸åŸ Minimap é‡Œ '#F0F' + hexToRgb çš„â€œå®é™…ç»“æœâ€ä¸€è‡´ï¼š
            // r = parseInt('F0',16)=240, g=parseInt('F',16)=15, b=parseInt('',16)=NaN -> å†™å…¥ Uint8ClampedArray æ—¶ä¼šå˜ 0
            const FALLBACK_PACKED = (240 << 16) | (15 << 8) | 0;

            for (const k in BLOCK_DATA) {
                const id = Number(k);
                if (!Number.isFinite(id) || id < 0 || id >= BLOCK_MAX_ID) continue;

                const d = BLOCK_DATA[id];
                if (!d) continue;

                BLOCK_SOLID[id] = d.solid ? 1 : 0;
                BLOCK_TRANSPARENT[id] = d.transparent ? 1 : 0;
                BLOCK_LIQUID[id] = d.liquid ? 1 : 0;
                BLOCK_LIGHT[id] = d.light ? d.light : 0;
                BLOCK_HARDNESS[id] = d.hardness ? d.hardness : 0;
                BLOCK_COLOR[id] = d.color;

                if (d.solid && !d.transparent) SUN_DECAY[id] = 3;
                else if (d.transparent && id !== BLOCK.AIR) SUN_DECAY[id] = 1;
                else SUN_DECAY[id] = 0;

                if (typeof d.color === 'string' && d.color.length === 7) {
                    const r = parseInt(d.color.slice(1, 3), 16);
                    const g = parseInt(d.color.slice(3, 5), 16);
                    const b = parseInt(d.color.slice(5, 7), 16);
                    BLOCK_COLOR_PACKED[id] = (r << 16) | (g << 8) | b;
                } else {
                    BLOCK_COLOR_PACKED[id] = FALLBACK_PACKED;
                }
            }
        })();

        (function buildWalkableTable() {
            for (let i = 0; i < BLOCK_MAX_ID; i++) {
                BLOCK_WALKABLE[i] = BLOCK_SOLID[i] ? 0 : 1;
            }
        })();

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 6: Settings, Toast, Fullscreen, Audio
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class GameSettings {
            static KEY = 'terraria_ultra_settings_v1';
            static defaults() {
                const prefersReducedMotion = (() => {
                    try { return !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches); } catch { return false; }
                })();
                return {
                    // ç”»è´¨
                    dprCap: 2,
                    particles: true,
                    ambient: true,
                    bgMountains: true,
                    minimap: true,

                    // åæœŸç”»é¢å¢å¼ºï¼š0 å…³ / 1 è½»é‡ / 2 æè‡´
                    postFxMode: 2,
                    // è§¦æ§ä¸ä½“éªŒ
                    aimAssist: true,
                    vibration: true,
                    cameraSmooth: 0.08,   // 0.03~0.18ï¼ˆè¶Šå¤§è¶Šé¡ºæ»‘ä½†æ›´æ…¢è·Ÿï¼‰
                    lookAhead: 1.0,       // 0~1.5ï¼ˆé•œå¤´å‰ç»å¼ºåº¦ï¼‰
                    placeIntervalMs: 80,  // è¿ç»­æ”¾ç½®èŠ‚æµï¼ˆmsï¼‰

                    // UI
                    joystickSize: 140,
                    // æ‘‡æ†ï¼šæ­»åŒº + çµæ•åº¦æ›²çº¿ï¼ˆç§»åŠ¨ç«¯æ›´ç¨³å®šæ›´è·Ÿæ‰‹ï¼‰
                    joystickDeadzone: 0.14,
                    joystickCurve: 2.2,
                    buttonSize: 70,
                    showFps: false,

                    // éŸ³é¢‘ä¸æ— éšœç¢
                    sfxVolume: 0.35,
                    reducedMotion: prefersReducedMotion,

                    // æ€§èƒ½è°ƒåº¦
                    autoQuality: true,

                    // å­˜æ¡£
                    autosaveMs: 30000,
                };
            }
            static sanitize(o) {
                const d = GameSettings.defaults();

                // é˜²å¾¡æ€§ï¼šé˜²æ­¢åŸå‹æ±¡æŸ“
                const forbiddenKeys = ['__proto__', 'constructor', 'prototype'];
                const safeObj = {};
                if (o && typeof o === 'object') {
                    for (const key of Object.keys(o)) {
                        if (forbiddenKeys.includes(key)) {
                            console.warn('[GameSettings] Forbidden key detected:', key);
                            continue;
                        }
                        safeObj[key] = o[key];
                    }
                }

                const s = Object.assign({}, d, safeObj);

                // å¢å¼ºçš„æ•°å€¼éªŒè¯å™¨
                const num = (v, min, max, fallback) => {
                    const n = Number(v);
                    if (Number.isNaN(n) || !Number.isFinite(n)) return fallback;
                    return Math.max(min, Math.min(max, n));
                };

                s.dprCap = num(s.dprCap, 1, 2, d.dprCap);
                s.postFxMode = num(s.postFxMode, 0, 2, d.postFxMode);
                s.joystickSize = num(s.joystickSize, 110, 200, d.joystickSize);
                s.joystickDeadzone = num(s.joystickDeadzone, 0, 0.35, d.joystickDeadzone);
                s.joystickCurve = num(s.joystickCurve, 1, 4, d.joystickCurve);
                s.buttonSize = num(s.buttonSize, 52, 100, d.buttonSize);
                s.sfxVolume = num(s.sfxVolume, 0, 1, d.sfxVolume);
                s.autosaveMs = num(s.autosaveMs, 10000, 120000, d.autosaveMs);
                s.cameraSmooth = num(s.cameraSmooth, 0.03, 0.18, d.cameraSmooth);
                s.lookAhead = num(s.lookAhead, 0, 1.5, d.lookAhead);
                s.placeIntervalMs = num(s.placeIntervalMs, 40, 200, d.placeIntervalMs);

                s.aimAssist = !!s.aimAssist;
                s.vibration = !!s.vibration;
                s.showFps = !!s.showFps;
                s.autoQuality = (s.autoQuality === undefined) ? d.autoQuality : !!s.autoQuality;

                s.particles = !!s.particles;
                s.ambient = !!s.ambient;
                s.bgMountains = (s.bgMountains === undefined) ? d.bgMountains : !!s.bgMountains;
                s.minimap = !!s.minimap;
                s.reducedMotion = !!s.reducedMotion;
                return s;
            }
            static load() {
                try {
                    const raw = localStorage.getItem(GameSettings.KEY);
                    if (!raw) return GameSettings.defaults();

                    // æ£€æŸ¥æ•°æ®å¤§å°
                    if (raw.length > 100 * 1024) { // 100KBé™åˆ¶
                        console.warn('[GameSettings] Settings data too large');
                        return GameSettings.defaults();
                    }

                    const parsed = JSON.parse(raw);
                    return GameSettings.sanitize(parsed);
                } catch (e) {
                    console.error('[GameSettings] Load error:', e);
                    return GameSettings.defaults();
                }
            }

            static save(settings) {
                try {
                    const sanitized = GameSettings.sanitize(settings);
                    const serialized = JSON.stringify(sanitized);

                    // æ£€æŸ¥åºåˆ—åŒ–åçš„å¤§å°
                    if (serialized.length > 100 * 1024) {
                        console.warn('[GameSettings] Settings too large to save');
                        return false;
                    }

                    localStorage.setItem(GameSettings.KEY, serialized);
                    return true;
                } catch (e) {
                    console.error('[GameSettings] Save error:', e);
                    return false;
                }
            }

            static applyToDocument(settings) {
                const s = GameSettings.sanitize(settings);
                const root = document.documentElement;

                // å®‰å…¨çš„CSSå€¼è®¾ç½®
                const safeCSS = (value, unit = 'px') => {
                    const num = Number(value);
                    if (Number.isNaN(num) || !Number.isFinite(num)) return null;
                    const clamped = Math.max(0, Math.min(10000, num));
                    return `${clamped}${unit}`;
                };

                const joySize = safeCSS(s.joystickSize);
                if (joySize) root.style.setProperty('--joy-size', joySize);

                const btnSize = safeCSS(s.buttonSize);
                if (btnSize) root.style.setProperty('--btn-size', btnSize);

                root.classList.toggle('reduced-motion', !!s.reducedMotion);

                const minimap = document.getElementById('minimap');
                if (minimap) minimap.style.display = s.minimap ? '' : 'none';

                const ambient = document.getElementById('ambient-particles');
                if (ambient) ambient.style.display = s.ambient ? '' : 'none';

                const fpsEl = document.getElementById('fps');
                if (fpsEl) fpsEl.style.display = s.showFps ? '' : 'none';

                // ä¾¿äº Renderer è¯»åˆ°
                window.GAME_SETTINGS = s;
                return s;
            }
        }

        class Toast {
            static el() { return document.getElementById('toast-container'); }
            static show(msg, ms = 1600) {
                const host = Toast.el();
                if (!host) return;
                const t = document.createElement('div');
                t.className = 'toast';
                t.textContent = msg;
                host.appendChild(t);
                requestAnimationFrame(() => t.classList.add('show'));
                setTimeout(() => {
                    t.classList.remove('show');
                    setTimeout(() => t.remove(), 220);
                }, ms);
            }
        }

            class FullscreenManager {
                static supported() {
                    const de = document.documentElement;
                    return !!(de && de.requestFullscreen && document.exitFullscreen);
                }

                static async request() {
                    const doc = document;
                    if (!doc.documentElement || !doc.documentElement.requestFullscreen) return false;
                    await doc.documentElement.requestFullscreen();
                    // å°è¯•é”å®šæ¨ªå±ï¼ˆå¤±è´¥ä¸å½±å“ï¼‰
                    try {
                        if (screen.orientation && screen.orientation.lock) {
                            await screen.orientation.lock('landscape');
                        }
                    } catch { }
                    return true;
                }

                static async exit() {
                    const doc = document;
                    if (!doc.exitFullscreen) return false;
                    await doc.exitFullscreen();
                    return true;
                }

                static _toast(msg, ms = 1000) {
                    try {
                        if (toast && typeof toast.show === 'function') {
                            toast.show(msg, ms);
                            return;
                        }
                    } catch { }
                    // fallback
                    console.log(msg);
                }

                static async toggle() {
                    try {
                        const doc = document;
                        if (!FullscreenManager.supported()) {
                            FullscreenManager._toast('âš ï¸ è®¾å¤‡ä¸æ”¯æŒå…¨å±', 1200);
                            return;
                        }
                        if (doc.fullscreenElement) {
                            await FullscreenManager.exit();
                            FullscreenManager._toast('ğŸ§© å·²é€€å‡ºå…¨å±', 900);
                        } else {
                            await FullscreenManager.request();
                            FullscreenManager._toast('ğŸ–¥ å·²è¿›å…¥å…¨å±', 900);
                        }
                    } catch {
                        FullscreenManager._toast('âš ï¸ å…¨å±è¯·æ±‚å¤±è´¥', 1200);
                    }
                }
            }

        class AudioManager {
            constructor(settings) {
                this.settings = settings;
                this.ctx = null;
                this._noiseBuf = null;
                this._armed = false;
            }
            arm() {
                if (this._armed) return;
                this._armed = true;
                const armNow = () => {
                    if (!this.ctx) {
                        const AC = window.AudioContext || window.webkitAudioContext;
                        if (!AC) return;
                        this.ctx = new AC();
                        this._noiseBuf = this._makeNoiseBuffer();
                    }
                    if (this.ctx && this.ctx.state === 'suspended') {
                        this.ctx.resume().catch(() => { });
                    }
                };
                window.addEventListener('pointerdown', armNow, { once: true, passive: true });
                window.addEventListener('touchstart', armNow, { once: true, passive: true });
                window.addEventListener('keydown', armNow, { once: true, passive: true });
            }
            setVolume(v01) { this.settings.sfxVolume = Math.max(0, Math.min(1, v01)); }
            _makeNoiseBuffer() {
                if (!this.ctx) return null;
                const sr = this.ctx.sampleRate;
                const len = Math.floor(sr * 0.12);
                const b = this.ctx.createBuffer(1, len, sr);
                const d = b.getChannelData(0);
                for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / len);
                return b;
            }
            _gain(v) {
                if (!this.ctx) return null;
                const g = this.ctx.createGain();
                g.gain.value = v;
                return g;
            }
            beep(freq = 440, dur = 0.06, type = 'sine', vol = 1) {
                if (!this.ctx) return;
                const v = (this.settings.sfxVolume || 0) * vol;
                if (v <= 0.0001) return;

                const o = this.ctx.createOscillator();
                o.type = type;
                o.frequency.value = freq;

                const g = this._gain(0);
                const now = this.ctx.currentTime;
                g.gain.setValueAtTime(0.0001, now);
                g.gain.exponentialRampToValueAtTime(v, now + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

                o.connect(g);
                g.connect(this.ctx.destination);
                o.start(now);
                o.stop(now + dur + 0.02);
            }
            noise(dur = 0.08, vol = 1) {
                if (!this.ctx || !this._noiseBuf) return;
                const v = (this.settings.sfxVolume || 0) * vol;
                if (v <= 0.0001) return;

                const src = this.ctx.createBufferSource();
                src.buffer = this._noiseBuf;

                const g = this._gain(0);
                const now = this.ctx.currentTime;
                g.gain.setValueAtTime(0.0001, now);
                g.gain.exponentialRampToValueAtTime(v, now + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

                src.connect(g);
                g.connect(this.ctx.destination);
                src.start(now);
                src.stop(now + dur + 0.02);
            }
            play(kind) {
                // éªŒè¯kindå‚æ•°
                const validKinds = ['mine', 'place', 'pickup', 'ui', 'error'];
                if (!validKinds.includes(kind)) {
                    console.warn('[AudioManager] Invalid sound kind:', kind);
                    return;
                }

                try {
                    switch (kind) {
                        case 'mine':
                            this.noise(0.06, 0.9);
                            this.beep(220, 0.05, 'triangle', 0.35);
                            break;
                        case 'place':
                            this.beep(320, 0.05, 'square', 0.35);
                            break;
                        case 'pickup':
                            this.beep(660, 0.05, 'sine', 0.35);
                            break;
                        case 'ui':
                            this.beep(520, 0.04, 'sine', 0.25);
                            break;
                        case 'error':
                            this.beep(140, 0.08, 'sawtooth', 0.4);
                            break;
                        default:
                            console.error('[AudioManager] Unreachable code in play()');
                    }
                } catch (e) {
                    console.error('[AudioManager] Play error:', e);
                }
            }
        }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 7: Save System (with IndexedDB support)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class SaveSystem {
            static KEY = 'terraria_ultra_save_v1';
            constructor(game) {
                this.game = game;
                this.seed = null;
                this.diff = new Map(); // key "x,y" -> blockId
                this._autosaveAcc = 0;
                this._disabled = false;
            }

            static hasSave() {
                try { return !!localStorage.getItem(SaveSystem.KEY); } catch { return false; }
            }
            static clear() {
                try { localStorage.removeItem(SaveSystem.KEY); } catch { }
            }
            static load() {
                try {
                    const raw = localStorage.getItem(SaveSystem.KEY);
                    if (!raw) return null;

                    // æ£€æŸ¥æ•°æ®å¤§å°
                    if (raw.length > 10 * 1024 * 1024) { // 10MBé™åˆ¶
                        console.error('[SaveSystem] Save data too large');
                        return null;
                    }

                    const data = JSON.parse(raw);

                    // éªŒè¯åŸºæœ¬ç»“æ„
                    if (!data || typeof data !== 'object' || data.v !== 1) {
                        console.warn('[SaveSystem] Invalid save format');
                        return null;
                    }

                    // éªŒè¯å¿…éœ€å­—æ®µ
                    const requiredFields = ['ts', 'seed', 'player', 'w', 'h'];
                    for (const field of requiredFields) {
                        if (!(field in data)) {
                            console.warn('[SaveSystem] Missing required field:', field);
                            return null;
                        }
                    }

                    // è§£ç  diffsï¼ˆæ”¯æŒæ—§ç‰ˆæ•°ç»„ & æ–°ç‰ˆ RLEï¼‰
                    const diff = new Map();
                    const diffs = data.diffs;

                    // æ—§ç‰ˆï¼š["x_y_id", ...]
                    if (Array.isArray(diffs)) {
                        for (const s of diffs) {
                            if (typeof s !== 'string') continue;
                            const parts = s.split('_');
                            if (parts.length !== 3) continue;
                            const x = parseInt(parts[0], 36);
                            const y = parseInt(parts[1], 36);
                            const id = parseInt(parts[2], 36);
                            if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(id)) continue;
                            diff.set(x + ',' + y, id);
                        }
                    }
                    // æ–°ç‰ˆï¼š{ fmt:'rle1', w, data:[ 'r<start>_<len>_<id>', ... ] }
                    else if (diffs && typeof diffs === 'object' && diffs.fmt === 'rle1' && Array.isArray(diffs.data)) {
                        const fallbackW = (Number.isFinite(data.w) ? (data.w | 0) : ((typeof CONFIG !== 'undefined' && CONFIG && Number.isFinite(CONFIG.WORLD_WIDTH)) ? (CONFIG.WORLD_WIDTH | 0) : 0));
                        const w = Number.isFinite(diffs.w) ? (diffs.w | 0) : fallbackW;
                        if (!Number.isFinite(w) || w <= 0) return null;

                        // é™åˆ¶diffæ¡ç›®æ•°
                        let totalEntries = 0;
                        const MAX_DIFF_ENTRIES = 100000;

                        for (const token of diffs.data) {
                            if (typeof token !== 'string') continue;
                            const t = token.charAt(0) === 'r' ? token.slice(1) : token;
                            const parts = t.split('_');
                            if (parts.length !== 3) continue;
                            const start = parseInt(parts[0], 36);
                            const len = parseInt(parts[1], 36);
                            const id = parseInt(parts[2], 36);
                            if (!Number.isFinite(start) || !Number.isFinite(len) || !Number.isFinite(id) || len <= 0) continue;

                            // é˜²å¾¡ï¼šé¿å…å¼‚å¸¸å­˜æ¡£å¯¼è‡´é•¿å¾ªç¯
                            const maxLen = Math.min(len, 20000);
                            for (let i = 0; i < maxLen; i++) {
                                if (totalEntries >= MAX_DIFF_ENTRIES) {
                                    console.warn('[SaveSystem] Diff entries limit reached');
                                    break;
                                }
                                const idx = start + i;
                                const x = idx % w;
                                const y = (idx / w) | 0;
                                diff.set(x + ',' + y, id);
                                totalEntries++;
                            }
                        }
                    }

                    data._diffMap = diff;
                    return data;
                } catch (e) {
                    console.error('[SaveSystem] Load error:', e);
                    return null;
                }
            }
            static _encodeDiff(diffMap, worldW) {
                const fallbackW = (typeof CONFIG !== 'undefined' && CONFIG && Number.isFinite(CONFIG.WORLD_WIDTH)) ? (CONFIG.WORLD_WIDTH | 0) : 0;
                const w = Number.isFinite(worldW) ? (worldW | 0) : fallbackW;
                if (!Number.isFinite(w) || w <= 0) return { fmt: 'rle1', w: (fallbackW || 0), data: [] };

                // RLEï¼šæŒ‰çº¿æ€§ç´¢å¼•æ’åºï¼Œå°†è¿ç»­ä¸”ç›¸åŒçš„ blockId åˆå¹¶ä¸ºä¸€æ¡è®°å½•
                const entries = [];
                for (const [k, id] of diffMap.entries()) {
                    const [x, y] = k.split(',').map(n => parseInt(n, 10));
                    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(id)) continue;
                    entries.push([y * w + x, id]);
                }
                entries.sort((a, b) => a[0] - b[0]);

                const out = [];
                for (let i = 0; i < entries.length;) {
                    const start = entries[i][0];
                    const id = entries[i][1];
                    let len = 1;
                    while (i + len < entries.length && entries[i + len][1] === id && entries[i + len][0] === start + len) len++;
                    out.push('r' + start.toString(36) + '_' + len.toString(36) + '_' + id.toString(36));
                    i += len;
                }

                return { fmt: 'rle1', w, data: out };
            }

            static async promptStartIfNeeded() {
                const has = SaveSystem.hasSave();
                if (!has) return { mode: 'new', save: null };
                const overlay = document.getElementById('save-prompt-overlay');
                const btnC = document.getElementById('save-prompt-continue');
                const btnN = document.getElementById('save-prompt-new');
                const btnX = document.getElementById('save-prompt-close');

                if (!overlay || !btnC || !btnN) return { mode: 'new', save: null };

                return await new Promise((resolve) => {
                    const done = (mode) => {
                        overlay.classList.remove('show');
                        overlay.setAttribute('aria-hidden', 'true');
                        btnC.removeEventListener('click', onC);
                        btnN.removeEventListener('click', onN);
                        btnX && btnX.removeEventListener('click', onX);
                        let loaded = null;
                        if (mode === 'continue') {
                            loaded = SaveSystem.load();
                            if (!loaded) {
                                try { if (typeof Toast !== 'undefined' && Toast && Toast.show) Toast.show('âš ï¸ å­˜æ¡£æŸåæˆ–ä¸å…¼å®¹ï¼šå·²å¼€å§‹æ–°ä¸–ç•Œ', 2600); } catch { }
                                try { SaveSystem.clear(); } catch { }
                                mode = 'new';
                            }
                        }
                        resolve({ mode, save: loaded });
                    };
                    const onC = () => done('continue');
                    const onN = () => done('new');
                    const onX = () => done('new');
                    overlay.classList.add('show');
                    overlay.setAttribute('aria-hidden', 'false');
                    btnC.addEventListener('click', onC);
                    btnN.addEventListener('click', onN);
                    if (btnX) btnX.addEventListener('click', onX);
                });
            }

            importLoaded(save) {
                if (!save) return;
                this.seed = save.seed;
                this.diff = save._diffMap || new Map();
            }

            markTile(x, y, newId) {
                if (this._disabled) return;
                this.diff.set(x + ',' + y, newId);
            }

            tickAutosave(dt) {
                if (this._disabled) return;
                this._autosaveAcc += dt;
                if (this._autosaveAcc >= (this.game.settings.autosaveMs || 30000)) {
                    this._autosaveAcc = 0;
                    this.save('autosave');
                }
            }

            save(reason = 'manual') {
                if (this._disabled) return;
                const g = this.game;
                if (!g || !g.world || !g.player) {
                    console.warn('[SaveSystem] Cannot save: invalid game state');
                    return;
                }

                // diffå¤§å°é™åˆ¶
                if (this.diff.size > 50000) {
                    this._disabled = true;
                    Toast.show('âš ï¸ æ”¹åŠ¨è¿‡å¤šï¼šè‡ªåŠ¨ä¿å­˜å·²åœç”¨ï¼ˆå¯æ‰‹åŠ¨ä¿å­˜/æ¸…ç†å­˜æ¡£ï¼‰', 2800);
                    return;
                }

                // éªŒè¯ç©å®¶æ•°æ®
                if (!Number.isFinite(g.player.x) || !Number.isFinite(g.player.y)) {
                    console.warn('[SaveSystem] Invalid player position');
                    return;
                }

                const payload = {
                    v: 1,
                    ts: Date.now(),
                    seed: g.seed || this.seed || Date.now(),
                    timeOfDay: Math.max(0, Math.min(1, g.timeOfDay || 0.35)),
                    player: {
                        x: g.player.x,
                        y: g.player.y,
                        health: Math.max(0, Math.min(1000, g.player.health || 100)),
                        mana: Math.max(0, Math.min(1000, g.player.mana || 100)),
                        inventory: Array.isArray(g.player.inventory) ? g.player.inventory.slice(0, 36) : [],
                        selectedSlot: Math.max(0, Math.min(35, g.player.selectedSlot || 0))
                    },
                    w: g.world.w,
                    h: g.world.h,
                    diffs: SaveSystem._encodeDiff(this.diff, g.world.w),
                };

                // æ£€æŸ¥åºåˆ—åŒ–åçš„å¤§å°
                let serialized;
                try {
                    serialized = JSON.stringify(payload);
                } catch (e) {
                    console.error('[SaveSystem] Serialization error:', e);
                    Toast.show('âš ï¸ å­˜æ¡£åºåˆ—åŒ–å¤±è´¥', 2600);
                    return;
                }

                if (serialized.length > 4 * 1024 * 1024) { // 4MBé™åˆ¶
                    this._disabled = true;
                    Toast.show('âš ï¸ å­˜æ¡£è¿‡å¤§ï¼šè‡ªåŠ¨ä¿å­˜å·²åœç”¨', 2800);
                    return;
                }

                try {
                    localStorage.setItem(SaveSystem.KEY, serialized);
                    if (reason === 'manual') Toast.show('ğŸ’¾ å·²ä¿å­˜');
                    if (reason === 'autosave') Toast.show('âœ… è‡ªåŠ¨ä¿å­˜', 1100);
                } catch (e) {
                    this._disabled = true;
                    Toast.show('âš ï¸ å­˜æ¡£å¤±è´¥ï¼šç©ºé—´ä¸è¶³ï¼Œå·²åœç”¨è‡ªåŠ¨ä¿å­˜', 2600);
                }
            }

            applyToWorld(world, save) {
                if (!world || !save || !save._diffMap) {
                    console.warn('[SaveSystem] Cannot apply to world: invalid parameters');
                    return;
                }

                let appliedCount = 0;
                const MAX_APPLY = 100000;

                for (const [k, id] of save._diffMap.entries()) {
                    if (appliedCount >= MAX_APPLY) {
                        console.warn('[SaveSystem] Apply limit reached');
                        break;
                    }

                    const parts = String(k).split(',');
                    if (parts.length !== 2) continue;

                    const x = parseInt(parts[0], 10);
                    const y = parseInt(parts[1], 10);

                    if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
                    if (!Number.isFinite(id)) continue;

                    if (x >= 0 && x < world.w && y >= 0 && y < world.h) {
                        if (Array.isArray(world.tiles) && Array.isArray(world.tiles[x])) {
                            world.tiles[x][y] = id;
                            appliedCount++;
                        }
                    }
                }

                console.log('[SaveSystem] Applied', appliedCount, 'tiles to world');
            }

            applyToPlayer(player, ui, save) {
                if (!player || !save || !save.player) return;
                const p = save.player;
                if (Number.isFinite(p.x)) player.x = p.x;
                if (Number.isFinite(p.y)) player.y = p.y;
                if (Number.isFinite(p.health)) player.health = p.health;
                if (Number.isFinite(p.mana)) player.mana = p.mana;
                if (Array.isArray(p.inventory)) { try { const maxSize = (typeof INVENTORY_LIMITS !== 'undefined' && INVENTORY_LIMITS && INVENTORY_LIMITS.MAX_SIZE) ? INVENTORY_LIMITS.MAX_SIZE : 36; const maxStack = (typeof INVENTORY_LIMITS !== 'undefined' && INVENTORY_LIMITS && INVENTORY_LIMITS.MAX_STACK) ? INVENTORY_LIMITS.MAX_STACK : 999; const inv = []; for (let i = 0; i < p.inventory.length && inv.length < maxSize; i++) { const it = p.inventory[i]; if (!it) continue; const id = (it.id != null) ? String(it.id) : ''; if (!id) continue; const bd = (typeof BLOCK_DATA !== 'undefined' && BLOCK_DATA) ? BLOCK_DATA[id] : null; if (!bd) continue; let c = Math.floor(+it.count || 0); if (!Number.isFinite(c) || c <= 0) continue; if (c > maxStack) c = maxStack; inv.push({ id: id, name: (it.name && typeof it.name === 'string') ? it.name : (bd.name || id), count: c }); } if (inv.length) player.inventory = inv; } catch (_) { player.inventory = p.inventory; } }
                if (Number.isFinite(p.selectedSlot)) { try { const maxHot = 8; const maxIdx = Math.min(maxHot, (player.inventory && player.inventory.length > 0) ? (player.inventory.length - 1) : maxHot); const s = Math.floor(p.selectedSlot); player.selectedSlot = Math.max(0, Math.min(maxIdx, s)); } catch (_) { player.selectedSlot = p.selectedSlot; } }
                if (ui) ui.buildHotbar();
            }
        }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 8: UX Wiring
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function applyInfoHintText(isMobile) {
            const el = document.getElementById('info');
            if (!el) return;

            // SECURITY: avoid innerHTML. Build DOM nodes to prevent XSS surface area.
            if (!isMobile) return;

            try {
                // Clear existing nodes
                while (el.firstChild) el.removeChild(el.firstChild);

                const parts = [
                    ['æ‘‡æ†', ' ç§»åŠ¨'],
                    ['â¬†ï¸', ' è·³è·ƒ'],
                    ['â›ï¸', ' æŒ–æ˜'],
                    ['ğŸ§±', ' æ”¾ç½®'],
                    ['âš’ï¸', ' åˆæˆ'],
                    ['ğŸ’', ' èƒŒåŒ…'],
                ];

                for (let i = 0; i < parts.length; i++) {
                    const [label, text] = parts[i];

                    const span = document.createElement('span');
                    span.className = 'highlight';
                    span.textContent = String(label);

                    el.appendChild(span);
                    el.appendChild(document.createTextNode(String(text)));

                    if (i < parts.length - 1) {
                        el.appendChild(document.createTextNode(' | '));
                    }
                }
            } catch (e) {
                // Fall back to plain text if DOM ops fail for any reason
                try {
                    el.textContent = 'æ‘‡æ† ç§»åŠ¨ | â¬†ï¸ è·³è·ƒ | â›ï¸ æŒ–æ˜ | ğŸ§± æ”¾ç½® | âš’ï¸ åˆæˆ | ğŸ’ èƒŒåŒ…';
                } catch (_) {}
            }
        }

        function wireUXUI(game) {
            // é¡¶éƒ¨æŒ‰é’®
            const btnPause = document.getElementById('btn-pause');
            const btnSettings = document.getElementById('btn-settings');
            const btnSave = document.getElementById('btn-save');
            const btnHelp = document.getElementById('btn-help');

            const pauseOverlay = document.getElementById('pause-overlay');
            const settingsOverlay = document.getElementById('settings-overlay');
            const helpOverlay = document.getElementById('help-overlay');

            const _overlayStack = [];
            const _overlayFocusStack = [];
            const _firstFocusable = (root) => {
                if (!root) return null;
                return root.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            };

            const showOverlay = (el) => {
                if (!el) return;

                // å·²ç»æ‰“å¼€ï¼šåªæŠŠç„¦ç‚¹æ‹‰å›é¢æ¿å†…ï¼Œé¿å…é‡å¤å…¥æ ˆå¯¼è‡´ç„¦ç‚¹/çŠ¶æ€é”™ä¹±
                try {
                    if (el.classList && el.classList.contains('show')) {
                        queueMicrotask(() => {
                            const t = _firstFocusable(el) || el;
                            try { t.focus({ preventScroll: true }); } catch { }
                        });
                        return;
                    }
                } catch { }

                // è®°å½•ç„¦ç‚¹ï¼šå…³é—­æ—¶å°½å¯èƒ½å›åˆ°åŸæ§ä»¶
                const prev = (document.activeElement instanceof HTMLElement) ? document.activeElement : null;
                _overlayStack.push(el);
                _overlayFocusStack.push(prev);

                el.classList.add('show');
                el.setAttribute('aria-hidden', 'false');
                el.setAttribute('role', 'dialog');
                el.setAttribute('aria-modal', 'true');

                document.body.classList.add('tu-modal-open');
                game._inputBlocked = true;
                if (Utils && Utils.resetGameInput) Utils.resetGameInput(game);

                // è‡ªåŠ¨èšç„¦é¢æ¿å†…ç¬¬ä¸€ä¸ªå¯äº¤äº’æ§ä»¶ï¼Œé”®ç›˜/æ‰‹æŸ„æ›´å‹å¥½
                queueMicrotask(() => {
                    const t = _firstFocusable(el) || el;
                    try { t.focus({ preventScroll: true }); } catch { }
                });
            };

            const hideOverlay = (el) => {
                if (!el) return;

                el.classList.remove('show');
                el.setAttribute('aria-hidden', 'true');
                el.removeAttribute('aria-modal');

                // ä»æ ˆä¸­ç§»é™¤ï¼ˆæ”¯æŒâ€œåµŒå¥—â€å¼¹çª—ï¼šå¸®åŠ© -> è®¾ç½® ç­‰ï¼‰
                const idx = _overlayStack.lastIndexOf(el);
                let prev = null;
                if (idx !== -1) {
                    _overlayStack.splice(idx, 1);
                    prev = _overlayFocusStack.splice(idx, 1)[0] || null;
                }

                // åªæœ‰å½“æ‰€æœ‰ overlay éƒ½å…³é—­æ—¶æ‰è§£é™¤å±è”½
                const anyOpen =
                    (pauseOverlay && pauseOverlay.classList.contains('show')) ||
                    (settingsOverlay && settingsOverlay.classList.contains('show')) ||
                    (helpOverlay && helpOverlay.classList.contains('show')) ||
                    (game.inventoryUI && game.inventoryUI.isOpen) ||
                    (game.crafting && game.crafting.isOpen);

                game._inputBlocked = anyOpen;
                if (!anyOpen) document.body.classList.remove('tu-modal-open');

                // è¿˜åŸç„¦ç‚¹
                if (prev && document.contains(prev)) {
                    queueMicrotask(() => {
                        try { prev.focus({ preventScroll: true }); } catch { }
                    });
                }
            };

            const setPaused = (v) => {
                game.paused = !!v;
                if (game.paused) showOverlay(pauseOverlay);
                else hideOverlay(pauseOverlay);
            };

            // äº¤ç»™ InputManager ç»Ÿä¸€å¤„ç†é”®ç›˜ï¼ˆEsc/H ç­‰ï¼‰ï¼Œé¿å…å¤šä¸ª keydown ç›‘å¬ç›¸äº’â€œæŠ¢é”®â€
            game._ux = {
                pauseOverlay,
                settingsOverlay,
                helpOverlay,
                showOverlay,
                hideOverlay,
                setPaused,
                isHelpOpen: () => !!(helpOverlay && helpOverlay.classList.contains('show')),
                isSettingsOpen: () => !!(settingsOverlay && settingsOverlay.classList.contains('show')),
                closeSettings: () => {
                    // ç»Ÿä¸€å…³é—­é€»è¾‘ï¼šæ ¹æ®è¿›å…¥å‰çŠ¶æ€å†³å®šè¿”å›æš‚åœèœå•æˆ–ç»§ç»­æ¸¸æˆ
                    hideOverlay(settingsOverlay);
                    if (game._settingsReturnToPause) {
                        showOverlay(pauseOverlay);
                        game.paused = true;
                    } else {
                        game.paused = false;
                        hideOverlay(pauseOverlay);
                    }
                },
                isPauseOpen: () => !!(pauseOverlay && pauseOverlay.classList.contains('show')),
                toggleHelp: () => {
                    if (!helpOverlay) return;
                    if (helpOverlay.classList.contains('show')) {
                        hideOverlay(helpOverlay);
                    } else {
                        showOverlay(helpOverlay);
                    }
                    try { localStorage.setItem('terraria_ultra_help_seen_v1', '1'); } catch { }
                }
            };

            if (btnPause) btnPause.addEventListener('click', () => { game.audio && game.audio.play('ui'); setPaused(!game.paused); });
            if (btnSettings) btnSettings.addEventListener('click', () => {
                game.audio && game.audio.play('ui');

                // è®°å½•ï¼šè¿›å…¥è®¾ç½®å‰æ˜¯å¦å·²å¤„äºæš‚åœï¼ˆç”¨äºè¿”å›é€»è¾‘ï¼‰
                game._settingsReturnToPause = !!game.paused;

                // åŒæ­¥æ§ä»¶å€¼
                syncSettingsControls(game.settings);

                // è®¾ç½®é¢æ¿æ‰“å¼€æ—¶ï¼šæš‚åœæ¸¸æˆã€éšè—æš‚åœèœå•ï¼ˆé¿å…å å±‚ï¼‰
                game.paused = true;
                hideOverlay(pauseOverlay);
                showOverlay(settingsOverlay);
            });
            if (btnSave) btnSave.addEventListener('click', () => {
                game.audio && game.audio.play('ui');
                game.saveSystem.save('manual');
            });
            if (btnHelp) btnHelp.addEventListener('click', () => {
                game.audio && game.audio.play('ui');
                if (helpOverlay) showOverlay(helpOverlay);
                try { localStorage.setItem('terraria_ultra_help_seen_v1', '1'); } catch { }
            });

            // æš‚åœé¢æ¿æŒ‰é’®
            const pauseClose = document.getElementById('pause-close');
            const pauseResume = document.getElementById('pause-resume');
            const pauseSave = document.getElementById('pause-save');
            const pauseNew = document.getElementById('pause-newworld');
            const pauseFullscreen = document.getElementById('pause-fullscreen');

            const resume = () => { game.audio && game.audio.play('ui'); game.paused = false; hideOverlay(pauseOverlay); };
            if (pauseClose) pauseClose.addEventListener('click', resume);
            if (pauseResume) pauseResume.addEventListener('click', resume);
            if (pauseSave) pauseSave.addEventListener('click', () => { game.audio && game.audio.play('ui'); game.saveSystem.save('manual'); });
            if (pauseNew) pauseNew.addEventListener('click', () => {
                game.audio && game.audio.play('ui');
                if (confirm('ç¡®å®šè¦å¼€å¯æ–°ä¸–ç•Œå—ï¼Ÿè¿™ä¼šæ¸…é™¤å½“å‰å­˜æ¡£ã€‚')) {
                    SaveSystem.clear();
                    location.reload();
                }
            });

            const toggleFullscreen = async () => {
                const fm = window.TU && window.TU.FullscreenManager;
                if (fm && typeof fm.toggle === 'function') return fm.toggle();
                // fallbackï¼ˆæç®€ï¼‰
                try {
                    const doc = document;
                    if (doc.fullscreenElement && doc.exitFullscreen) await doc.exitFullscreen();
                    else if (doc.documentElement && doc.documentElement.requestFullscreen) await doc.documentElement.requestFullscreen();
                } catch { }
            };
            if (pauseFullscreen) pauseFullscreen.addEventListener('click', () => { game.audio && game.audio.play('ui'); toggleFullscreen(); });

            // è®¾ç½®é¢æ¿æŒ‰é’®
            const settingsClose = document.getElementById('settings-close');
            const settingsApply = document.getElementById('settings-apply');
            const settingsReset = document.getElementById('settings-reset');
            const settingsClear = document.getElementById('settings-clear-save');

            if (settingsClose) settingsClose.addEventListener('click', () => {
                game.audio && game.audio.play('ui');
                // å…³é—­è®¾ç½®ï¼šè‹¥åŸæœ¬åœ¨æš‚åœèœå•ä¸­è¿›å…¥ï¼Œåˆ™è¿”å›æš‚åœèœå•ï¼›å¦åˆ™ç»§ç»­æ¸¸æˆ
                hideOverlay(settingsOverlay);
                if (game._settingsReturnToPause) {
                    showOverlay(pauseOverlay);
                    game.paused = true;
                } else {
                    game.paused = false;
                    hideOverlay(pauseOverlay);
                }
            });
            if (settingsReset) settingsReset.addEventListener('click', () => {
                game.audio && game.audio.play('ui');
                game.settings = GameSettings.applyToDocument(GameSettings.defaults());
                if (game.quality && typeof game.quality.onSettingsChanged === 'function') game.quality.onSettingsChanged();
                GameSettings.save(game.settings);
                syncSettingsControls(game.settings);

                // ä½“éªŒå‚æ•°å³æ—¶ç”Ÿæ•ˆ
                game._placeIntervalMs = game.settings.placeIntervalMs || game._placeIntervalMs;

                // reset åå›åˆ°é«˜ç‰¹æ•ˆ
                try { game._setQuality && game._setQuality('high'); } catch { }
                if (game._perf) { game._perf.lowForMs = 0; game._perf.highForMs = 0; }

                // resize è®© DPR ç«‹å³ç”Ÿæ•ˆ
                if (game.renderer) game.renderer.resize();
                if (game.audio) game.audio.setVolume(game.settings.sfxVolume);
                Toast.show('â†© å·²æ¢å¤é»˜è®¤');
            });
            if (settingsClear) settingsClear.addEventListener('click', () => {
                game.audio && game.audio.play('ui');
                if (confirm('ç¡®å®šåˆ é™¤å­˜æ¡£å—ï¼Ÿ')) {
                    SaveSystem.clear();
                    Toast.show('ğŸ—‘ å·²åˆ é™¤å­˜æ¡£');
                }
            });

            if (settingsApply) settingsApply.addEventListener('click', () => {
                game.audio && game.audio.play('ui');
                const prevAuto = !!(game.settings && game.settings.autoQuality);
                const s = readSettingsControls(game.settings);
                game.settings = GameSettings.applyToDocument(s);
                if (game.quality && typeof game.quality.onSettingsChanged === 'function') game.quality.onSettingsChanged();
                GameSettings.save(game.settings);

                // ä½“éªŒå‚æ•°å³æ—¶ç”Ÿæ•ˆ
                game._placeIntervalMs = game.settings.placeIntervalMs || game._placeIntervalMs;

                // è‡ªåŠ¨æ€§èƒ½è°ƒèŠ‚ï¼šå¦‚æœç”¨æˆ·å…³é—­ï¼Œåˆ™ç«‹å³æ¢å¤é«˜ç‰¹æ•ˆå¹¶åœæ­¢è‡ªåŠ¨åˆ‡æ¡£
                if (prevAuto && game.settings.autoQuality === false) {
                    try { game._setQuality && game._setQuality('high'); } catch { }
                    if (game._perf) { game._perf.lowForMs = 0; game._perf.highForMs = 0; }
                }

                if (game.audio) game.audio.setVolume(game.settings.sfxVolume);
                if (game.renderer) game.renderer.resize(); // DPR ç«‹å³ç”Ÿæ•ˆ
                Toast.show('âœ… å·²åº”ç”¨è®¾ç½®');
                hideOverlay(settingsOverlay);
                if (game._settingsReturnToPause) {
                    showOverlay(pauseOverlay);
                    game.paused = true;
                } else {
                    game.paused = false;
                    hideOverlay(pauseOverlay);
                }
            });

            // è®¾ç½®é¢æ¿ï¼šæ»‘å—å®æ—¶æ˜¾ç¤ºæ•°å€¼
            const $ = (id) => document.getElementById(id);
            const bindRange = (rangeId, valId, fmt) => {
                const r = $(rangeId);
                const v = $(valId);
                if (!r || !v) return;
                const update = () => { v.textContent = fmt(r.value); };
                r.addEventListener('input', update, { passive: true });
                r.addEventListener('change', update, { passive: true });
                update();
            };
            bindRange('opt-joy', 'val-joy', (x) => x + 'px');
            bindRange('opt-btn', 'val-btn', (x) => x + 'px');
            bindRange('opt-sfx', 'val-sfx', (x) => x + '%');
            bindRange('opt-camsmooth', 'val-camsmooth', (x) => (Number(x) / 100).toFixed(2));
            bindRange('opt-lookahead', 'val-lookahead', (x) => (Number(x) / 100).toFixed(2) + 'x');
            bindRange('opt-placeinterval', 'val-placeinterval', (x) => x + 'ms');

            // å¸®åŠ©é¢æ¿æŒ‰é’® + é¦–æ¬¡è¿›å…¥è‡ªåŠ¨å¼¹å‡º
            const helpClose = document.getElementById('help-close');
            const helpOk = document.getElementById('help-ok');
            const helpDont = document.getElementById('help-dontshow');
            const markHelpSeen = () => { try { localStorage.setItem('terraria_ultra_help_seen_v1', '1'); } catch { } };

            const closeHelp = () => { game.audio && game.audio.play('ui'); hideOverlay(helpOverlay); markHelpSeen(); };
            if (helpClose) helpClose.addEventListener('click', closeHelp);
            if (helpOk) helpOk.addEventListener('click', closeHelp);
            if (helpDont) helpDont.addEventListener('click', () => { markHelpSeen(); closeHelp(); });

            try {
                const seen = localStorage.getItem('terraria_ultra_help_seen_v1');
                if (!seen && helpOverlay) {
                    // ä¸æŠ¢å åŠ è½½æç¤ºï¼šå»¶è¿Ÿä¸€ç‚¹ç‚¹
                    setTimeout(() => {
                        try {
                            const savePrompt = document.getElementById('save-prompt-overlay');
                            if (savePrompt && savePrompt.classList.contains('show')) return;
                            showOverlay(helpOverlay);
                        } catch { }
                    }, 800);
                }
            } catch { }

            // é¡µé¢å¤±ç„¦/åˆ‡åå°ï¼šè‡ªåŠ¨ä¿å­˜ + è‡ªåŠ¨æš‚åœï¼ˆç§»åŠ¨ç«¯æ›´å‹å¥½ï¼‰
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    try { game.saveSystem.save('autosave'); } catch { }
                    try { if (game._stopRafForHidden) game._stopRafForHidden(); } catch { }
                    game.paused = true;
                    if (pauseOverlay) showOverlay(pauseOverlay);
                } else {
                    // å›åˆ°å‰å°ï¼šä»…æ¢å¤ RAFï¼ˆä»ä¿æŒæš‚åœï¼Œé¿å…è¯¯æ“ä½œï¼‰
                    try { if (game._resumeRafIfNeeded) game._resumeRafIfNeeded(); } catch { }
                }
            }, { passive: true });

            window.addEventListener('beforeunload', () => {
                try { game.saveSystem.save('autosave'); } catch { }
            });

            // ç‚¹å‡»ç©ºç™½é®ç½©å…³é—­ï¼ˆæš‚åœ/è®¾ç½®/å¸®åŠ©ï¼‰ï¼Œä½“éªŒæ›´åƒâ€œHUDé¢æ¿â€
            const _bindBackdropClose = (overlayEl, onClose) => {
                if (!overlayEl) return;
                // é˜²é‡å¤ç»‘å®šï¼šé¿å…é‡å¤ç›‘å¬å¯¼è‡´å¤šæ¬¡è§¦å‘
                if (overlayEl.__tuBackdropBound) return;
                overlayEl.__tuBackdropBound = true;
                // pointerdownï¼šæ¯” click æ›´åŠæ—¶ï¼›passive:false å…è®¸ preventDefault
                overlayEl.addEventListener('pointerdown', (e) => {
                    if (e.target !== overlayEl) return;
                    e.preventDefault();
                    e.stopPropagation();
                    try { onClose && onClose(); } catch { }
                }, { passive: false });
            };

            // æ³¨æ„ï¼špauseOverlay çš„å…³é—­é€»è¾‘å°±æ˜¯â€œç»§ç»­æ¸¸æˆâ€
            _bindBackdropClose(pauseOverlay, () => {
                if (!game.paused) return;
                game.audio && game.audio.play('ui');
                game.paused = false;
                hideOverlay(pauseOverlay);
            });

            _bindBackdropClose(helpOverlay, () => {
                if (!helpOverlay || !helpOverlay.classList.contains('show')) return;
                game.audio && game.audio.play('ui');
                hideOverlay(helpOverlay);
                try { localStorage.setItem('terraria_ultra_help_seen_v1', '1'); } catch { }
            });

            _bindBackdropClose(settingsOverlay, () => {
                if (!settingsOverlay || !settingsOverlay.classList.contains('show')) return;
                game.audio && game.audio.play('ui');
                if (game._ux && typeof game._ux.closeSettings === 'function') game._ux.closeSettings();
                else hideOverlay(settingsOverlay);
            });
        }

        function syncSettingsControls(settings) {
            const s = GameSettings.sanitize(settings);
            const $ = (id) => document.getElementById(id);

            const dpr = $('opt-dpr'); if (dpr) dpr.value = String(s.dprCap);
            const p = $('opt-particles'); if (p) p.value = s.particles ? '1' : '0';
            const a = $('opt-ambient'); if (a) a.value = s.ambient ? '1' : '0';
            const m = $('opt-minimap'); if (m) m.value = s.minimap ? '1' : '0';
            const bm = $('opt-bgmountains'); if (bm) bm.value = s.bgMountains ? '1' : '0';
            const fx = $('opt-postfx'); if (fx) fx.value = String(s.postFxMode);

            const aim = $('opt-aimassist'); if (aim) aim.value = s.aimAssist ? '1' : '0';
            const vib = $('opt-vibration'); if (vib) vib.value = s.vibration ? '1' : '0';
            const aq = $('opt-autoquality'); if (aq) aq.value = s.autoQuality ? '1' : '0';
            const sf = $('opt-showfps'); if (sf) sf.value = s.showFps ? '1' : '0';

            const cam = $('opt-camsmooth'); if (cam) cam.value = String(Math.round(s.cameraSmooth * 100));
            const look = $('opt-lookahead'); if (look) look.value = String(Math.round(s.lookAhead * 100));
            const pi = $('opt-placeinterval'); if (pi) pi.value = String(Math.round(s.placeIntervalMs));

            const joy = $('opt-joy'); if (joy) joy.value = String(s.joystickSize);
            const btn = $('opt-btn'); if (btn) btn.value = String(s.buttonSize);
            const sfx = $('opt-sfx'); if (sfx) sfx.value = String(Math.round(s.sfxVolume * 100));
            const rm = $('opt-reduce-motion'); if (rm) rm.value = s.reducedMotion ? '1' : '0';

            // æ›´æ–°æ•°å€¼æ ‡ç­¾ï¼ˆæ‰“å¼€è®¾ç½®æ—¶ç«‹å³åŒæ­¥ï¼‰
            const setVal = (id, text) => { const el = $(id); if (el) el.textContent = text; };
            if (joy) setVal('val-joy', joy.value + 'px');
            if (btn) setVal('val-btn', btn.value + 'px');
            if (sfx) setVal('val-sfx', sfx.value + '%');
            if (cam) setVal('val-camsmooth', (Number(cam.value) / 100).toFixed(2));
            if (look) setVal('val-lookahead', (Number(look.value) / 100).toFixed(2) + 'x');
            if (pi) setVal('val-placeinterval', pi.value + 'ms');
        }

        function readSettingsControls(current) {
            const base = GameSettings.sanitize(current);
            const $ = (id) => document.getElementById(id);
            const num = (el, fallback) => el ? parseFloat(el.value) : fallback;

            return Object.assign({}, base, {
                dprCap: num($('opt-dpr'), base.dprCap),
                particles: ($('opt-particles') ? $('opt-particles').value === '1' : base.particles),
                ambient: ($('opt-ambient') ? $('opt-ambient').value === '1' : base.ambient),
                minimap: ($('opt-minimap') ? $('opt-minimap').value === '1' : base.minimap),
                bgMountains: ($('opt-bgmountains') ? $('opt-bgmountains').value === '1' : base.bgMountains),

                postFxMode: num($('opt-postfx'), base.postFxMode),

                aimAssist: ($('opt-aimassist') ? $('opt-aimassist').value === '1' : base.aimAssist),
                vibration: ($('opt-vibration') ? $('opt-vibration').value === '1' : base.vibration),
                autoQuality: ($('opt-autoquality') ? $('opt-autoquality').value === '1' : base.autoQuality),
                showFps: ($('opt-showfps') ? $('opt-showfps').value === '1' : base.showFps),

                cameraSmooth: num($('opt-camsmooth'), base.cameraSmooth * 100) / 100,
                lookAhead: num($('opt-lookahead'), base.lookAhead * 100) / 100,
                placeIntervalMs: num($('opt-placeinterval'), base.placeIntervalMs),

                joystickSize: num($('opt-joy'), base.joystickSize),
                buttonSize: num($('opt-btn'), base.buttonSize),
                sfxVolume: num($('opt-sfx'), base.sfxVolume * 100) / 100,
                reducedMotion: ($('opt-reduce-motion') ? $('opt-reduce-motion').value === '1' : base.reducedMotion),
            });
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { applyInfoHintText, wireUXUI, syncSettingsControls, readSettingsControls });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 9: World Generation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class NoiseGenerator {
            constructor(seed = Math.random() * 10000) {
                this.seed = seed;
                this.p = this._initPermutation();
            }

            _initPermutation() {
                const p = Array.from({ length: 256 }, (_, i) => i);
                let s = this.seed;
                for (let i = 255; i > 0; i--) {
                    s = (s * 16807) % 2147483647;
                    const j = s % (i + 1);
                    [p[i], p[j]] = [p[j], p[i]];
                }
                return [...p, ...p];
            }

            _fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            _lerp(a, b, t) { return a + t * (b - a); }
            _grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x); y -= Math.floor(y);
                const u = this._fade(x), v = this._fade(y);
                const A = this.p[X] + Y, B = this.p[X + 1] + Y;
                return this._lerp(
                    this._lerp(this._grad(this.p[A], x, y), this._grad(this.p[B], x - 1, y), u),
                    this._lerp(this._grad(this.p[A + 1], x, y - 1), this._grad(this.p[B + 1], x - 1, y - 1), u), v
                );
            }

            fbm(x, y, octaves = 5, lac = 2, gain = 0.5) {
                let val = 0, amp = 1, freq = 1, max = 0;
                for (let i = 0; i < octaves; i++) {
                    val += amp * this.noise2D(x * freq, y * freq);
                    max += amp;
                    amp *= gain;
                    freq *= lac;
                }
                return val / max;
            }

            warpedNoise(x, y, strength = 0.5) {
                const wx = this.fbm(x + 100, y + 100, 3) * strength;
                const wy = this.fbm(x + 200, y + 200, 3) * strength;
                return this.fbm(x + wx, y + wy, 4);
            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { NoiseGenerator });

        class TextureGenerator {
            constructor() {
                this.cache = []; // Array cache: blockId -> canvas|nullï¼Œæ¯” Map æ›´å¿«
                this.glowCache = []; // å‘å…‰è´´å›¾ç¼“å­˜ï¼šblockId -> canvas|null
                // é¢„å®šä¹‰è°ƒè‰²æ¿
                this.palette = {
                    dirt: ['#5d4037', '#4e342e', '#3e2723', '#795548'],
                    grass: ['#4caf50', '#388e3c', '#2e7d32', '#81c784'],
                    stone: ['#9e9e9e', '#757575', '#616161', '#424242'],
                    wood: ['#8d6e63', '#6d4c41', '#5d4037', '#4e342e'],
                    sand: ['#fff176', '#fdd835', '#fbc02d', '#f9a825']
                };
            }

            get(blockId) {
                // Array ç´¢å¼•æ¯” Map.has/get æ›´å¿«ï¼›ç”¨ undefined ä½œä¸ºâ€œæœªç¼“å­˜â€å“¨å…µ
                const cached = this.cache[blockId];
                if (cached !== undefined) return cached;

                const data = BLOCK_DATA[blockId];
                if (!data?.color) {
                    this.cache[blockId] = null;
                    return null;
                }

                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = CONFIG.TILE_SIZE;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                // ç¦ç”¨å¹³æ»‘ä»¥è·å¾—æ¸…è„†çš„åƒç´ æ„Ÿ
                ctx.imageSmoothingEnabled = false;

                this._drawPixelArt(ctx, blockId, data);
                this.cache[blockId] = canvas;
                return canvas;
            }

            getGlow(blockId) {
                // ä»…å¯¹å‘å…‰æ–¹å—ç”Ÿæˆâ€œé¢„çƒ˜ç„™è¾‰å…‰è´´å›¾â€ï¼Œé¿å…æ¯æ ¼ ctx.save/shadowBlur çš„é«˜å¼€é”€
                const cached = this.glowCache[blockId];
                if (cached !== undefined) return cached;

                const base = this.get(blockId);
                if (!base) {
                    this.glowCache[blockId] = null;
                    return null;
                }

                // BLOCK_LIGHT / BLOCK_COLOR åœ¨åç»­å¸¸é‡åŒºå®šä¹‰ï¼›æ–¹æ³•æ‰§è¡Œæ—¶å·²å°±ç»ªå³å¯
                const bl = (typeof BLOCK_LIGHT !== 'undefined' && BLOCK_LIGHT[blockId]) ? BLOCK_LIGHT[blockId] : 0;
                if (bl <= 5) {
                    this.glowCache[blockId] = null;
                    return null;
                }

                const pad = Math.max(2, Math.min(24, Math.ceil(bl * 1.6)));
                const size = CONFIG.TILE_SIZE + pad * 2;

                const glow = document.createElement('canvas');
                glow.width = glow.height = size;
                const gctx = glow.getContext('2d', { alpha: true });
                gctx.imageSmoothingEnabled = false;

                gctx.clearRect(0, 0, size, size);
                gctx.save();
                gctx.shadowColor = (typeof BLOCK_COLOR !== 'undefined' && BLOCK_COLOR[blockId]) ? BLOCK_COLOR[blockId] : (BLOCK_DATA[blockId]?.color || '#ffffff');
                gctx.shadowBlur = bl * 2;
                gctx.drawImage(base, pad, pad);
                gctx.restore();

                // ç»™æ¸²æŸ“ç«¯ä¸€ä¸ª pad ä¿¡æ¯ï¼ˆç”¨äºç»˜åˆ¶æ—¶å›é€€åç§»ï¼‰
                glow.__pad = pad;

                this.glowCache[blockId] = glow;
                return glow;
            }

            _drawPixel(ctx, x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, 1, 1);
            }

            // ä½¿ç”¨åƒç´ çŸ©é˜µç»˜åˆ¶
            _drawMatrix(ctx, matrix, colors) {
                for (let y = 0; y < 16; y++) {
                    for (let x = 0; x < 16; x++) {
                        const char = matrix[y] ? matrix[y][x] : '.';
                        if (colors[char]) {
                            this._drawPixel(ctx, x, y, colors[char]);
                        }
                    }
                }
            }

            _drawPixelArt(ctx, id, data) {
                const s = CONFIG.TILE_SIZE;
                const p = this.palette;

                // åŸºç¡€åº•è‰²å¡«å……
                const baseColor = data.color || '#F0F';

                // ç”Ÿæˆéšæœºåƒç´ çº¹ç†çš„è¾…åŠ©å‡½æ•°
                const fillNoise = (colors, density = 0.3) => {
                    for (let x = 0; x < s; x++) {
                        for (let y = 0; y < s; y++) {
                            if (Math.random() < density) {
                                const c = colors[Math.floor(Math.random() * colors.length)];
                                this._drawPixel(ctx, x, y, c);
                            }
                        }
                    }
                };

                switch (id) {
                    case BLOCK.DIRT:
                        // åœŸå—ï¼šæ·±æµ…ä¸ä¸€çš„å™ªç‚¹
                        ctx.fillStyle = p.dirt[0]; ctx.fillRect(0, 0, s, s);
                        fillNoise(p.dirt, 0.5);
                        break;

                    case BLOCK.GRASS:
                    case BLOCK.SNOW_GRASS:
                    case BLOCK.JUNGLE_GRASS:
                        // ä¾§é¢è‰æ–¹å—ï¼šé¡¶éƒ¨æ˜¯è‰ï¼Œä¸‹é¢æ˜¯åœŸ
                        const isSnow = id === BLOCK.SNOW_GRASS;
                        const topColors = isSnow ? ['#fff', '#eee', '#ddd'] :
                            (id === BLOCK.JUNGLE_GRASS ? ['#66bb6a', '#43a047', '#2e7d32'] : p.grass);
                        const soilColors = id === BLOCK.JUNGLE_GRASS ? ['#5d4037', '#4e342e'] : p.dirt;

                        // åœŸå£¤éƒ¨åˆ†
                        ctx.fillStyle = soilColors[0]; ctx.fillRect(0, 0, s, s);
                        fillNoise(soilColors, 0.4);

                        // è‰é¡¶ (3-5åƒç´ åš)
                        ctx.fillStyle = topColors[1];
                        ctx.fillRect(0, 0, s, 4);

                        // è‰çš„è¾¹ç¼˜ï¼ˆå‚ä¸‹çš„åƒç´ ï¼‰
                        for (let x = 0; x < s; x++) {
                            const drop = Math.floor(Math.random() * 3) + 1;
                            ctx.fillStyle = topColors[Math.floor(Math.random() * topColors.length)];
                            ctx.fillRect(x, 0, 1, 4 + drop);
                            // å¶å°”çš„é«˜å…‰
                            if (Math.random() > 0.8) {
                                ctx.fillStyle = topColors[0];
                                ctx.fillRect(x, 1, 1, 1);
                            }
                        }
                        break;

                    case BLOCK.STONE:
                    case BLOCK.COBBLESTONE:
                    case BLOCK.MOSSY_STONE:
                    case BLOCK.GRANITE:
                    case BLOCK.MARBLE:
                        // çŸ³å¤´çº¹ç†ï¼šä¸è§„åˆ™çš„å±‚çŠ¶æˆ–å—çŠ¶
                        const stoneBase = id === BLOCK.GRANITE ? '#4e342e' : (id === BLOCK.MARBLE ? '#f5f5f5' : '#757575');
                        const stoneDark = id === BLOCK.GRANITE ? '#3e2723' : (id === BLOCK.MARBLE ? '#e0e0e0' : '#616161');

                        ctx.fillStyle = stoneBase; ctx.fillRect(0, 0, s, s);

                        if (id === BLOCK.COBBLESTONE) {
                            // åœ†çŸ³ï¼šç”»å‡ ä¸ªåœ†åœˆè½®å»“
                            ctx.fillStyle = '#00000033'; // é˜´å½±ç¼éš™
                            ctx.fillRect(2, 1, 10, 1); ctx.fillRect(1, 2, 1, 4); ctx.fillRect(12, 2, 1, 4); ctx.fillRect(2, 6, 10, 1);
                            ctx.fillRect(0, 8, 6, 1); ctx.fillRect(5, 9, 1, 4); ctx.fillRect(0, 13, 6, 1);
                            ctx.fillRect(7, 8, 9, 1); ctx.fillRect(7, 9, 1, 5); ctx.fillRect(15, 9, 1, 5);
                        } else {
                            // å¤©ç„¶çŸ³ï¼šæ¨ªå‘è£‚çº¹
                            for (let i = 0; i < 8; i++) {
                                const sx = Math.floor(Math.random() * s);
                                const sy = Math.floor(Math.random() * s);
                                const len = Math.floor(Math.random() * 5) + 2;
                                ctx.fillStyle = stoneDark;
                                ctx.fillRect(sx, sy, len, 1);
                            }
                            fillNoise([stoneBase, stoneDark], 0.2);
                        }

                        if (id === BLOCK.MOSSY_STONE) {
                            fillNoise(p.grass, 0.2); // è‹”è—“æ–‘ç‚¹
                        }
                        break;

                    case BLOCK.WOOD:
                    case BLOCK.LOG:
                        // åŸæœ¨ï¼šæ ‘çš®çº¹ç†ï¼ˆå‚ç›´ï¼‰
                        ctx.fillStyle = '#5d4037'; ctx.fillRect(0, 0, s, s);
                        for (let x = 1; x < s; x += 2) {
                            ctx.fillStyle = Math.random() > 0.5 ? '#4e342e' : '#3e2723';
                            ctx.fillRect(x, 0, 1, s);
                            if (Math.random() > 0.7) ctx.fillRect(x + 1, Math.random() * s, 1, 2); // æ ‘èŠ‚
                        }
                        break;

                    case BLOCK.PLANKS:
                        // æœ¨æ¿ï¼šæ°´å¹³æ¡çº¹
                        ctx.fillStyle = '#8d6e63'; ctx.fillRect(0, 0, s, s);
                        // åˆ†éš”çº¿
                        ctx.fillStyle = '#4e342e';
                        ctx.fillRect(0, 4, s, 1);
                        ctx.fillRect(0, 9, s, 1);
                        ctx.fillRect(0, 14, s, 1);
                        // éšæœºå™ªç‚¹æ¨¡æ‹Ÿæœ¨çº¹
                        fillNoise(['#795548', '#a1887f'], 0.1);
                        break;

                    case BLOCK.BRICK:
                        // ç –å—ï¼šäº¤é”™æ’åˆ—
                        ctx.fillStyle = '#8d6e63'; ctx.fillRect(0, 0, s, s); // ç°ç¼
                        const bCol = '#d32f2f';
                        const bLit = '#ef5350';
                        const bDrk = '#b71c1c';

                        const drawOneBrick = (x, y, w, h) => {
                            ctx.fillStyle = bCol; ctx.fillRect(x, y, w, h);
                            ctx.fillStyle = bLit; ctx.fillRect(x, y, w - 1, 1); ctx.fillRect(x, y, 1, h - 1);
                            ctx.fillStyle = bDrk; ctx.fillRect(x + w - 1, y, 1, h); ctx.fillRect(x, y + h - 1, w, 1);
                        };

                        drawOneBrick(0, 0, 7, 7);
                        drawOneBrick(8, 0, 8, 7);
                        drawOneBrick(0, 8, 3, 7);
                        drawOneBrick(4, 8, 8, 7);
                        drawOneBrick(13, 8, 3, 7);
                        break;

                    case BLOCK.LEAVES:
                        // æ ‘å¶ï¼šé€šé€çš„åƒç´ ç‚¹ç°‡
                        // ä¸æ¸…é™¤èƒŒæ™¯ï¼Œè®©å®ƒé€æ˜
                        const leafColors = ['#2e7d32', '#388e3c', '#43a047'];
                        for (let x = 0; x < s; x += 2) {
                            for (let y = 0; y < s; y += 2) {
                                if (Math.random() > 0.3) {
                                    ctx.fillStyle = leafColors[Math.floor(Math.random() * leafColors.length)];
                                    ctx.fillRect(x, y, 2, 2);
                                    // é˜´å½±
                                    if (Math.random() > 0.5) {
                                        ctx.fillStyle = '#1b5e20';
                                        ctx.fillRect(x + 1, y + 1, 1, 1);
                                    }
                                }
                            }
                        }
                        break;

                    case BLOCK.GLASS:
                        // ç»ç’ƒï¼šè¾¹æ¡† + åå…‰
                        ctx.fillStyle = 'rgba(225, 245, 254, 0.2)'; ctx.fillRect(1, 1, 14, 14);
                        ctx.strokeStyle = '#81d4fa'; ctx.lineWidth = 1; ctx.strokeRect(0.5, 0.5, 15, 15);
                        // åå…‰æ¡
                        ctx.fillStyle = 'rgba(255,255,255,0.6)';
                        ctx.fillRect(3, 3, 2, 2);
                        ctx.fillRect(5, 5, 2, 2);
                        ctx.fillRect(10, 10, 3, 3);
                        break;

                    case BLOCK.ORE_COPPER:
                    case BLOCK.ORE_IRON:
                    case BLOCK.ORE_SILVER:
                    case BLOCK.ORE_GOLD:
                    case BLOCK.ORE_DIAMOND:
                    case BLOCK.COPPER_ORE: case BLOCK.IRON_ORE: case BLOCK.SILVER_ORE:
                    case BLOCK.GOLD_ORE: case BLOCK.DIAMOND_ORE:
                        // çŸ¿çŸ³ï¼šçŸ³å¤´èƒŒæ™¯ + å®çŸ³é•¶åµŒ
                        this._drawPixelArt(ctx, BLOCK.STONE, BLOCK_DATA[BLOCK.STONE]);

                        let oreC = '#FFF';
                        if (id === BLOCK.COPPER_ORE) oreC = '#e67e22';
                        if (id === BLOCK.IRON_ORE) oreC = '#d7ccc8';
                        if (id === BLOCK.SILVER_ORE) oreC = '#e0e0e0';
                        if (id === BLOCK.GOLD_ORE) oreC = '#ffd700';
                        if (id === BLOCK.DIAMOND_ORE) oreC = '#29b6f6';
                        if (data.color) oreC = data.color;

                        for (let i = 0; i < 4; i++) {
                            const ox = Math.floor(Math.random() * 12) + 2;
                            const oy = Math.floor(Math.random() * 12) + 2;
                            // çŸ¿çŸ³å½¢çŠ¶
                            ctx.fillStyle = oreC;
                            ctx.fillRect(ox, oy, 2, 2);
                            ctx.fillRect(ox - 1, oy, 1, 1);
                            ctx.fillRect(ox, oy - 1, 1, 1);
                            // é«˜å…‰
                            ctx.fillStyle = '#ffffffaa';
                            ctx.fillRect(ox, oy, 1, 1);
                        }
                        break;

                    case BLOCK.TORCH:
                        // ç«æŠŠ
                        ctx.fillStyle = '#5d4037'; ctx.fillRect(7, 6, 2, 10); // æŸ„
                        // ç«ç„°ä¸­å¿ƒ
                        ctx.fillStyle = '#ffeb3b'; ctx.fillRect(6, 4, 4, 4);
                        ctx.fillStyle = '#fff'; ctx.fillRect(7, 5, 2, 2);
                        // å¤–ç„°
                        ctx.fillStyle = '#ff5722';
                        ctx.fillRect(7, 2, 2, 2);
                        ctx.fillRect(6, 4, 1, 1); ctx.fillRect(9, 4, 1, 1);
                        break;

                    case BLOCK.SAND:
                        ctx.fillStyle = '#fff59d'; ctx.fillRect(0, 0, s, s);
                        // æ³¢æµªçº¹ç†
                        ctx.fillStyle = '#fdd835';
                        for (let y = 2; y < s; y += 4) {
                            for (let x = 0; x < s; x++) {
                                if ((x + y) % 4 === 0) ctx.fillRect(x, y, 1, 1);
                            }
                        }
                        fillNoise(['#fbc02d'], 0.1);
                        break;

                    case BLOCK.MUSHROOM:
                        // è˜‘è‡
                        ctx.fillStyle = '#fff'; ctx.fillRect(7, 10, 2, 6); // èŒ
                        // ä¼ç›–
                        ctx.fillStyle = '#e91e63';
                        ctx.fillRect(4, 7, 8, 3);
                        ctx.fillRect(5, 6, 6, 1);
                        // æ–‘ç‚¹
                        ctx.fillStyle = '#f8bbd0';
                        ctx.fillRect(5, 8, 1, 1); ctx.fillRect(9, 7, 1, 1);
                        break;

                    case BLOCK.FLOWER_RED:
                    case BLOCK.FLOWER_YELLOW:
                    case BLOCK.PINK_FLOWER:
                    case BLOCK.BLUE_FLOWER:
                        const stemC = '#4caf50';
                        ctx.fillStyle = stemC; ctx.fillRect(7, 8, 2, 8); // èŒ
                        // å¶
                        ctx.fillRect(5, 12, 2, 1); ctx.fillRect(9, 11, 2, 1);
                        // èŠ±ç“£
                        let petalC = '#f44336';
                        if (id === BLOCK.FLOWER_YELLOW) petalC = '#ffeb3b';
                        if (id === BLOCK.PINK_FLOWER) petalC = '#f48fb1';
                        if (id === BLOCK.BLUE_FLOWER) petalC = '#64b5f6';
                        ctx.fillStyle = petalC;
                        ctx.fillRect(6, 6, 4, 4);
                        ctx.fillRect(7, 5, 2, 6);
                        ctx.fillRect(5, 7, 6, 2);
                        // èŠ±è•Š
                        ctx.fillStyle = '#fff'; ctx.fillRect(7, 7, 2, 2);
                        break;

                    case BLOCK.SUNFLOWER:
                        ctx.fillStyle = '#4caf50'; ctx.fillRect(7, 6, 2, 10); // èŒ
                        ctx.fillRect(5, 10, 2, 1); ctx.fillRect(9, 9, 2, 1);
                        // èŠ±ç“£ - å‘æ—¥è‘µ
                        ctx.fillStyle = '#ffeb3b';
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const px = 8 + Math.cos(angle) * 4;
                            const py = 4 + Math.sin(angle) * 4;
                            ctx.fillRect(Math.floor(px) - 1, Math.floor(py) - 1, 3, 3);
                        }
                        ctx.fillStyle = '#8d6e63'; ctx.fillRect(6, 2, 4, 4); // ä¸­å¿ƒ
                        break;

                    case BLOCK.FERN:
                        ctx.fillStyle = '#2e7d32';
                        ctx.fillRect(7, 6, 2, 10);
                        // è•¨ç±»å¶ç‰‡
                        for (let i = 0; i < 5; i++) {
                            const y = 6 + i * 2;
                            ctx.fillRect(4, y, 3, 1);
                            ctx.fillRect(9, y + 1, 3, 1);
                        }
                        break;

                    case BLOCK.VINE:
                        ctx.fillStyle = '#388e3c';
                        ctx.fillRect(7, 0, 2, 16);
                        ctx.fillRect(5, 3, 2, 1);
                        ctx.fillRect(9, 6, 2, 1);
                        ctx.fillRect(4, 10, 2, 1);
                        ctx.fillRect(10, 13, 2, 1);
                        break;

                    case BLOCK.BAMBOO:
                        ctx.fillStyle = '#7cb342'; ctx.fillRect(6, 0, 4, 16);
                        ctx.fillStyle = '#689f38';
                        ctx.fillRect(6, 3, 4, 1);
                        ctx.fillRect(6, 8, 4, 1);
                        ctx.fillRect(6, 13, 4, 1);
                        ctx.fillStyle = '#8bc34a';
                        ctx.fillRect(7, 0, 2, 16);
                        break;

                    case BLOCK.CHERRY_LEAVES:
                        const cherryColors = ['#f48fb1', '#f8bbd9', '#fce4ec', '#ec407a'];
                        for (let x = 0; x < s; x += 2) {
                            for (let y = 0; y < s; y += 2) {
                                if (Math.random() > 0.25) {
                                    ctx.fillStyle = cherryColors[Math.floor(Math.random() * cherryColors.length)];
                                    ctx.fillRect(x, y, 2, 2);
                                }
                            }
                        }
                        break;

                    case BLOCK.PINE_LEAVES:
                        const pineColors = ['#1b5e20', '#2e7d32', '#388e3c'];
                        for (let x = 0; x < s; x++) {
                            for (let y = 0; y < s; y++) {
                                if (Math.random() > 0.2) {
                                    ctx.fillStyle = pineColors[Math.floor(Math.random() * pineColors.length)];
                                    ctx.fillRect(x, y, 1, 1);
                                }
                            }
                        }
                        break;

                    case BLOCK.PALM_LEAVES:
                        const palmColors = ['#7cb342', '#8bc34a', '#9ccc65'];
                        for (let x = 0; x < s; x += 2) {
                            for (let y = 0; y < s; y += 2) {
                                if (Math.random() > 0.3) {
                                    ctx.fillStyle = palmColors[Math.floor(Math.random() * palmColors.length)];
                                    ctx.fillRect(x, y, 2, 2);
                                }
                            }
                        }
                        break;

                    case BLOCK.SANDSTONE:
                        ctx.fillStyle = '#d4a574'; ctx.fillRect(0, 0, s, s);
                        ctx.fillStyle = '#c9956c';
                        ctx.fillRect(0, 4, s, 1);
                        ctx.fillRect(0, 10, s, 1);
                        fillNoise(['#deb887', '#c9956c'], 0.2);
                        break;

                    case BLOCK.RED_SAND:
                        ctx.fillStyle = '#c75b39'; ctx.fillRect(0, 0, s, s);
                        fillNoise(['#b74a2a', '#d96c4a'], 0.4);
                        break;

                    case BLOCK.GRAVEL:
                        ctx.fillStyle = '#757575'; ctx.fillRect(0, 0, s, s);
                        for (let i = 0; i < 20; i++) {
                            const gx = Math.floor(Math.random() * 14) + 1;
                            const gy = Math.floor(Math.random() * 14) + 1;
                            ctx.fillStyle = Math.random() > 0.5 ? '#616161' : '#9e9e9e';
                            ctx.fillRect(gx, gy, 2, 2);
                        }
                        break;

                    case BLOCK.LIMESTONE:
                        ctx.fillStyle = '#e8dcc4'; ctx.fillRect(0, 0, s, s);
                        fillNoise(['#d7c9a8', '#f5f0e0'], 0.25);
                        break;

                    case BLOCK.SLATE:
                        ctx.fillStyle = '#546e7a'; ctx.fillRect(0, 0, s, s);
                        for (let y = 2; y < s; y += 3) {
                            ctx.fillStyle = '#455a64';
                            ctx.fillRect(0, y, s, 1);
                        }
                        break;

                    case BLOCK.BASALT:
                        ctx.fillStyle = '#37474f'; ctx.fillRect(0, 0, s, s);
                        fillNoise(['#263238', '#455a64'], 0.3);
                        break;

                    case BLOCK.FROZEN_STONE:
                        ctx.fillStyle = '#b3e5fc'; ctx.fillRect(0, 0, s, s);
                        fillNoise(['#81d4fa', '#e1f5fe'], 0.3);
                        // å†°æ™¶æ•ˆæœ
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        ctx.fillRect(3, 3, 2, 2);
                        ctx.fillRect(10, 8, 2, 2);
                        break;

                    case BLOCK.GLOWSTONE:
                        ctx.fillStyle = '#ffc107'; ctx.fillRect(0, 0, s, s);
                        fillNoise(['#ffeb3b', '#ff9800', '#fff176'], 0.5);
                        // å‘å…‰æ•ˆæœ
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(4, 4, 2, 2);
                        ctx.fillRect(10, 10, 2, 2);
                        break;

                    case BLOCK.AMETHYST:
                        ctx.fillStyle = '#9c27b0'; ctx.fillRect(0, 0, s, s);
                        // æ™¶ä½“çº¹ç†
                        ctx.fillStyle = '#ba68c8';
                        ctx.fillRect(3, 2, 2, 6);
                        ctx.fillRect(8, 4, 3, 8);
                        ctx.fillStyle = '#e1bee7';
                        ctx.fillRect(4, 3, 1, 4);
                        ctx.fillRect(9, 5, 1, 6);
                        break;

                    case BLOCK.MUSHROOM_GIANT:
                        ctx.fillStyle = '#8e24aa'; ctx.fillRect(0, 0, s, s);
                        fillNoise(['#7b1fa2', '#9c27b0', '#ab47bc'], 0.4);
                        // æ–‘ç‚¹
                        ctx.fillStyle = '#e1bee7';
                        ctx.fillRect(3, 4, 2, 2);
                        ctx.fillRect(10, 8, 2, 2);
                        ctx.fillRect(6, 12, 2, 2);
                        break;

                    case BLOCK.UNDERGROUND_MUSHROOM:
                        ctx.fillStyle = '#7e57c2'; ctx.fillRect(7, 10, 2, 6);
                        ctx.fillStyle = '#5e35b1';
                        ctx.fillRect(4, 7, 8, 3);
                        ctx.fillRect(5, 6, 6, 1);
                        // å‘å…‰ç‚¹
                        ctx.fillStyle = '#b39ddb';
                        ctx.fillRect(5, 8, 1, 1);
                        ctx.fillRect(9, 7, 1, 1);
                        break;

                    case BLOCK.GLOWING_MOSS:
                        ctx.fillStyle = '#00e676';
                        for (let x = 0; x < s; x += 2) {
                            for (let y = 0; y < s; y += 2) {
                                if (Math.random() > 0.4) {
                                    ctx.fillStyle = Math.random() > 0.5 ? '#00e676' : '#69f0ae';
                                    ctx.fillRect(x, y, 2, 2);
                                }
                            }
                        }
                        break;

                    case BLOCK.STALAGMITE:
                    case BLOCK.STALACTITE:
                        const isUp = id === BLOCK.STALACTITE;
                        ctx.fillStyle = '#8d6e63';
                        if (isUp) {
                            ctx.fillRect(6, 0, 4, 8);
                            ctx.fillRect(7, 8, 2, 6);
                            ctx.fillRect(7, 14, 2, 2);
                        } else {
                            ctx.fillRect(7, 0, 2, 2);
                            ctx.fillRect(7, 2, 2, 6);
                            ctx.fillRect(6, 8, 4, 8);
                        }
                        break;

                    case BLOCK.SPIDER_WEB:
                        ctx.strokeStyle = '#eeeeee';
                        ctx.lineWidth = 1;
                        // æ”¾å°„çº¿
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.moveTo(8, 8);
                            ctx.lineTo(8 + Math.cos(angle) * 7, 8 + Math.sin(angle) * 7);
                            ctx.stroke();
                        }
                        // åŒå¿ƒç¯
                        for (let r = 2; r <= 6; r += 2) {
                            ctx.beginPath();
                            ctx.arc(8, 8, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;

                    case BLOCK.BONE:
                        ctx.fillStyle = '#efebe9'; ctx.fillRect(0, 0, s, s);
                        ctx.fillStyle = '#d7ccc8';
                        ctx.fillRect(2, 6, 12, 4);
                        ctx.fillRect(0, 5, 3, 6);
                        ctx.fillRect(13, 5, 3, 6);
                        break;

                    case BLOCK.TREASURE_CHEST:
                        ctx.fillStyle = '#8d6e63'; ctx.fillRect(2, 4, 12, 10);
                        ctx.fillStyle = '#5d4037';
                        ctx.fillRect(2, 4, 12, 2);
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(6, 8, 4, 3);
                        ctx.fillRect(7, 7, 2, 1);
                        break;

                    case BLOCK.LANTERN:
                        ctx.fillStyle = '#5d4037'; ctx.fillRect(6, 0, 4, 2);
                        ctx.fillStyle = '#ff9800'; ctx.fillRect(5, 2, 6, 8);
                        ctx.fillStyle = '#ffeb3b'; ctx.fillRect(6, 3, 4, 6);
                        ctx.fillStyle = '#fff'; ctx.fillRect(7, 4, 2, 4);
                        ctx.fillStyle = '#5d4037';
                        ctx.fillRect(5, 10, 6, 2);
                        ctx.fillRect(6, 12, 4, 2);
                        break;

                    case BLOCK.MOSS:
                        for (let x = 0; x < s; x++) {
                            for (let y = 0; y < s; y++) {
                                if (Math.random() > 0.5) {
                                    ctx.fillStyle = Math.random() > 0.5 ? '#558b2f' : '#689f38';
                                    ctx.fillRect(x, y, 1, 1);
                                }
                            }
                        }
                        break;

                    default:
                        // é»˜è®¤é™çº§å¤„ç†
                        ctx.fillStyle = baseColor;
                        ctx.fillRect(0, 0, s, s);
                        ctx.fillStyle = '#00000022';
                        ctx.strokeRect(0, 0, s, s);
                        fillNoise(['#ffffff33', '#00000033'], 0.2);
                }
            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { TextureGenerator });

const STRUCTURES_JSON = [
  {
    "id": "dungeon_room_basic",
    "tags": ["dungeon", "room"],
    "weight": 3,
    "depth": [0.62, 0.92],
    "anchor": [0.5, 0.5],
    "placement": { "mode": "underground", "minSolidRatio": 0.55, "defaultWall": 2 },
    "pattern": [
      "#############",
      "#...........#",
      "#..l.....l..#",
      "#...........#",
      "#.....C.....#",
      "#...........#",
      "#..l.....l..#",
      "#...........#",
      "#############"
    ],
    "legend": {
      "#": { "tile": "DUNGEON_BRICK", "replace": "any" },
      ".": { "tile": "AIR", "wall": 2, "replace": "any" },
      "l": { "tile": "LANTERN", "replace": "any" },
      "C": { "tile": "TREASURE_CHEST", "replace": "any" }
    },
    "connectors": [
      { "x": 0, "y": 4, "dir": "left", "len": 18, "carve": true, "wall": 2 },
      { "x": 12, "y": 4, "dir": "right", "len": 18, "carve": true, "wall": 2 }
    ]
  },
  {
    "id": "ruin_shrine",
    "tags": ["ruin", "room"],
    "weight": 2,
    "depth": [0.38, 0.74],
    "anchor": [0.5, 0.5],
    "placement": { "mode": "underground", "minSolidRatio": 0.45, "defaultWall": 1 },
    "pattern": [
      "  #######  ",
      " ##.....## ",
      "##..#.#..##",
      "#...#C#...#",
      "##..#.#..##",
      " ##.....## ",
      "  #######  "
    ],
    "legend": {
      "#": { "tile": "COBBLESTONE" },
      ".": { "tile": "AIR", "wall": 1 },
      "C": { "tile": "TREASURE_CHEST" }
    },
    "connectors": [
      { "x": 5, "y": 6, "dir": "down", "len": 10, "carve": true, "wall": 1 }
    ]
  },
  {
    "id": "ancient_tree",
    "tags": ["tree"],
    "weight": 2,
    "depth": [0.05, 0.35],
    "anchor": [0.5, 1.0],
    "placement": { "mode": "surface" },
    "pattern": [
      "   LLL   ",
      "  LLLLL  ",
      " LLLLLLL ",
      "  LLLLL  ",
      "   LLL   ",
      "    T    ",
      "    T    ",
      "    T    ",
      "    T    "
    ],
    "legend": {
      "L": { "tile": "LEAVES", "replace": "air" },
      "T": { "tile": "WOOD", "replace": "any" }
    }
  }
];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                ä¸–ç•Œç”Ÿæˆå™¨ (è¶…çº§å¢å¼ºç‰ˆ)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        (() => {
            const LS_KEY = 'TU_STRUCTURES_JSON';
            const LIMITS = Object.freeze({ MAX_W: 96, MAX_H: 96, MAX_CELLS: 4096, MAX_DESC: 256, MAX_CONN: 16 });

            const isObj = (v) => v && typeof v === 'object' && !Array.isArray(v);
            const clamp01 = (n) => (n < 0 ? 0 : (n > 1 ? 1 : n));
            const clampI = (n, lo, hi) => (n < lo ? lo : (n > hi ? hi : n)) | 0;
            const asNum = (v, d = 0) => (typeof v === 'number' && Number.isFinite(v) ? v : d);
            const asStr = (v, d = '') => (typeof v === 'string' ? v : d);

            function resolveBlockId(v) {
                if (typeof v === 'number' && Number.isFinite(v)) return clampI(v, 0, 255);
                if (typeof v === 'string') {
                    const k = v.trim();
                    if (!k || k === 'KEEP' || k === 'NULL' || k === 'null') return null;
                    if (typeof BLOCK === 'object' && k in BLOCK) return BLOCK[k];
                }
                return null;
            }
            function resolveWallId(v) {
                if (v === null || v === undefined) return null;
                if (typeof v === 'number' && Number.isFinite(v)) return clampI(v, 0, 255);
                if (typeof v === 'string') {
                    const s = v.trim();
                    if (!s) return null;
                    const n = Number(s);
                    if (Number.isFinite(n)) return clampI(n, 0, 255);
                }
                return null;
            }
            function dirVec(dir) {
                switch (dir) {
                    case 'left': return [-1, 0];
                    case 'right': return [1, 0];
                    case 'up': return [0, -1];
                    case 'down': return [0, 1];
                    default: return [0, 0];
                }
            }

            function normalizeDescriptor(raw, idx) {
                if (!isObj(raw)) return null;

                const id = asStr(raw.id, `desc_${idx}`).slice(0, 64);
                const tags = Array.isArray(raw.tags) ? raw.tags.map(t => asStr(t, '')).filter(Boolean).slice(0, 16) : [];
                const weight = Math.max(0.0001, asNum(raw.weight, 1));

                let depth = [0, 1];
                if (Array.isArray(raw.depth) && raw.depth.length >= 2) {
                    const a = clamp01(asNum(raw.depth[0], 0));
                    const b = clamp01(asNum(raw.depth[1], 1));
                    depth = a <= b ? [a, b] : [b, a];
                }

                const placement = isObj(raw.placement) ? raw.placement : {};
                const mode = placement.mode === 'surface' ? 'surface' : 'underground';
                const minSolidRatio = clamp01(asNum(placement.minSolidRatio, mode === 'underground' ? 0.5 : 0.0));
                const defaultWall = clampI(asNum(placement.defaultWall, 0), 0, 255);

                let anchor = [0.5, 0.5];
                if (Array.isArray(raw.anchor) && raw.anchor.length >= 2) {
                    anchor = [clamp01(asNum(raw.anchor[0], 0.5)), clamp01(asNum(raw.anchor[1], 0.5))];
                }

                const pat = Array.isArray(raw.pattern) ? raw.pattern.map(s => String(s).replace(/\r/g, '')) : [];
                if (!pat.length) return null;

                const h = pat.length;
                let w = 0;
                for (let i = 0; i < pat.length; i++) w = Math.max(w, pat[i].length);

                if (w <= 0 || h <= 0) return null;
                if (w > LIMITS.MAX_W || h > LIMITS.MAX_H) return null;
                if (w * h > LIMITS.MAX_CELLS) return null;

                const grid = pat.map(line => line.padEnd(w, ' '));

                const legendRaw = isObj(raw.legend) ? raw.legend : {};
                const legend = Object.create(null);
                for (const k in legendRaw) {
                    if (!k || k.length !== 1) continue;
                    const v = legendRaw[k];
                    if (!isObj(v)) continue;

                    const tile = resolveBlockId(v.tile);
                    const wall = resolveWallId(v.wall);
                    const replace = (v.replace === 'solid' || v.replace === 'air' || v.replace === 'any') ? v.replace : 'any';
                    const chance = clamp01(asNum(v.chance, 1));

                    // tile === null â†’ KEEPï¼ˆè·³è¿‡å†™å…¥ tileï¼‰
                    legend[k] = { tile, wall, replace, chance };
                }

                const connectors = [];
                if (Array.isArray(raw.connectors)) {
                    for (let i = 0; i < raw.connectors.length && connectors.length < LIMITS.MAX_CONN; i++) {
                        const c = raw.connectors[i];
                        if (!isObj(c)) continue;
                        const x = clampI(asNum(c.x, 0), 0, w - 1);
                        const y = clampI(asNum(c.y, 0), 0, h - 1);
                        const dir = asStr(c.dir, 'right');
                        const len = clampI(asNum(c.len, 10), 1, 64);
                        const carve = !!c.carve;
                        const wall = resolveWallId(c.wall);
                        connectors.push({ x, y, dir, len, carve, wall });
                    }
                }

                return { id, tags, weight, depth, placement: { mode, minSolidRatio, defaultWall }, anchor, w, h, grid, legend, connectors };
            }

            class StructureLibrary {
                constructor() {
                    this._descs = [];
                    this._loaded = false;
                    this._lastError = '';
                }
                count() { return this._descs.length; }
                lastError() { return this._lastError; }

                clear() {
                    this._descs.length = 0;
                    this._loaded = true;
                    this._lastError = '';
                }

                loadFromArray(arr, { replace = false } = {}) {
                    if (!Array.isArray(arr)) return { ok: false, added: 0, error: 'not_array' };
                    if (replace) this._descs.length = 0;

                    let added = 0;
                    for (let i = 0; i < arr.length && this._descs.length < LIMITS.MAX_DESC; i++) {
                        const desc = normalizeDescriptor(arr[i], i);
                        if (!desc) continue;
                        this._descs.push(desc);
                        added++;
                    }
                    this._loaded = true;
                    this._lastError = '';
                    return { ok: true, added };
                }

                loadFromJSON(json, { replace = false } = {}) {
                    try {
                        const arr = typeof json === 'string' ? JSON.parse(json) : json;
                        return this.loadFromArray(arr, { replace });
                    } catch (e) {
                        this._lastError = String(e && e.message ? e.message : e);
                        return { ok: false, added: 0, error: this._lastError };
                    }
                }

                ensureLoaded() {
                    if (this._loaded) return;

                    // 1) localStorage è¦†ç›–
                    const ls = (() => { try { return localStorage.getItem(LS_KEY); } catch { return null; } })();
                    if (ls) {
                        const r = this.loadFromJSON(ls, { replace: true });
                        if (r.ok && this._descs.length) { this._loaded = true; return; }
                    }

                    // 2) å†…åµŒ JSONï¼ˆé»˜è®¤åº“ï¼‰
                    const el = null;
                    if (el && el.textContent) {
                        const r = this.loadFromJSON(el.textContent, { replace: true });
                        if (r.ok) { this._loaded = true; return; }
                    }

                    // 3) å…œåº•ï¼šç©ºåº“
                    this._loaded = true;
                }

                // tags: string | string[]
                pick(depthNorm, tags) {
                    this.ensureLoaded();
                    if (!this._descs.length) return null;

                    const dn = clamp01(asNum(depthNorm, 0.5));
                    const tagList = Array.isArray(tags) ? tags : (tags ? [tags] : []);
                    const filtered = [];

                    for (let i = 0; i < this._descs.length; i++) {
                        const d = this._descs[i];
                        if (dn < d.depth[0] || dn > d.depth[1]) continue;
                        if (tagList.length) {
                            let ok = false;
                            for (let t = 0; t < tagList.length; t++) {
                                if (d.tags.includes(tagList[t])) { ok = true; break; }
                            }
                            if (!ok) continue;
                        }
                        filtered.push(d);
                    }
                    if (!filtered.length) return null;

                    let total = 0;
                    for (let i = 0; i < filtered.length; i++) total += filtered[i].weight;

                    let r = Math.random() * total;
                    for (let i = 0; i < filtered.length; i++) {
                        r -= filtered[i].weight;
                        if (r <= 0) return filtered[i];
                    }
                    return filtered[filtered.length - 1];
                }

                exportJSON() {
                    // ä»…å¯¼å‡ºå¯åºåˆ—åŒ–çš„â€œåŸå‹ä¿¡æ¯â€ï¼ˆpattern/grid ä¼šè¢«ä¿ç•™ä¸ºæ•°ç»„ï¼‰
                    this.ensureLoaded();
                    return JSON.stringify(this._descs.map(d => ({
                        id: d.id, tags: d.tags, weight: d.weight, depth: d.depth,
                        anchor: d.anchor, placement: d.placement,
                        pattern: d.grid, legend: d.legend, connectors: d.connectors
                    })), null, 2);
                }
            }

            TU.Structures = TU.Structures || new StructureLibrary();

            // ä¾¿æ· APIï¼šå¼€å‘è€…å¯åœ¨æ§åˆ¶å°/è‡ªå®šä¹‰ UI ä¸­è°ƒç”¨
            TU.loadStructureJSON = (jsonString) => {
                try { localStorage.setItem(LS_KEY, jsonString); } catch { }
                const r = TU.Structures.loadFromJSON(jsonString, { replace: true });
                return r;
            };
            TU.clearStructureJSON = () => { try { localStorage.removeItem(LS_KEY); } catch { } TU.Structures.clear(); TU.Structures.ensureLoaded(); };

            // æå‰åŠ è½½ä¸€æ¬¡ï¼ˆé¿å…é¦–æ¬¡ç”Ÿæˆæ—¶ parse å¡é¡¿ï¼‰
            try { TU.Structures.ensureLoaded(); } catch { }
        })();

        class WorldGenerator {
            constructor(w, h, seed) {
                this.w = w;
                this.h = h;
                this.seed = seed;
                this.noise = new NoiseGenerator(seed);
                this.biomeNoise = new NoiseGenerator(seed + 1000);
                this.caveNoise = new NoiseGenerator(seed + 2000);
                this.oreNoise = new NoiseGenerator(seed + 3000);
                this.structureNoise = new NoiseGenerator(seed + 4000);
            }

            async generate(progress) {
                const tiles = Array.from({ length: this.w }, () => new Uint8Array(this.h));
                const walls = Array.from({ length: this.w }, () => new Uint8Array(this.h));
                const light = Array.from({ length: this.w }, () => new Uint8Array(this.h));

                const steps = [
                    ['âœ¨ ç¼–ç»‡åœ°å½¢...', () => this._terrain(tiles, walls)],
                    ['ğŸ”ï¸ ç”Ÿæˆå±±è„‰å³¡è°·...', () => this._specialTerrain(tiles, walls)],
                    ['ğŸ•³ï¸ é›•åˆ»æ´ç©´...', () => this._caves(tiles, walls)],
                    ['ğŸŒŠ åˆ›é€ æ¹–æ³Š...', () => this._lakes(tiles)],
                    ['ğŸ’ åŸ‹è—å®è—...', () => this._ores(tiles)],
                    ['ğŸŒ¿ ç§æ¤ç”Ÿå‘½...', () => this._vegetation(tiles)],
                    ['ğŸ„ åœ°ä¸‹ç”Ÿæ€...', () => this._undergroundLife(tiles, walls)],
                    ['ğŸ  å»ºé€ é—è¿¹...', () => this._structures(tiles, walls)],
                    ['ğŸ° éšç§˜åœ°ç‰¢...', () => this._dungeons(tiles, walls)],
                    ['ğŸ’« ç‚¹äº®ä¸–ç•Œ...', () => this._lighting(tiles, light)]
                ];

                for (let i = 0; i < steps.length; i++) {
                    progress(steps[i][0], (i / steps.length) * 100);
                    steps[i][1]();
                    await new Promise(r => setTimeout(r, 30));
                }

                progress('ğŸ® å‡†å¤‡å°±ç»ª!', 100);
                return { tiles, walls, light, w: this.w, h: this.h };
            }

            _biome(x) {
                const v = this.biomeNoise.fbm(x * 0.003, 0, 4);
                const v2 = this.biomeNoise.fbm(x * 0.008 + 500, 100, 3);

                if (v < -0.35) return 'tundra';
                if (v < -0.15) return 'snow';
                if (v < 0.05) return 'forest';
                if (v < 0.2) return 'plains';
                if (v < 0.35) return v2 > 0 ? 'cherry' : 'bamboo';
                if (v < 0.55) return 'jungle';
                if (v < 0.7) return 'savanna';
                return v2 > 0.2 ? 'red_desert' : 'desert';
            }

            _subBiome(x, y) {
                const v = this.biomeNoise.fbm(x * 0.02, y * 0.02, 3);
                if (y > this.h * 0.5 && y < this.h * 0.7) {
                    if (v > 0.4) return 'mushroom_cave';
                    if (v < -0.4) return 'crystal_cave';
                }
                if (y > this.h * 0.65 && y < this.h * 0.85) {
                    if (v > 0.3) return 'lush_cave';
                    if (v < -0.3) return 'ice_cave';
                }
                return 'normal';
            }

            _terrain(tiles, walls) {
                const surfY = Math.floor(this.h * CONFIG.SURFACE_LEVEL);

                for (let x = 0; x < this.w; x++) {
                    const biome = this._biome(x);

                    // æ›´å¤æ‚çš„åœ°å½¢é«˜åº¦
                    let heightMod = this.noise.fbm(x * 0.008, 0, 6) * 25;
                    heightMod += this.noise.fbm(x * 0.02, 0, 4) * 8;
                    heightMod += this.noise.fbm(x * 0.05, 0, 2) * 3;

                    // ç”Ÿç‰©ç¾¤ç³»å½±å“é«˜åº¦
                    if (biome === 'tundra' || biome === 'snow') heightMod += 10;
                    if (biome === 'plains') heightMod -= 5;
                    if (biome === 'jungle') heightMod += this.noise.fbm(x * 0.03, 50, 3) * 12;

                    const groundY = surfY + Math.floor(heightMod);

                    for (let y = 0; y < this.h; y++) {
                        if (y < groundY - 3) {
                            tiles[x][y] = BLOCK.AIR;
                        } else if (y === groundY) {
                            // è¡¨é¢æ–¹å—æ ¹æ®ç”Ÿç‰©ç¾¤ç³»
                            tiles[x][y] = this._getSurfaceBlock(biome);
                        } else if (y < groundY + 4 + Math.floor(Math.random() * 4)) {
                            // è¡¨åœŸå±‚
                            tiles[x][y] = this._getSubSurfaceBlock(biome);
                            walls[x][y] = 1;
                        } else if (y < this.h * CONFIG.UNDERGROUND_LEVEL) {
                            tiles[x][y] = this._getUndergroundBlock(x, y, 'upper');
                            walls[x][y] = 1;
                        } else if (y < this.h * CONFIG.CAVERN_LEVEL) {
                            tiles[x][y] = this._getUndergroundBlock(x, y, 'middle');
                            walls[x][y] = 2;
                        } else if (y < this.h * CONFIG.UNDERWORLD_LEVEL) {
                            tiles[x][y] = this._getUndergroundBlock(x, y, 'deep');
                            walls[x][y] = 2;
                        } else if (y >= this.h - 4) {
                            tiles[x][y] = BLOCK.BEDROCK;
                            walls[x][y] = 3;
                        } else {
                            // åœ°ç‹±å±‚
                            const hellNoise = this.noise.fbm(x * 0.03, y * 0.03, 3);
                            if (hellNoise > 0.3) tiles[x][y] = BLOCK.HELLSTONE;
                            else if (hellNoise > 0) tiles[x][y] = BLOCK.ASH;
                            else if (hellNoise > -0.3) tiles[x][y] = BLOCK.OBSIDIAN;
                            else tiles[x][y] = BLOCK.BASALT;
                            walls[x][y] = 3;
                        }
                    }
                }
            }

            _getSurfaceBlock(biome) {
                switch (biome) {
                    case 'tundra': case 'snow': return BLOCK.SNOW_GRASS;
                    case 'desert': return BLOCK.SAND;
                    case 'red_desert': return BLOCK.RED_SAND;
                    case 'jungle': return BLOCK.JUNGLE_GRASS;
                    case 'bamboo': return BLOCK.JUNGLE_GRASS;
                    case 'cherry': return BLOCK.GRASS;
                    case 'savanna': return Math.random() > 0.3 ? BLOCK.GRASS : BLOCK.SAND;
                    default: return BLOCK.GRASS;
                }
            }

            _getSubSurfaceBlock(biome) {
                switch (biome) {
                    case 'tundra': case 'snow': return Math.random() > 0.8 ? BLOCK.ICE : BLOCK.SNOW;
                    case 'desert': return Math.random() > 0.7 ? BLOCK.SANDSTONE : BLOCK.SAND;
                    case 'red_desert': return Math.random() > 0.6 ? BLOCK.SANDSTONE : BLOCK.RED_SAND;
                    case 'jungle': case 'bamboo': return Math.random() > 0.5 ? BLOCK.MUD : BLOCK.CLAY;
                    default: return BLOCK.DIRT;
                }
            }

            _getUndergroundBlock(x, y, layer) {
                const n = this.noise.fbm(x * 0.04, y * 0.04, 3);
                const n2 = this.noise.fbm(x * 0.08 + 200, y * 0.08, 2);

                if (layer === 'upper') {
                    if (n > 0.5) return BLOCK.GRAVEL;
                    if (n > 0.35) return BLOCK.CLAY;
                    if (n < -0.4) return BLOCK.LIMESTONE;
                    return BLOCK.STONE;
                } else if (layer === 'middle') {
                    if (n > 0.45) return BLOCK.MOSSY_STONE;
                    if (n > 0.3 && n2 > 0.2) return BLOCK.SLATE;
                    if (n < -0.35) return BLOCK.MARBLE;
                    if (n < -0.5) return BLOCK.GRANITE;
                    return BLOCK.STONE;
                } else {
                    if (n > 0.4) return BLOCK.GRANITE;
                    if (n > 0.25 && n2 > 0.1) return BLOCK.BASALT;
                    if (n < -0.3) return BLOCK.OBSIDIAN;
                    if (n < -0.45) return BLOCK.SLATE;
                    return BLOCK.STONE;
                }
            }

            _specialTerrain(tiles, walls) {
                // æµ®ç©ºå²›å±¿
                for (let i = 0; i < 3 + Math.floor(Math.random() * 4); i++) {
                    const ix = 80 + Math.floor(Math.random() * (this.w - 160));
                    const iy = 15 + Math.floor(Math.random() * 25);
                    const iw = 20 + Math.floor(Math.random() * 30);
                    const ih = 8 + Math.floor(Math.random() * 8);

                    this._createFloatingIsland(tiles, walls, ix, iy, iw, ih);
                }

                // å³¡è°·/è£‚ç¼
                for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                    const cx = 50 + Math.floor(Math.random() * (this.w - 100));
                    this._createRavine(tiles, cx);
                }

                // åœ°è¡¨æ¹–æ³Šä½ç½®é¢„ç•™
                for (let i = 0; i < 4 + Math.floor(Math.random() * 4); i++) {
                    const lx = 30 + Math.floor(Math.random() * (this.w - 60));
                    this._createSurfaceLake(tiles, lx);
                }
            }

            _createFloatingIsland(tiles, walls, cx, cy, w, h) {
                for (let dx = -w / 2; dx < w / 2; dx++) {
                    const x = Math.floor(cx + dx);
                    if (x < 0 || x >= this.w) continue;

                    const edgeDist = Math.min(dx + w / 2, w / 2 - dx) / (w / 2);
                    const height = Math.floor(h * edgeDist * (0.7 + Math.random() * 0.3));

                    for (let dy = 0; dy < height; dy++) {
                        const y = cy + dy;
                        if (y < 0 || y >= this.h) continue;

                        if (dy === 0) {
                            tiles[x][y] = BLOCK.GRASS;
                        } else if (dy < 3) {
                            tiles[x][y] = BLOCK.DIRT;
                        } else {
                            tiles[x][y] = BLOCK.STONE;
                        }
                        walls[x][y] = 1;
                    }
                }

                // å²›ä¸Šæ”¾äº›å¥½ä¸œè¥¿
                if (cx > 0 && cx < this.w && cy > 0) {
                    if (Math.random() > 0.5) tiles[cx][cy - 1] = BLOCK.TREASURE_CHEST;
                    else tiles[cx][cy - 1] = BLOCK.CRYSTAL;
                }
            }

            _createRavine(tiles, startX) {
                let x = startX;
                const surfY = Math.floor(this.h * CONFIG.SURFACE_LEVEL);

                // æ‰¾åˆ°åœ°è¡¨
                let groundY = 0;
                for (let y = 0; y < this.h; y++) {
                    if (tiles[x][y] !== BLOCK.AIR) { groundY = y; break; }
                }

                const depth = 30 + Math.floor(Math.random() * 40);
                const width = 3 + Math.floor(Math.random() * 4);

                for (let y = groundY; y < groundY + depth && y < this.h - 10; y++) {
                    const w = width + Math.floor(Math.sin(y * 0.1) * 2);
                    for (let dx = -w; dx <= w; dx++) {
                        const tx = x + dx + Math.floor(Math.sin(y * 0.15) * 3);
                        if (tx >= 0 && tx < this.w) {
                            tiles[tx][y] = BLOCK.AIR;
                        }
                    }
                }

                // åº•éƒ¨æ”¾æ°´æˆ–ç†”å²©
                for (let dx = -width - 2; dx <= width + 2; dx++) {
                    const tx = x + dx;
                    const ty = groundY + depth - 3;
                    if (tx >= 0 && tx < this.w && ty >= 0 && ty < this.h) {
                        if (tiles[tx][ty] === BLOCK.AIR) {
                            tiles[tx][ty] = Math.random() > 0.7 ? BLOCK.LAVA : BLOCK.WATER;
                        }
                    }
                }
            }

            _createSurfaceLake(tiles, startX) {
                const biome = this._biome(startX);
                if (biome === 'desert' || biome === 'red_desert') return; // æ²™æ¼ æ²¡æœ‰æ¹–

                const width = 15 + Math.floor(Math.random() * 25);
                const depth = 4 + Math.floor(Math.random() * 6);

                // æ‰¾åœ°è¡¨é«˜åº¦
                let minGroundY = this.h;
                for (let dx = 0; dx < width; dx++) {
                    const x = startX + dx;
                    if (x >= this.w) continue;
                    for (let y = 0; y < this.h; y++) {
                        if (tiles[x][y] !== BLOCK.AIR) {
                            minGroundY = Math.min(minGroundY, y);
                            break;
                        }
                    }
                }

                // æŒ–æ¹–
                for (let dx = 0; dx < width; dx++) {
                    const x = startX + dx;
                    if (x >= this.w) continue;

                    const edgeDist = Math.min(dx, width - dx) / (width / 2);
                    const d = Math.floor(depth * edgeDist);

                    for (let dy = 0; dy < d; dy++) {
                        const y = minGroundY + dy;
                        if (y >= this.h) continue;
                        tiles[x][y] = biome === 'snow' || biome === 'tundra' ? BLOCK.ICE : BLOCK.WATER;
                    }
                }
            }

            _caves(tiles, walls) {
                const startY = Math.floor(this.h * CONFIG.SURFACE_LEVEL) + 8;

                // å¤šå±‚æ´ç©´ç³»ç»Ÿ
                for (let x = 0; x < this.w; x++) {
                    for (let y = startY; y < this.h - 4; y++) {
                        const subBiome = this._subBiome(x, y);

                        // ä¸»æ´ç©´ç½‘ç»œ
                        const c1 = this.caveNoise.warpedNoise(x * 0.032, y * 0.032);
                        const c2 = this.caveNoise.fbm(x * 0.05 + 500, y * 0.05, 4);
                        const c3 = this.caveNoise.fbm(x * 0.02 + 1000, y * 0.02, 3);

                        const depth = Math.min(1, (y - startY) / (this.h * 0.3));
                        const thresh = 0.35 + depth * 0.15;

                        // ä¸»è¦æ´ç©´
                        if (c1 > thresh || (c2 > 0.55 && Math.random() > 0.3)) {
                            tiles[x][y] = BLOCK.AIR;
                        }

                        // å¤§å‹æ´å®¤
                        if (y > this.h * CONFIG.CAVERN_LEVEL && c3 > 0.48) {
                            tiles[x][y] = BLOCK.AIR;
                        }

                        // è •è™«çŠ¶éš§é“
                        const worm = Math.sin(x * 0.05 + y * 0.1) * Math.sin(x * 0.02 - y * 0.03);
                        if (Math.abs(worm) < 0.08 && y > this.h * 0.35 && Math.random() > 0.3) {
                            tiles[x][y] = BLOCK.AIR;
                        }
                    }
                }

                // åœ°ä¸‹æ°´å’Œç†”å²©æ± 
                this._fillCaveLiquids(tiles);
            }

            _fillCaveLiquids(tiles) {
                for (let x = 0; x < this.w; x++) {
                    for (let y = Math.floor(this.h * 0.45); y < this.h - 4; y++) {
                        if (tiles[x][y] !== BLOCK.AIR) continue;

                        // æ£€æŸ¥æ˜¯å¦æ˜¯æ± åº•
                        if (y + 1 < this.h && BLOCK_DATA[tiles[x][y + 1]]?.solid) {
                            // æ·±å±‚ç†”å²©
                            if (y > this.h * CONFIG.UNDERWORLD_LEVEL && Math.random() > 0.5) {
                                this._fillPool(tiles, x, y, BLOCK.LAVA, 8);
                            }
                            // ä¸­å±‚æ°´æ± 
                            else if (y < this.h * CONFIG.UNDERWORLD_LEVEL && Math.random() > 0.88) {
                                this._fillPool(tiles, x, y, BLOCK.WATER, 12);
                            }
                        }
                    }
                }
            }

            _fillPool(tiles, sx, sy, liquid, maxSize) {
                // æ€§èƒ½ï¼šé¿å… queue.shift() çš„ O(n) å¼€é”€ & å­—ç¬¦ä¸² key çš„é¢‘ç¹åˆ†é…
                const queue = [{ x: sx, y: sy }];
                let head = 0;
                const filled = new Set();
                let count = 0;

                while (head < queue.length && count < maxSize) {
                    const { x, y } = queue[head++];

                    if (x < 0 || x >= this.w || y < 0 || y >= this.h) continue;

                    // ä»¥ 32-bit key ä»£æ›¿ `${x},${y}`ï¼Œå‡å°‘ GC å‹åŠ›ï¼ˆå‡è®¾ä¸–ç•Œå°ºå¯¸ < 65536ï¼‰
                    const key = (x << 16) | (y & 0xffff);
                    if (filled.has(key)) continue;
                    filled.add(key);

                    if (tiles[x][y] !== BLOCK.AIR) continue;

                    tiles[x][y] = liquid;
                    count++;

                    // åªå‘ä¸‹å’Œæ°´å¹³æ‰©å±•
                    queue.push({ x: x - 1, y }, { x: x + 1, y }, { x, y: y + 1 });
                }
            }

            _lakes(tiles) {
                // åœ°ä¸‹å¤§å‹æ¹–æ³Š
                for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                    const lx = 50 + Math.floor(Math.random() * (this.w - 100));
                    const ly = Math.floor(this.h * (0.5 + Math.random() * 0.25));
                    const lw = 25 + Math.floor(Math.random() * 35);
                    const lh = 8 + Math.floor(Math.random() * 12);

                    this._createUndergroundLake(tiles, lx, ly, lw, lh);
                }

                // ç†”å²©æ¹–
                for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                    const lx = 40 + Math.floor(Math.random() * (this.w - 80));
                    const ly = Math.floor(this.h * (0.85 + Math.random() * 0.1));
                    const lw = 20 + Math.floor(Math.random() * 30);
                    const lh = 5 + Math.floor(Math.random() * 8);

                    this._createLavaLake(tiles, lx, ly, lw, lh);
                }
            }

            _createUndergroundLake(tiles, cx, cy, w, h) {
                for (let dx = -w / 2; dx < w / 2; dx++) {
                    for (let dy = -h / 2; dy < h / 2; dy++) {
                        const x = Math.floor(cx + dx);
                        const y = Math.floor(cy + dy);
                        if (x < 0 || x >= this.w || y < 0 || y >= this.h) continue;

                        const dist = Math.sqrt((dx / (w / 2)) ** 2 + (dy / (h / 2)) ** 2);
                        if (dist < 1 - Math.random() * 0.2) {
                            tiles[x][y] = BLOCK.WATER;
                        }
                    }
                }
            }

            _createLavaLake(tiles, cx, cy, w, h) {
                for (let dx = -w / 2; dx < w / 2; dx++) {
                    for (let dy = -h / 2; dy < h / 2; dy++) {
                        const x = Math.floor(cx + dx);
                        const y = Math.floor(cy + dy);
                        if (x < 0 || x >= this.w || y < 0 || y >= this.h) continue;

                        const dist = Math.sqrt((dx / (w / 2)) ** 2 + (dy / (h / 2)) ** 2);
                        if (dist < 0.9) {
                            tiles[x][y] = BLOCK.LAVA;
                        }
                    }
                }
                // å‘¨å›´æ”¾è¤çŸ³
                for (let i = 0; i < 8; i++) {
                    const gx = cx + Math.floor((Math.random() - 0.5) * w * 1.2);
                    const gy = cy + Math.floor((Math.random() - 0.5) * h * 1.5);
                    if (gx >= 0 && gx < this.w && gy >= 0 && gy < this.h) {
                        if (tiles[gx][gy] === BLOCK.STONE || tiles[gx][gy] === BLOCK.OBSIDIAN) {
                            tiles[gx][gy] = BLOCK.GLOWSTONE;
                        }
                    }
                }
            }

            _ores(tiles) {
                const ores = [
                    // å¸¸è§çŸ¿çŸ³
                    { id: BLOCK.COPPER_ORE, minY: 0.26, maxY: 0.55, chance: 0.008, size: 6 },
                    { id: BLOCK.IRON_ORE, minY: 0.35, maxY: 0.65, chance: 0.006, size: 5 },
                    { id: BLOCK.SILVER_ORE, minY: 0.45, maxY: 0.75, chance: 0.005, size: 4 },
                    { id: BLOCK.GOLD_ORE, minY: 0.52, maxY: 0.82, chance: 0.004, size: 4 },
                    // ç¨€æœ‰çŸ¿çŸ³
                    { id: BLOCK.DIAMOND_ORE, minY: 0.70, maxY: 0.88, chance: 0.0015, size: 3 },
                    { id: BLOCK.RUBY_ORE, minY: 0.60, maxY: 0.80, chance: 0.002, size: 3 },
                    { id: BLOCK.EMERALD_ORE, minY: 0.55, maxY: 0.75, chance: 0.002, size: 3 },
                    { id: BLOCK.SAPPHIRE_ORE, minY: 0.58, maxY: 0.78, chance: 0.002, size: 3 },
                    // ç‰¹æ®ŠçŸ¿çŸ³
                    { id: BLOCK.CRYSTAL, minY: 0.48, maxY: 0.72, chance: 0.003, size: 4 },
                    { id: BLOCK.AMETHYST, minY: 0.55, maxY: 0.80, chance: 0.0025, size: 4 },
                    { id: BLOCK.GLOWSTONE, minY: 0.60, maxY: 0.85, chance: 0.003, size: 3 },
                    // åœ°ç‹±çŸ¿çŸ³
                    { id: BLOCK.HELLSTONE, minY: 0.88, maxY: 0.98, chance: 0.015, size: 5 }
                ];

                for (const ore of ores) {
                    const minY = Math.floor(this.h * ore.minY);
                    const maxY = Math.floor(this.h * ore.maxY);

                    for (let x = 0; x < this.w; x++) {
                        for (let y = minY; y < maxY; y++) {
                            // ä½¿ç”¨å™ªå£°å¢åŠ çŸ¿è„‰èšé›†æ€§
                            const oreChance = ore.chance * (1 + this.oreNoise.fbm(x * 0.1, y * 0.1, 2));
                            if (Math.random() < oreChance) {
                                const block = tiles[x][y];
                                if (block === BLOCK.STONE || block === BLOCK.GRANITE ||
                                    block === BLOCK.SLATE || block === BLOCK.LIMESTONE) {
                                    this._placeVein(tiles, x, y, ore.id, ore.size + Math.floor(Math.random() * 3));
                                }
                            }
                        }
                    }
                }
            }

            _placeVein(tiles, sx, sy, id, size) {
                const placed = [{ x: sx, y: sy }];
                tiles[sx][sy] = id;
                let attempts = 0;

                while (placed.length < size && attempts < size * 3) {
                    attempts++;
                    const p = placed[Math.floor(Math.random() * placed.length)];
                    const nx = p.x + Math.floor(Math.random() * 3) - 1;
                    const ny = p.y + Math.floor(Math.random() * 3) - 1;

                    if (nx >= 0 && nx < this.w && ny >= 0 && ny < this.h) {
                        const block = tiles[nx][ny];
                        if (block === BLOCK.STONE || block === BLOCK.GRANITE ||
                            block === BLOCK.SLATE || block === BLOCK.LIMESTONE ||
                            block === BLOCK.MARBLE || block === BLOCK.BASALT) {
                            tiles[nx][ny] = id;
                            placed.push({ x: nx, y: ny });
                        }
                    }
                }
            }

            _vegetation(tiles) {
                for (let x = 5; x < this.w - 5; x++) {
                    const biome = this._biome(x);
                    let groundY = 0;
                    for (let y = 0; y < this.h; y++) {
                        if (tiles[x][y] !== BLOCK.AIR) { groundY = y; break; }
                    }
                    if (!groundY || groundY > this.h * 0.5) continue;

                    // å„ç§æ ‘æœ¨
                    this._placeTree(tiles, x, groundY, biome);

                    // èŠ±è‰è£…é¥°
                    this._placeFlora(tiles, x, groundY, biome);
                }
            }

            _placeTree(tiles, x, groundY, biome) {
                const treeChance = {
                    'forest': 0.08, 'jungle': 0.12, 'plains': 0.03, 'cherry': 0.07,
                    'bamboo': 0.15, 'snow': 0.04, 'tundra': 0.02, 'savanna': 0.02,
                    'desert': 0, 'red_desert': 0
                };

                if (Math.random() > (treeChance[biome] || 0.05)) return;
                if (tiles[x][groundY - 1] !== BLOCK.AIR) return;

                let logType = BLOCK.LOG;
                let leafType = BLOCK.LEAVES;
                let height = 5 + Math.floor(Math.random() * 4);
                let canopyRadius = 2;

                switch (biome) {
                    case 'jungle':
                        height = 10 + Math.floor(Math.random() * 8);
                        canopyRadius = 3 + Math.floor(Math.random() * 2);
                        break;
                    case 'bamboo':
                        logType = BLOCK.BAMBOO;
                        height = 8 + Math.floor(Math.random() * 6);
                        // ç«¹å­æ²¡æœ‰æ ‘å† 
                        for (let i = 1; i <= height && groundY - i >= 0; i++) {
                            tiles[x][groundY - i] = logType;
                        }
                        return;
                    case 'cherry':
                        logType = BLOCK.CHERRY_LOG;
                        leafType = BLOCK.CHERRY_LEAVES;
                        height = 6 + Math.floor(Math.random() * 3);
                        canopyRadius = 3;
                        break;
                    case 'snow': case 'tundra':
                        logType = BLOCK.PINE_LOG;
                        leafType = BLOCK.PINE_LEAVES;
                        height = 8 + Math.floor(Math.random() * 5);
                        // æ¾æ ‘æ˜¯ä¸‰è§’å½¢
                        for (let i = 1; i <= height && groundY - i >= 0; i++) {
                            tiles[x][groundY - i] = logType;
                        }
                        for (let layer = 0; layer < height - 2; layer++) {
                            const w = Math.max(1, Math.floor((height - layer) / 2));
                            const y = groundY - height + layer;
                            for (let dx = -w; dx <= w; dx++) {
                                const tx = x + dx;
                                if (tx >= 0 && tx < this.w && y >= 0 && tiles[tx][y] === BLOCK.AIR) {
                                    tiles[tx][y] = leafType;
                                }
                            }
                        }
                        return;
                    case 'savanna':
                        height = 4 + Math.floor(Math.random() * 2);
                        canopyRadius = 4;
                        break;
                    case 'desert': case 'red_desert':
                        // ä»™äººæŒ
                        if (Math.random() > 0.96) {
                            const h = 3 + Math.floor(Math.random() * 4);
                            for (let i = 1; i <= h && groundY - i >= 0; i++) {
                                tiles[x][groundY - i] = BLOCK.CACTUS;
                            }
                            // ä»™äººæŒæ‰‹è‡‚
                            if (h > 3 && Math.random() > 0.5) {
                                const armY = groundY - Math.floor(h / 2);
                                const armDir = Math.random() > 0.5 ? 1 : -1;
                                if (x + armDir >= 0 && x + armDir < this.w) {
                                    if (armY >= 0 && armY < this.h && tiles[x + armDir][armY] === BLOCK.AIR) tiles[x + armDir][armY] = BLOCK.CACTUS;
                                    if (armY - 1 >= 0 && (armY - 1) < this.h && tiles[x + armDir][armY - 1] === BLOCK.AIR) tiles[x + armDir][armY - 1] = BLOCK.CACTUS;
                                }
                            }
                        }
                        return;
                }

                // æ ‡å‡†æ ‘å¹²
                for (let i = 1; i <= height && groundY - i >= 0; i++) {
                    tiles[x][groundY - i] = logType;
                }

                // æ ‘å† 
                for (let dx = -canopyRadius; dx <= canopyRadius; dx++) {
                    for (let dy = -canopyRadius - 1; dy <= 1; dy++) {
                        const tx = x + dx, ty = groundY - height + dy;
                        if (tx >= 0 && tx < this.w && ty >= 0 && ty < this.h) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= canopyRadius + 0.5 && tiles[tx][ty] === BLOCK.AIR && Math.random() > 0.15) {
                                tiles[tx][ty] = leafType;
                            }
                        }
                    }
                }
            }

            _placeFlora(tiles, x, groundY, biome) {
                if (tiles[x][groundY - 1] !== BLOCK.AIR) return;

                const floraChance = biome === 'jungle' ? 0.5 : biome === 'plains' ? 0.4 :
                    biome === 'forest' ? 0.35 : biome === 'cherry' ? 0.45 : 0.2;

                if (Math.random() > floraChance) return;

                const r = Math.random();
                let flora = BLOCK.TALL_GRASS;

                switch (biome) {
                    case 'plains':
                        if (r > 0.92) flora = BLOCK.SUNFLOWER;
                        else if (r > 0.85) flora = BLOCK.FLOWER_RED;
                        else if (r > 0.78) flora = BLOCK.FLOWER_YELLOW;
                        else if (r > 0.7) flora = BLOCK.PINK_FLOWER;
                        else if (r > 0.62) flora = BLOCK.BLUE_FLOWER;
                        else flora = BLOCK.TALL_GRASS;
                        break;
                    case 'forest':
                        if (r > 0.9) flora = BLOCK.MUSHROOM;
                        else if (r > 0.8) flora = BLOCK.FERN;
                        else if (r > 0.7) flora = BLOCK.FLOWER_RED;
                        else flora = BLOCK.TALL_GRASS;
                        break;
                    case 'jungle':
                        if (r > 0.85) flora = BLOCK.FERN;
                        else if (r > 0.75) flora = BLOCK.PINK_FLOWER;
                        else flora = BLOCK.TALL_GRASS;
                        break;
                    case 'cherry':
                        if (r > 0.8) flora = BLOCK.PINK_FLOWER;
                        else if (r > 0.6) flora = BLOCK.FLOWER_RED;
                        else flora = BLOCK.TALL_GRASS;
                        break;
                    case 'snow': case 'tundra':
                        if (r > 0.9) flora = BLOCK.BLUE_FLOWER;
                        break;
                    default:
                        if (r > 0.85) flora = BLOCK.FLOWER_YELLOW;
                        else if (r > 0.7) flora = BLOCK.TALL_GRASS;
                        else return;
                }

                tiles[x][groundY - 1] = flora;
            }

            _undergroundLife(tiles, walls) {
                const startY = Math.floor(this.h * CONFIG.UNDERGROUND_LEVEL);

                for (let x = 0; x < this.w; x++) {
                    for (let y = startY; y < this.h * CONFIG.UNDERWORLD_LEVEL; y++) {
                        if (tiles[x][y] !== BLOCK.AIR) continue;

                        const subBiome = this._subBiome(x, y);

                        // åœ°ä¸‹è˜‘è‡
                        if (tiles[x][y + 1] !== BLOCK.AIR && BLOCK_DATA[tiles[x][y + 1]]?.solid) {
                            if (Math.random() > 0.992) {
                                tiles[x][y] = subBiome === 'mushroom_cave' ? BLOCK.UNDERGROUND_MUSHROOM : BLOCK.MUSHROOM;
                            }
                            if (subBiome === 'mushroom_cave' && Math.random() > 0.97) {
                                // å·¨å‹è˜‘è‡
                                this._placeGiantMushroom(tiles, x, y);
                            }
                        }

                        // å¤©èŠ±æ¿è£…é¥°
                        if (y > 0 && tiles[x][y - 1] !== BLOCK.AIR && BLOCK_DATA[tiles[x][y - 1]]?.solid) {
                            if (Math.random() > 0.985) {
                                tiles[x][y] = BLOCK.STALACTITE;
                            }
                            if (subBiome === 'lush_cave' && Math.random() > 0.9) {
                                tiles[x][y] = BLOCK.VINE;
                            }
                        }

                        // åœ°é¢è£…é¥°
                        if (y + 1 < this.h && tiles[x][y + 1] !== BLOCK.AIR && BLOCK_DATA[tiles[x][y + 1]]?.solid) {
                            if (Math.random() > 0.988) {
                                tiles[x][y] = BLOCK.STALAGMITE;
                            }
                            if (subBiome === 'lush_cave' && Math.random() > 0.93) {
                                tiles[x][y] = BLOCK.GLOWING_MOSS;
                            }
                            if (subBiome === 'crystal_cave' && Math.random() > 0.95) {
                                tiles[x][y] = Math.random() > 0.5 ? BLOCK.CRYSTAL : BLOCK.AMETHYST;
                            }
                        }

                        // å¢™å£è£…é¥°
                        if (subBiome === 'lush_cave') {
                            if (x > 0 && tiles[x - 1][y] !== BLOCK.AIR && Math.random() > 0.92) {
                                tiles[x][y] = BLOCK.MOSS;
                            }
                            if (x + 1 < this.w && tiles[x + 1][y] !== BLOCK.AIR && Math.random() > 0.92) {
                                tiles[x][y] = BLOCK.MOSS;
                            }
                        }

                        // å†°æ´ç©´
                        if (subBiome === 'ice_cave') {
                            if (Math.random() > 0.95) {
                                // å°†å‘¨å›´çŸ³å¤´å˜æˆå†»çŸ³
                                for (let dx = -1; dx <= 1; dx++) {
                                    for (let dy = -1; dy <= 1; dy++) {
                                        const tx = x + dx, ty = y + dy;
                                        if (tx >= 0 && tx < this.w && ty >= 0 && ty < this.h) {
                                            if (tiles[tx][ty] === BLOCK.STONE) {
                                                tiles[tx][ty] = BLOCK.FROZEN_STONE;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            _placeGiantMushroom(tiles, x, groundY) {
                const height = 5 + Math.floor(Math.random() * 4);
                const capRadius = 2 + Math.floor(Math.random() * 2);

                // èŒ
                for (let i = 1; i <= height && groundY - i >= 0; i++) {
                    tiles[x][groundY - i] = BLOCK.MUSHROOM_GIANT;
                }

                // ä¼ç›–
                for (let dx = -capRadius; dx <= capRadius; dx++) {
                    const tx = x + dx;
                    const ty = groundY - height;
                    if (tx >= 0 && tx < this.w && ty >= 0 && ty < this.h) {
                        if (tiles[tx][ty] === BLOCK.AIR) {
                            tiles[tx][ty] = BLOCK.MUSHROOM_GIANT;
                        }
                        if (ty - 1 >= 0 && tiles[tx][ty - 1] === BLOCK.AIR && Math.abs(dx) < capRadius) {
                            tiles[tx][ty - 1] = BLOCK.MUSHROOM_GIANT;
                        }
                    }
                }
            }

            _structures(tiles, walls) {
                // åœ°è¡¨å°å±‹
                for (let i = 0; i < 6 + Math.floor(Math.random() * 5); i++) {
                    const x = 50 + Math.floor(Math.random() * (this.w - 100));
                    this._placeHouse(tiles, walls, x);
                }

                // åœ°ä¸‹é—è¿¹å°å±‹
                for (let i = 0; i < 8 + Math.floor(Math.random() * 6); i++) {
                    const x = 40 + Math.floor(Math.random() * (this.w - 80));
                    const y = Math.floor(this.h * (0.4 + Math.random() * 0.35));
                    this._placeUndergroundCabin(tiles, walls, x, y);
                }

                // çŸ¿äº•å…¥å£
                for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                    const x = 60 + Math.floor(Math.random() * (this.w - 120));
                    this._placeMineEntrance(tiles, walls, x);
                }

                // ç¥æ®¿
                if (Math.random() > 0.3) {
                    const x = 100 + Math.floor(Math.random() * (this.w - 200));
                    const y = Math.floor(this.h * (0.55 + Math.random() * 0.2));
                    this._placeTemple(tiles, walls, x, y);
                }
            }

            _placeHouse(tiles, walls, x) {
                let groundY = 0;
                for (let y = 0; y < this.h; y++) {
                    if (tiles[x][y] !== BLOCK.AIR) { groundY = y; break; }
                }
                if (!groundY || groundY > this.h * 0.4) return;

                const w = 8 + Math.floor(Math.random() * 4);
                const h = 6 + Math.floor(Math.random() * 3);
                const biome = this._biome(x);

                let wallBlock = BLOCK.PLANKS;
                if (biome === 'desert' || biome === 'red_desert') wallBlock = BLOCK.SANDSTONE;
                if (biome === 'snow' || biome === 'tundra') wallBlock = Math.random() > 0.5 ? BLOCK.PLANKS : BLOCK.ICE;

                for (let dx = 0; dx < w; dx++) {
                    for (let dy = 0; dy < h; dy++) {
                        const tx = x + dx, ty = groundY - h + dy;
                        if (tx >= this.w || ty < 0) continue;

                        const isWall = dx === 0 || dx === w - 1 || dy === 0 || dy === h - 1;
                        const isDoor = dy === h - 1 && dx === Math.floor(w / 2);

                        if (isDoor) {
                            tiles[tx][ty] = BLOCK.AIR;
                        } else if (isWall) {
                            tiles[tx][ty] = wallBlock;
                        } else {
                            tiles[tx][ty] = BLOCK.AIR;
                            walls[tx][ty] = 1;
                        }
                    }
                }

                // å†…éƒ¨è£…é¥°
                const midX = x + Math.floor(w / 2);
                const floorY = groundY - 1;
                if (midX < this.w && floorY > 0) {
                    tiles[midX][groundY - h + 1] = BLOCK.LANTERN;
                    if (Math.random() > 0.5 && x + w - 2 < this.w) {
                        tiles[x + w - 2][floorY] = BLOCK.TREASURE_CHEST;
                    }
                }
            }

            _placeUndergroundCabin(tiles, walls, x, y) {
                const w = 7 + Math.floor(Math.random() * 5);
                const h = 5 + Math.floor(Math.random() * 3);

                for (let dx = 0; dx < w; dx++) {
                    for (let dy = 0; dy < h; dy++) {
                        const tx = x + dx, ty = y + dy;
                        if (tx >= this.w || ty >= this.h) continue;

                        const isWall = dx === 0 || dx === w - 1 || dy === 0 || dy === h - 1;
                        tiles[tx][ty] = isWall ? BLOCK.PLANKS : BLOCK.AIR;
                        if (!isWall) walls[tx][ty] = 1;
                    }
                }

                // ç«æŠŠ
                if (x + Math.floor(w / 2) < this.w && y + 1 < this.h) {
                    tiles[x + Math.floor(w / 2)][y + 1] = BLOCK.TORCH;
                }
                // å®ç®±
                if (x + w - 2 < this.w && y + h - 2 < this.h && Math.random() > 0.3) {
                    tiles[x + w - 2][y + h - 2] = BLOCK.TREASURE_CHEST;
                }
            }

            _placeMineEntrance(tiles, walls, x) {
                let groundY = 0;
                for (let y = 0; y < this.h; y++) {
                    if (tiles[x][y] !== BLOCK.AIR) { groundY = y; break; }
                }
                if (!groundY) return;

                // çŸ¿äº•å…¥å£æ¡†æ¶
                const entranceW = 4;
                const entranceH = 5;

                for (let dx = 0; dx < entranceW; dx++) {
                    for (let dy = 0; dy < entranceH; dy++) {
                        const tx = x + dx, ty = groundY + dy;
                        if (tx >= this.w || ty >= this.h) continue;

                        if (dx === 0 || dx === entranceW - 1) {
                            tiles[tx][ty] = BLOCK.PLANKS;
                        } else {
                            tiles[tx][ty] = BLOCK.AIR;
                        }
                    }
                }

                // å‘ä¸‹çš„ç«–äº•
                const shaftDepth = 20 + Math.floor(Math.random() * 30);
                for (let dy = entranceH; dy < shaftDepth; dy++) {
                    const ty = groundY + dy;
                    if (ty >= this.h - 10) break;

                    for (let dx = 1; dx < entranceW - 1; dx++) {
                        const tx = x + dx;
                        if (tx < this.w) tiles[tx][ty] = BLOCK.AIR;
                    }

                    // å‘¨æœŸæ€§æ”¾ç½®æ¢¯å­å¹³å°
                    if (dy % 8 === 0) {
                        for (let dx = 0; dx < entranceW; dx++) {
                            const tx = x + dx;
                            if (tx < this.w) tiles[tx][ty] = BLOCK.PLANKS;
                        }
                    }

                    // ç«æŠŠ
                    if (dy % 6 === 0 && x < this.w) {
                        tiles[x][ty] = BLOCK.TORCH;
                    }
                }
            }

            _placeTemple(tiles, walls, x, y) {
                const w = 15 + Math.floor(Math.random() * 10);
                const h = 10 + Math.floor(Math.random() * 5);

                const wallBlock = Math.random() > 0.5 ? BLOCK.BRICK : BLOCK.COBBLESTONE;

                for (let dx = 0; dx < w; dx++) {
                    for (let dy = 0; dy < h; dy++) {
                        const tx = x + dx, ty = y + dy;
                        if (tx >= this.w || ty >= this.h) continue;

                        const isWall = dx === 0 || dx === w - 1 || dy === 0 || dy === h - 1;
                        const isPillar = (dx === 3 || dx === w - 4) && dy > 1 && dy < h - 1;

                        if (isWall || isPillar) {
                            tiles[tx][ty] = wallBlock;
                        } else {
                            tiles[tx][ty] = BLOCK.AIR;
                            walls[tx][ty] = 2;
                        }
                    }
                }

                // ä¸­å¤®å®è—
                const cx = x + Math.floor(w / 2);
                const cy = y + h - 2;
                if (cx < this.w && cy < this.h) {
                    tiles[cx][cy] = BLOCK.TREASURE_CHEST;
                    tiles[cx][y + 1] = BLOCK.LANTERN;

                    // å‘¨å›´æ°´æ™¶
                    for (let i = 0; i < 4; i++) {
                        const crystalX = cx + (i % 2 === 0 ? -2 : 2);
                        const crystalY = cy - (i < 2 ? 0 : 1);
                        if (crystalX >= 0 && crystalX < this.w && crystalY >= 0 && crystalY < this.h) {
                            tiles[crystalX][crystalY] = Math.random() > 0.5 ? BLOCK.CRYSTAL : BLOCK.AMETHYST;
                        }
                    }
                }

                // èœ˜è››ç½‘è£…é¥°
                for (let i = 0; i < 5; i++) {
                    const wx = x + 1 + Math.floor(Math.random() * (w - 2));
                    const wy = y + 1 + Math.floor(Math.random() * 3);
                    if (wx < this.w && wy < this.h && tiles[wx][wy] === BLOCK.AIR) {
                        tiles[wx][wy] = BLOCK.SPIDER_WEB;
                    }
                }
            }

            _dungeons(tiles, walls) {
                const dungeonCount = 2 + Math.floor(Math.random() * 3);

                for (let d = 0; d < dungeonCount; d++) {
                    const startX = 80 + Math.floor(Math.random() * (this.w - 160));
                    const startY = Math.floor(this.h * (0.5 + Math.random() * 0.3));

                    this._createDungeon(tiles, walls, startX, startY);
                }

                // é¢å¤–æ·»åŠ ç‰¹æ®Šç»“æ„
                this._createSpecialFeatures(tiles, walls);

                // StructureDescriptorï¼šä» JSON ç»“æ„åº“æŒ‰æ·±åº¦æŠ½å–å¹¶ç„Šæ¥åˆ°åœ°å½¢ä¸­
                if (this._weldStructuresFromLibrary) this._weldStructuresFromLibrary(tiles, walls);
            }

            // åˆ›å»ºç‰¹æ®Šåœ°å½¢ç‰¹å¾
            _createSpecialFeatures(tiles, walls) {
                // é™¨çŸ³å‘
                for (let i = 0; i < 1 + Math.floor(Math.random() * 2); i++) {
                    const mx = 100 + Math.floor(Math.random() * (this.w - 200));
                    this._createMeteoriteCrater(tiles, mx);
                }

                // èœ‚å·¢
                for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                    const hx = 60 + Math.floor(Math.random() * (this.w - 120));
                    const hy = Math.floor(this.h * (0.35 + Math.random() * 0.2));
                    this._createBeehive(tiles, walls, hx, hy);
                }

                // èœ˜è››å·¢ç©´
                for (let i = 0; i < 3 + Math.floor(Math.random() * 4); i++) {
                    const sx = 50 + Math.floor(Math.random() * (this.w - 100));
                    const sy = Math.floor(this.h * (0.45 + Math.random() * 0.3));
                    this._createSpiderNest(tiles, walls, sx, sy);
                }

                // ç”Ÿå‘½æ ‘
                for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                    const tx = 80 + Math.floor(Math.random() * (this.w - 160));
                    this._createLivingTree(tiles, walls, tx);
                }

                // é‡‘å­—å¡” (æ²™æ¼ )
                this._createPyramids(tiles, walls);

                // åœ°ä¸‹ä¸›æ—ç¥åº™
                if (Math.random() > 0.4) {
                    const jx = Math.floor(this.w * 0.6 + Math.random() * this.w * 0.3);
                    const jy = Math.floor(this.h * (0.65 + Math.random() * 0.15));
                    this._createJungleTemple(tiles, walls, jx, jy);
                }

                // å¤©ç©ºå²›é“¾
                this._createSkyIslandChain(tiles, walls);

                // åœ°ä¸‹è˜‘è‡ç”Ÿæ€åŒº
                this._createMushroomBiome(tiles, walls);

                // è…åŒ–/çŒ©çº¢åŒºåŸŸ
                this._createEvilBiome(tiles, walls);

                // ç¥åœ£åŒºåŸŸ
                this._createHallowBiome(tiles, walls);

                // æµ·æ´‹/æ²™æ»©
                this._createOceans(tiles, walls);

                // è¯è‰åˆ†å¸ƒ
                this._distributeHerbs(tiles);

                // ç”Ÿå‘½æ°´æ™¶
                this._placeLifeCrystals(tiles);
            }

            _createMeteoriteCrater(tiles, cx) {
                let groundY = 0;
                for (let y = 0; y < this.h; y++) {
                    if (tiles[cx][y] !== BLOCK.AIR) { groundY = y; break; }
                }
                if (!groundY) return;

                const craterRadius = 8 + Math.floor(Math.random() * 6);

                // æŒ–å‡ºé™¨çŸ³å‘
                for (let dx = -craterRadius; dx <= craterRadius; dx++) {
                    const x = cx + dx;
                    if (x < 0 || x >= this.w) continue;

                    const depth = Math.floor(Math.sqrt(craterRadius * craterRadius - dx * dx) * 0.7);
                    for (let dy = -2; dy < depth; dy++) {
                        const y = groundY + dy;
                        if (y >= 0 && y < this.h) {
                            tiles[x][y] = BLOCK.AIR;
                        }
                    }
                }

                // å¡«å……é™¨çŸ³
                for (let dx = -craterRadius + 2; dx <= craterRadius - 2; dx++) {
                    const x = cx + dx;
                    if (x < 0 || x >= this.w) continue;

                    const meteoriteHeight = Math.floor(Math.sqrt((craterRadius - 2) * (craterRadius - 2) - dx * dx) * 0.5);
                    for (let dy = 0; dy < meteoriteHeight; dy++) {
                        const y = groundY + Math.floor(craterRadius * 0.5) - dy;
                        if (y >= 0 && y < this.h && Math.random() > 0.15) {
                            tiles[x][y] = BLOCK.METEORITE;
                        }
                    }
                }
            }

            _createBeehive(tiles, walls, cx, cy) {
                const w = 12 + Math.floor(Math.random() * 8);
                const h = 8 + Math.floor(Math.random() * 6);

                for (let dx = -w / 2; dx < w / 2; dx++) {
                    for (let dy = -h / 2; dy < h / 2; dy++) {
                        const x = Math.floor(cx + dx);
                        const y = Math.floor(cy + dy);
                        if (x < 0 || x >= this.w || y < 0 || y >= this.h) continue;

                        const dist = Math.sqrt((dx / (w / 2)) ** 2 + (dy / (h / 2)) ** 2);
                        if (dist < 0.85) {
                            if (dist > 0.7) {
                                tiles[x][y] = BLOCK.HIVE;
                            } else if (Math.random() > 0.6) {
                                tiles[x][y] = BLOCK.HONEY_BLOCK;
                            } else {
                                tiles[x][y] = BLOCK.AIR;
                            }
                            walls[x][y] = 1;
                        }
                    }
                }

                // ä¸­å¿ƒèœ‚çª
                if (cx >= 0 && cx < this.w && cy >= 0 && cy < this.h) {
                    tiles[cx][cy] = BLOCK.BEE_NEST;
                }
            }

            _createSpiderNest(tiles, walls, cx, cy) {
                const radius = 6 + Math.floor(Math.random() * 5);

                // æŒ–ç©ºåŒºåŸŸ
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const x = cx + dx;
                        const y = cy + dy;
                        if (x < 0 || x >= this.w || y < 0 || y >= this.h) continue;

                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < radius * 0.9) {
                            tiles[x][y] = BLOCK.AIR;
                            walls[x][y] = 2;
                        }
                    }
                }

                // æ·»åŠ èœ˜è››ç½‘
                for (let i = 0; i < radius * 3; i++) {
                    const wx = cx + Math.floor((Math.random() - 0.5) * radius * 1.5);
                    const wy = cy + Math.floor((Math.random() - 0.5) * radius * 1.5);
                    if (wx >= 0 && wx < this.w && wy >= 0 && wy < this.h) {
                        if (tiles[wx][wy] === BLOCK.AIR) {
                            tiles[wx][wy] = BLOCK.SPIDER_WEB;
                        }
                    }
                }

                // ä¸­å¿ƒèœ˜è››å·¢
                if (cx >= 0 && cx < this.w && cy >= 0 && cy < this.h) {
                    tiles[cx][cy] = BLOCK.SPIDER_NEST;
                }
            }

            _createLivingTree(tiles, walls, cx) {
                let groundY = 0;
                for (let y = 0; y < this.h; y++) {
                    if (tiles[cx][y] !== BLOCK.AIR) { groundY = y; break; }
                }
                if (!groundY || groundY > this.h * 0.4) return;

                const trunkWidth = 4 + Math.floor(Math.random() * 3);
                const trunkHeight = 25 + Math.floor(Math.random() * 20);
                const rootDepth = 15 + Math.floor(Math.random() * 10);

                // æ ‘å¹²
                for (let dx = -trunkWidth / 2; dx < trunkWidth / 2; dx++) {
                    const x = Math.floor(cx + dx);
                    if (x < 0 || x >= this.w) continue;

                    for (let dy = 1; dy <= trunkHeight; dy++) {
                        const y = groundY - dy;
                        if (y >= 0) {
                            tiles[x][y] = BLOCK.LIVING_WOOD;
                        }
                    }
                }

                // æ ‘æ ¹ (å‘ä¸‹å»¶ä¼¸)
                for (let dx = -trunkWidth / 2; dx < trunkWidth / 2; dx++) {
                    const x = Math.floor(cx + dx);
                    if (x < 0 || x >= this.w) continue;

                    for (let dy = 0; dy < rootDepth; dy++) {
                        const y = groundY + dy;
                        if (y < this.h) {
                            tiles[x][y] = BLOCK.LIVING_WOOD;
                            walls[x][y] = 1;
                        }
                    }
                }

                // åœ°ä¸‹æˆ¿é—´
                const roomY = groundY + Math.floor(rootDepth / 2);
                const roomW = 6 + Math.floor(Math.random() * 4);
                const roomH = 5 + Math.floor(Math.random() * 3);

                for (let dx = -roomW / 2; dx < roomW / 2; dx++) {
                    for (let dy = -roomH / 2; dy < roomH / 2; dy++) {
                        const x = Math.floor(cx + dx);
                        const y = Math.floor(roomY + dy);
                        if (x >= 0 && x < this.w && y >= 0 && y < this.h) {
                            tiles[x][y] = BLOCK.AIR;
                            walls[x][y] = 1;
                        }
                    }
                }

                // å®ç®±
                if (cx >= 0 && cx < this.w && roomY >= 0 && roomY < this.h) {
                    tiles[cx][Math.floor(roomY + roomH / 2 - 1)] = BLOCK.TREASURE_CHEST;
                    tiles[cx][Math.floor(roomY - roomH / 2 + 1)] = BLOCK.LANTERN;
                }

                // æ ‘å† 
                const canopyRadius = trunkWidth + 4 + Math.floor(Math.random() * 3);
                for (let dx = -canopyRadius; dx <= canopyRadius; dx++) {
                    for (let dy = -canopyRadius; dy <= 2; dy++) {
                        const x = cx + dx;
                        const y = groundY - trunkHeight + dy;
                        if (x < 0 || x >= this.w || y < 0) continue;

                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= canopyRadius && tiles[x][y] === BLOCK.AIR && Math.random() > 0.2) {
                            tiles[x][y] = BLOCK.LIVING_LEAF;
                        }
                    }
                }
            }

            _createPyramids(tiles, walls) {
                // æ‰¾æ²™æ¼ åŒºåŸŸ
                for (let x = 50; x < this.w - 50; x += 80) {
                    const biome = this._biome(x);
                    if (biome !== 'desert' && biome !== 'red_desert') continue;
                    if (Math.random() > 0.4) continue;

                    let groundY = 0;
                    for (let y = 0; y < this.h; y++) {
                        if (tiles[x][y] !== BLOCK.AIR) { groundY = y; break; }
                    }
                    if (!groundY) continue;

                    const pyramidW = 30 + Math.floor(Math.random() * 20);
                    const pyramidH = Math.floor(pyramidW * 0.6);

                    // é‡‘å­—å¡”å¤–å£³
                    for (let layer = 0; layer < pyramidH; layer++) {
                        const layerW = pyramidW - layer * 2;
                        const y = groundY - layer;
                        if (y < 0) break;

                        for (let dx = -layerW / 2; dx < layerW / 2; dx++) {
                            const px = Math.floor(x + dx);
                            if (px >= 0 && px < this.w) {
                                tiles[px][y] = BLOCK.SANDSTONE;
                            }
                        }
                    }

                    // å†…éƒ¨é€šé“å’Œæˆ¿é—´
                    const corridorY = groundY - Math.floor(pyramidH / 3);
                    const roomY = groundY - Math.floor(pyramidH / 2);

                    // å…¥å£é€šé“
                    for (let dy = 0; dy < pyramidH / 2; dy++) {
                        const y = groundY - dy;
                        if (y >= 0 && tiles[x][y] !== BLOCK.AIR) {
                            tiles[x][y] = BLOCK.AIR;
                            if (x - 1 >= 0) tiles[x - 1][y] = BLOCK.AIR;
                        }
                    }

                    // å®è—å®¤
                    const treasureRoomW = 8;
                    const treasureRoomH = 6;
                    for (let dx = -treasureRoomW / 2; dx < treasureRoomW / 2; dx++) {
                        for (let dy = -treasureRoomH / 2; dy < treasureRoomH / 2; dy++) {
                            const px = Math.floor(x + dx);
                            const py = Math.floor(roomY + dy);
                            if (px >= 0 && px < this.w && py >= 0 && py < this.h) {
                                tiles[px][py] = BLOCK.AIR;
                                walls[px][py] = 1;
                            }
                        }
                    }

                    // å®ç®±å’Œè£…é¥°
                    if (x >= 0 && x < this.w && roomY >= 0 && roomY < this.h) {
                        tiles[x][Math.floor(roomY + treasureRoomH / 2 - 1)] = BLOCK.TREASURE_CHEST;
                        tiles[x - 2][Math.floor(roomY + treasureRoomH / 2 - 1)] = BLOCK.GOLD_BRICK;
                        tiles[x + 2][Math.floor(roomY + treasureRoomH / 2 - 1)] = BLOCK.GOLD_BRICK;
                    }
                }
            }

            _createJungleTemple(tiles, walls, cx, cy) {
                const w = 40 + Math.floor(Math.random() * 20);
                const h = 30 + Math.floor(Math.random() * 15);

                const wallBlock = BLOCK.LIHZAHRD_BRICK;

                // å¤–å¢™
                for (let dx = 0; dx < w; dx++) {
                    for (let dy = 0; dy < h; dy++) {
                        const x = cx + dx;
                        const y = cy + dy;
                        if (x >= this.w || y >= this.h) continue;

                        const isWall = dx < 3 || dx >= w - 3 || dy < 3 || dy >= h - 3;
                        tiles[x][y] = isWall ? wallBlock : BLOCK.AIR;
                        if (!isWall) walls[x][y] = 2;
                    }
                }

                // å†…éƒ¨éš”å¢™
                for (let i = 0; i < 5; i++) {
                    const wx = cx + 5 + Math.floor(Math.random() * (w - 10));
                    const wy = cy + 5;
                    const wh = Math.floor(Math.random() * (h - 10));

                    for (let dy = 0; dy < wh; dy++) {
                        if (wx < this.w && wy + dy < this.h) {
                            tiles[wx][wy + dy] = wallBlock;
                        }
                    }
                }

                // æœºå…³å’Œå®è—
                const treasureX = cx + Math.floor(w / 2);
                const treasureY = cy + h - 5;
                if (treasureX < this.w && treasureY < this.h) {
                    tiles[treasureX][treasureY] = BLOCK.TREASURE_CHEST;
                    tiles[treasureX][cy + 4] = BLOCK.LANTERN;
                }

                // ç¥­å›
                const altarX = cx + Math.floor(w / 2);
                const altarY = cy + Math.floor(h / 2);
                if (altarX < this.w && altarY < this.h) {
                    tiles[altarX][altarY] = BLOCK.ALTAR;
                }
            }

            _createSkyIslandChain(tiles, walls) {
                const chainCount = 1 + Math.floor(Math.random() * 2);

                for (let c = 0; c < chainCount; c++) {
                    const startX = 100 + Math.floor(Math.random() * (this.w - 300));
                    const startY = 8 + Math.floor(Math.random() * 12);
                    const islandCount = 3 + Math.floor(Math.random() * 4);

                    let currentX = startX;
                    let currentY = startY;

                    for (let i = 0; i < islandCount; i++) {
                        const iw = 15 + Math.floor(Math.random() * 15);
                        const ih = 5 + Math.floor(Math.random() * 4);

                        // äº‘å±‚åŸºç¡€
                        for (let dx = -iw / 2; dx < iw / 2; dx++) {
                            const x = Math.floor(currentX + dx);
                            if (x < 0 || x >= this.w) continue;

                            const edgeDist = Math.min(dx + iw / 2, iw / 2 - dx) / (iw / 2);
                            const height = Math.floor(ih * edgeDist);

                            for (let dy = 0; dy < height; dy++) {
                                const y = currentY + dy;
                                if (y >= 0 && y < this.h) {
                                    if (dy === 0) {
                                        tiles[x][y] = BLOCK.SUNPLATE;
                                    } else if (dy < 2) {
                                        tiles[x][y] = BLOCK.CLOUD;
                                    } else {
                                        tiles[x][y] = Math.random() > 0.5 ? BLOCK.CLOUD : BLOCK.RAIN_CLOUD;
                                    }
                                }
                            }
                        }

                        // å²›ä¸Šå»ºç­‘
                        if (Math.random() > 0.4) {
                            const houseX = Math.floor(currentX);
                            const houseY = currentY - 1;
                            if (houseX >= 0 && houseX < this.w && houseY >= 0) {
                                // å°æˆ¿å­
                                for (let hdx = -3; hdx <= 3; hdx++) {
                                    for (let hdy = 0; hdy < 4; hdy++) {
                                        const hx = houseX + hdx;
                                        const hy = houseY - hdy;
                                        if (hx >= 0 && hx < this.w && hy >= 0) {
                                            if (hdx === -3 || hdx === 3 || hdy === 0 || hdy === 3) {
                                                tiles[hx][hy] = BLOCK.SUNPLATE;
                                            } else {
                                                tiles[hx][hy] = BLOCK.AIR;
                                            }
                                        }
                                    }
                                }
                                tiles[houseX][houseY] = BLOCK.TREASURE_CHEST;
                            }
                        }

                        currentX += iw + 10 + Math.floor(Math.random() * 15);
                        currentY += Math.floor(Math.random() * 5) - 2;
                        currentY = Utils.clamp(currentY, 5, 25);
                    }
                }
            }

            _createMushroomBiome(tiles, walls) {
                const biomeCount = 1 + Math.floor(Math.random() * 2);

                for (let b = 0; b < biomeCount; b++) {
                    const cx = 100 + Math.floor(Math.random() * (this.w - 200));
                    const cy = Math.floor(this.h * (0.55 + Math.random() * 0.15));
                    const radius = 30 + Math.floor(Math.random() * 25);

                    // è½¬æ¢åŒºåŸŸä¸ºè˜‘è‡ç”Ÿæ€
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            const x = cx + dx;
                            const y = cy + dy;
                            if (x < 0 || x >= this.w || y < 0 || y >= this.h) continue;

                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > radius) continue;

                            const block = tiles[x][y];

                            // è½¬æ¢æ–¹å—
                            if (block === BLOCK.STONE) {
                                tiles[x][y] = Math.random() > 0.3 ? BLOCK.MUSHROOM_GRASS : block;
                            } else if (block === BLOCK.DIRT) {
                                tiles[x][y] = BLOCK.MUD;
                            }

                            // åœ¨ç©ºæ°”ä¸­ç”Ÿæˆè˜‘è‡
                            if (block === BLOCK.AIR && y + 1 < this.h && BLOCK_DATA[tiles[x][y + 1]]?.solid) {
                                if (Math.random() > 0.9) {
                                    tiles[x][y] = BLOCK.UNDERGROUND_MUSHROOM;
                                }
                            }
                        }
                    }

                    // å·¨å‹è˜‘è‡
                    for (let i = 0; i < 5 + Math.floor(Math.random() * 5); i++) {
                        const mx = cx + Math.floor((Math.random() - 0.5) * radius);
                        const my = cy + Math.floor((Math.random() - 0.5) * radius);
                        if (mx >= 0 && mx < this.w && my >= 0 && my < this.h) {
                            if (tiles[mx][my] === BLOCK.AIR && my + 1 < this.h && BLOCK_DATA[tiles[mx][my + 1]]?.solid) {
                                this._placeGiantMushroom(tiles, mx, my);
                            }
                        }
                    }
                }
            }

            _createEvilBiome(tiles, walls) {
                const isCrimson = Math.random() > 0.5;
                const stoneType = isCrimson ? BLOCK.CRIMSON_STONE : BLOCK.EBONSTONE;
                const altarType = isCrimson ? BLOCK.CRIMSON_ALTAR : BLOCK.DEMON_ALTAR;

                // åœ¨ä¸–ç•Œä¸€ä¾§åˆ›å»ºé‚ªæ¶ç”Ÿæ€
                const side = Math.random() > 0.5 ? 'left' : 'right';
                const startX = side === 'left' ? 30 : this.w - 80;
                const endX = side === 'left' ? 80 : this.w - 30;

                for (let x = startX; x < endX; x++) {
                    for (let y = Math.floor(this.h * 0.25); y < this.h * 0.85; y++) {
                        if (x < 0 || x >= this.w) continue;

                        const block = tiles[x][y];

                        if (block === BLOCK.STONE || block === BLOCK.GRANITE || block === BLOCK.SLATE) {
                            if (Math.random() > 0.3) {
                                tiles[x][y] = stoneType;
                            }
                        } else if (block === BLOCK.GRASS) {
                            tiles[x][y] = isCrimson ? BLOCK.CRIMSON_STONE : BLOCK.CORRUPTION_STONE;
                        }
                    }
                }

                // æ”¾ç½®ç¥­å›
                for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                    const ax = startX + Math.floor(Math.random() * (endX - startX));
                    const ay = Math.floor(this.h * (0.4 + Math.random() * 0.3));
                    if (ax >= 0 && ax < this.w && ay >= 0 && ay < this.h) {
                        if (tiles[ax][ay] === BLOCK.AIR || tiles[ax][ay] === stoneType) {
                            tiles[ax][ay] = altarType;
                        }
                    }
                }
            }

            _createHallowBiome(tiles, walls) {
                // åœ¨ä¸–ç•Œå¦ä¸€ä¾§åˆ›å»ºç¥åœ£ç”Ÿæ€
                const cx = Math.floor(this.w * 0.7);
                const radius = 40 + Math.floor(Math.random() * 20);

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let y = Math.floor(this.h * 0.25); y < this.h * 0.75; y++) {
                        const x = cx + dx;
                        if (x < 0 || x >= this.w) continue;

                        const dist = Math.abs(dx) / radius;
                        if (dist > 1 || Math.random() > (1 - dist * 0.5)) continue;

                        const block = tiles[x][y];

                        if (block === BLOCK.STONE) {
                            tiles[x][y] = Math.random() > 0.5 ? BLOCK.PEARLSTONE : BLOCK.HALLOW_STONE;
                        } else if (block === BLOCK.GRASS) {
                            tiles[x][y] = BLOCK.HALLOW_STONE;
                        } else if (block === BLOCK.SAND) {
                            tiles[x][y] = BLOCK.PEARLSTONE;
                        }
                    }
                }
            }

            _createOceans(tiles, walls) {
                // å·¦ä¾§æµ·æ´‹
                this._createOcean(tiles, 0, 60, true);
                // å³ä¾§æµ·æ´‹
                this._createOcean(tiles, this.w - 60, this.w, false);
            }

            _createOcean(tiles, startX, endX, isLeft) {
                const surfY = Math.floor(this.h * CONFIG.SURFACE_LEVEL);
                const oceanDepth = 20 + Math.floor(Math.random() * 15);

                for (let x = startX; x < endX; x++) {
                    if (x < 0 || x >= this.w) continue;

                    // æ‰¾åœ°è¡¨
                    let groundY = surfY;
                    for (let y = 0; y < this.h; y++) {
                        if (tiles[x][y] !== BLOCK.AIR) { groundY = y; break; }
                    }

                    // æŒ–æ·±å¹¶å¡«æ°´
                    const depth = oceanDepth * (isLeft ? (endX - x) / (endX - startX) : (x - startX) / (endX - startX));

                    for (let dy = 0; dy < depth; dy++) {
                        const y = groundY + dy;
                        if (y >= this.h) break;

                        tiles[x][y] = BLOCK.WATER;
                    }

                    // æµ·åº•æ²™å­
                    for (let dy = Math.floor(depth); dy < Math.floor(depth) + 5; dy++) {
                        const y = groundY + dy;
                        if (y >= this.h) break;
                        tiles[x][y] = BLOCK.SAND;
                    }

                    // æµ·è‰å’Œæµ·å¸¦
                    if (Math.random() > 0.85) {
                        const seaY = groundY + Math.floor(depth) - 1;
                        if (seaY >= 0 && seaY < this.h && tiles[x][seaY] === BLOCK.WATER) {
                            tiles[x][seaY] = Math.random() > 0.5 ? BLOCK.SEAWEED : BLOCK.KELP;
                        }
                    }

                    // çŠç‘š
                    if (Math.random() > 0.92) {
                        const coralY = groundY + Math.floor(depth);
                        if (coralY >= 0 && coralY < this.h) {
                            tiles[x][coralY] = BLOCK.CORAL;
                        }
                    }
                }
            }

            _distributeHerbs(tiles) {
                const herbs = [
                    { id: BLOCK.DAYBLOOM, biomes: ['plains', 'forest'], surface: true },
                    { id: BLOCK.MOONGLOW, biomes: ['jungle', 'bamboo'], underground: true },
                    { id: BLOCK.BLINKROOT, biomes: ['all'], underground: true },
                    { id: BLOCK.WATERLEAF, biomes: ['desert', 'red_desert'], surface: true },
                    { id: BLOCK.FIREBLOSSOM, biomes: ['all'], hell: true },
                    { id: BLOCK.SHIVERTHORN, biomes: ['snow', 'tundra'], surface: true },
                    { id: BLOCK.DEATHWEED, biomes: ['all'], underground: true }
                ];

                for (let x = 10; x < this.w - 10; x++) {
                    const biome = this._biome(x);

                    for (const herb of herbs) {
                        if (herb.biomes[0] !== 'all' && !herb.biomes.includes(biome)) continue;
                        if (Math.random() > 0.005) continue;

                        let startY, endY;
                        if (herb.surface) {
                            startY = 0;
                            endY = Math.floor(this.h * 0.35);
                        } else if (herb.underground) {
                            startY = Math.floor(this.h * 0.35);
                            endY = Math.floor(this.h * 0.85);
                        } else if (herb.hell) {
                            startY = Math.floor(this.h * 0.9);
                            endY = this.h - 5;
                        }

                        for (let y = startY; y < endY; y++) {
                            if (tiles[x][y] === BLOCK.AIR && y + 1 < this.h && BLOCK_DATA[tiles[x][y + 1]]?.solid) {
                                tiles[x][y] = herb.id;
                                break;
                            }
                        }
                    }
                }
            }

            _placeLifeCrystals(tiles) {
                const crystalCount = 15 + Math.floor(Math.random() * 10);

                for (let i = 0; i < crystalCount; i++) {
                    const x = 50 + Math.floor(Math.random() * (this.w - 100));
                    const y = Math.floor(this.h * (0.4 + Math.random() * 0.4));

                    if (x >= 0 && x < this.w && y >= 0 && y < this.h) {
                        if (tiles[x][y] === BLOCK.AIR && y + 1 < this.h && BLOCK_DATA[tiles[x][y + 1]]?.solid) {
                            tiles[x][y] = Math.random() > 0.7 ? BLOCK.HEART_CRYSTAL : BLOCK.LIFE_CRYSTAL;
                        }
                    }
                }

                // é­”åŠ›æ°´æ™¶
                const manaCount = 10 + Math.floor(Math.random() * 8);
                for (let i = 0; i < manaCount; i++) {
                    const x = 50 + Math.floor(Math.random() * (this.w - 100));
                    const y = Math.floor(this.h * (0.5 + Math.random() * 0.35));

                    if (x >= 0 && x < this.w && y >= 0 && y < this.h) {
                        if (tiles[x][y] === BLOCK.AIR) {
                            tiles[x][y] = BLOCK.MANA_CRYSTAL;
                        }
                    }
                }
            }

            _createDungeon(tiles, walls, startX, startY) {
                const roomCount = 4 + Math.floor(Math.random() * 4);
                const rooms = [];

                // ç”Ÿæˆæˆ¿é—´
                let lastRoom = { x: startX, y: startY, w: 8, h: 6 };
                rooms.push(lastRoom);

                for (let i = 1; i < roomCount; i++) {
                    const dir = Math.floor(Math.random() * 4);
                    let nx = lastRoom.x, ny = lastRoom.y;
                    const nw = 6 + Math.floor(Math.random() * 5);
                    const nh = 5 + Math.floor(Math.random() * 4);

                    switch (dir) {
                        case 0: nx = lastRoom.x + lastRoom.w + 5 + Math.floor(Math.random() * 8); break;
                        case 1: nx = lastRoom.x - nw - 5 - Math.floor(Math.random() * 8); break;
                        case 2: ny = lastRoom.y + lastRoom.h + 3 + Math.floor(Math.random() * 5); break;
                        case 3: ny = lastRoom.y - nh - 3 - Math.floor(Math.random() * 5); break;
                    }

                    if (nx < 10 || nx + nw >= this.w - 10 || ny < this.h * 0.35 || ny + nh >= this.h - 10) continue;

                    const newRoom = { x: nx, y: ny, w: nw, h: nh };
                    rooms.push(newRoom);

                    // è¿æ¥èµ°å»Š
                    this._createCorridor(tiles, walls, lastRoom, newRoom);
                    lastRoom = newRoom;
                }

                // ç»˜åˆ¶æˆ¿é—´
                const wallBlock = BLOCK.BRICK;
                for (const room of rooms) {
                    for (let dx = 0; dx < room.w; dx++) {
                        for (let dy = 0; dy < room.h; dy++) {
                            const tx = room.x + dx, ty = room.y + dy;
                            if (tx >= this.w || ty >= this.h || tx < 0 || ty < 0) continue;

                            const isWall = dx === 0 || dx === room.w - 1 || dy === 0 || dy === room.h - 1;
                            tiles[tx][ty] = isWall ? wallBlock : BLOCK.AIR;
                            if (!isWall) walls[tx][ty] = 2;
                        }
                    }

                    // æˆ¿é—´è£…é¥°
                    const midX = room.x + Math.floor(room.w / 2);
                    const floorY = room.y + room.h - 2;

                    if (midX < this.w && room.y + 1 < this.h) {
                        tiles[midX][room.y + 1] = BLOCK.LANTERN;
                    }

                    // éšæœºæ”¾ç½®ç‰©å“
                    if (Math.random() > 0.4) {
                        const itemX = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
                        if (itemX < this.w && floorY < this.h && tiles[itemX][floorY] === BLOCK.AIR) {
                            const r = Math.random();
                            if (r > 0.7) tiles[itemX][floorY] = BLOCK.TREASURE_CHEST;
                            else if (r > 0.4) tiles[itemX][floorY] = BLOCK.CRYSTAL;
                            else tiles[itemX][floorY] = BLOCK.BONE;
                        }
                    }

                    // èœ˜è››ç½‘
                    if (Math.random() > 0.5) {
                        for (let i = 0; i < 3; i++) {
                            const wx = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
                            const wy = room.y + 1 + Math.floor(Math.random() * 2);
                            if (wx < this.w && wy < this.h && tiles[wx][wy] === BLOCK.AIR) {
                                tiles[wx][wy] = BLOCK.SPIDER_WEB;
                            }
                        }
                    }
                }
            }

            _createCorridor(tiles, walls, room1, room2) {
                const x1 = Math.floor(room1.x + room1.w / 2);
                const y1 = Math.floor(room1.y + room1.h / 2);
                const x2 = Math.floor(room2.x + room2.w / 2);
                const y2 = Math.floor(room2.y + room2.h / 2);

                let cx = x1, cy = y1;

                // å…ˆæ°´å¹³åå‚ç›´
                while (cx !== x2) {
                    if (cx >= 0 && cx < this.w && cy >= 0 && cy < this.h) {
                        tiles[cx][cy] = BLOCK.AIR;
                        if (cy - 1 >= 0) tiles[cx][cy - 1] = BLOCK.AIR;
                        if (cy + 1 < this.h) tiles[cx][cy + 1] = BLOCK.AIR;
                        walls[cx][cy] = 2;
                    }
                    cx += cx < x2 ? 1 : -1;
                }

                while (cy !== y2) {
                    if (cx >= 0 && cx < this.w && cy >= 0 && cy < this.h) {
                        tiles[cx][cy] = BLOCK.AIR;
                        if (cx - 1 >= 0) tiles[cx - 1][cy] = BLOCK.AIR;
                        if (cx + 1 < this.w) tiles[cx + 1][cy] = BLOCK.AIR;
                        walls[cx][cy] = 2;
                    }
                    cy += cy < y2 ? 1 : -1;
                }
            }

            _lighting(tiles, light) {
                // é˜³å…‰ï¼ˆå‚ç›´ç›´å°„ï¼‰+ æ”¶é›†å…‰æº
                const w = this.w, h = this.h;
                const srcX = [];
                const srcY = [];
                const srcL = [];

                for (let x = 0; x < w; x++) {
                    let sun = CONFIG.LIGHT_LEVELS;
                    const colTiles = tiles[x];
                    const colLight = light[x];

                    for (let y = 0; y < h; y++) {
                        const id = colTiles[y];

                        // SUN_DECAY: 0 / 1 / 3ï¼ˆä¸åŸè§„åˆ™ä¸€è‡´ï¼‰
                        const decay = SUN_DECAY[id];
                        if (decay) sun = sun > decay ? (sun - decay) : 0;

                        const bl = BLOCK_LIGHT[id];
                        const v = sun > bl ? sun : bl;
                        colLight[y] = v;

                        // åªæ‰©æ•£â€œæ–¹å—å…‰æºâ€ï¼Œä¸æ‰©æ•£å¤ªé˜³å…‰ï¼ˆä¿æŒæ—§æ•ˆæœï¼šå¤ªé˜³å…‰åªå‘ä¸‹ç›´å°„ï¼‰
                        if (bl > 0) {
                            srcX.push(x);
                            srcY.push(y);
                            srcL.push(bl);
                        }
                    }
                }

                // å¤šå…‰æºä¸€æ¬¡æ€§æ‰©æ•£ï¼ˆæ¯”é€ä¸ªå…‰æº BFS æ›´å¿«ï¼Œä¸”æ— éœ€ visited Set / queue.shiftï¼‰
                if (srcX.length) this._spreadLights(tiles, light, srcX, srcY, srcL);
            }

            _spreadLights(tiles, light, srcX, srcY, srcL) {
                const w = this.w, h = this.h;

                // å¤ç”¨æ•°ç»„é˜Ÿåˆ—ï¼ˆé¿å…å¯¹è±¡åˆ†é…ï¼‰
                const qx = [];
                const qy = [];
                const ql = [];
                let head = 0;

                for (let i = 0; i < srcX.length; i++) {
                    qx.push(srcX[i]);
                    qy.push(srcY[i]);
                    ql.push(srcL[i]);
                }

                while (head < qx.length) {
                    const x = qx[head];
                    const y = qy[head];
                    const l = ql[head];
                    head++;

                    if (l <= 0 || x < 0 || x >= w || y < 0 || y >= h) continue;

                    const colLight = light[x];
                    if (l <= colLight[y]) continue; // ä¸ä¼šå˜äº®å°±ä¸ä¼ æ’­ï¼Œå¤©ç„¶å»é‡
                    colLight[y] = l;

                    const nl = l - (BLOCK_SOLID[tiles[x][y]] ? 2 : 1);
                    if (nl > 0) {
                        // push é¡ºåºä¸æ—§å®ç°ä¸€è‡´ï¼šleft, right, up, down
                        qx.push(x - 1, x + 1, x, x);
                        qy.push(y, y, y - 1, y + 1);
                        ql.push(nl, nl, nl, nl);
                    }
                }
            }

        }

        WorldGenerator.prototype._weldStructuresFromLibrary = function (tiles, walls) {
            const lib = TU.Structures;
            if (!lib) return;
            lib.ensureLoaded();
            if (!lib.count || !lib.count()) return;

            const w = this.w, h = this.h;

            const randInt = (a, b) => (a + Math.floor(Math.random() * (b - a + 1))) | 0;
            const clampI = (n, lo, hi) => (n < lo ? lo : (n > hi ? hi : n)) | 0;

            const groundYAt = (x) => {
                if (x < 0 || x >= w) return -1;
                const col = tiles[x];
                for (let y = 0; y < h; y++) {
                    if (col[y] !== BLOCK.AIR) return y;
                }
                return -1;
            };

            const tryPlace = (desc, anchorX, anchorY) => {
                if (!desc) return false;
                const tlx = (anchorX - Math.floor(desc.w * desc.anchor[0])) | 0;
                const tly = (anchorY - Math.floor(desc.h * desc.anchor[1])) | 0;

                // v11-safe bounds: keep a 1-tile margin to reduce edge-cases
                if (tlx < 1 || tly < 1 || tlx + desc.w >= w - 1 || tly + desc.h >= h - 1) return false;

                // è½»é‡é‡‡æ ·ç¢°æ’æ£€æµ‹ï¼šåœ°ä¸‹ç»“æ„è¦æ±‚ä¸€å®šæ¯”ä¾‹çš„â€œå›ºä½“â€
                const needSolid = desc.placement.mode !== 'surface';
                const minSolid = desc.placement.minSolidRatio || 0;
                if (needSolid && minSolid > 0) {
                    const samples = 36;
                    let solid = 0;
                    for (let i = 0; i < samples; i++) {
                        const sx = tlx + randInt(0, desc.w - 1);
                        const sy = tly + randInt(0, desc.h - 1);
                        const id = tiles[sx][sy];
                        if (BLOCK_SOLID[id]) solid++;
                    }
                    if (solid / samples < minSolid) return false;
                }

                // å†™å…¥ç»“æ„ï¼ˆgrid/legendï¼‰
                const defWall = (desc.placement.defaultWall | 0) & 255;

                for (let gy = 0; gy < desc.h; gy++) {
                    const row = desc.grid[gy];
                    const yy = tly + gy;
                    if (yy < 0 || yy >= h) continue;

                    for (let gx = 0; gx < desc.w; gx++) {
                        const xx = tlx + gx;
                        if (xx < 0 || xx >= w) continue;

                        const ch = row[gx];
                        if (ch === ' ') continue;

                        const rule = desc.legend[ch];
                        if (!rule) continue;
                        if (rule.chance < 1 && Math.random() > rule.chance) continue;

                        const cur = tiles[xx][yy];
                        if (rule.replace === 'air' && cur !== BLOCK.AIR) continue;
                        if (rule.replace === 'solid' && !BLOCK_SOLID[cur]) continue;

                        if (rule.tile !== null && rule.tile !== undefined) {
                            tiles[xx][yy] = rule.tile & 255;
                            if ((rule.tile & 255) === BLOCK.AIR && defWall) walls[xx][yy] = defWall;
                        }
                        if (rule.wall !== null && rule.wall !== undefined) {
                            walls[xx][yy] = rule.wall & 255;
                        }
                    }
                }

                // â€œç„Šæ¥â€ï¼šä»è¿æ¥ç‚¹å‘å¤–æŒ–æ˜çŸ­é€šé“ï¼Œå°½é‡è¿åˆ°å·²æœ‰ç©ºè…”
                if (desc.connectors && desc.connectors.length) {
                    for (let i = 0; i < desc.connectors.length; i++) {
                        const c = desc.connectors[i];
                        const cx = tlx + c.x;
                        const cy = tly + c.y;
                        if (cx < 1 || cx >= w - 1 || cy < 1 || cy >= h - 1) continue;

                        if (c.carve) {
                            const wallId = (c.wall === null || c.wall === undefined) ? defWall : (c.wall & 255);
                            this._carveConnectorTunnel(tiles, walls, cx, cy, c.dir, c.len, wallId);
                        }
                    }
                }
                return true;
            };

            // è®¡åˆ’ï¼šæŒ‰æ·±åº¦åˆ†å¸ƒè‡ªåŠ¨æŠ½å–ç»“æ„
            const scale = Math.max(1, (w / 260));
            const plan = [
                { tag: 'tree', count: randInt(3, 6) * scale, depth: [0.08, 0.32] },
                { tag: 'ruin', count: randInt(6, 10) * scale, depth: [0.34, 0.72] },
                { tag: 'dungeon', count: randInt(8, 14) * scale, depth: [0.60, 0.92] }
            ];

            for (let p = 0; p < plan.length; p++) {
                const { tag, count, depth } = plan[p];
                const triesPer = 12;

                for (let i = 0; i < count; i++) {
                    const dn = depth[0] + Math.random() * (depth[1] - depth[0]);
                    const desc = lib.pick(dn, tag) || lib.pick(dn, [tag, 'room']);

                    let placed = false;
                    for (let t = 0; t < triesPer && !placed; t++) {
                        const x = randInt(20, w - 21);

                        let y;
                        if (desc && desc.placement.mode === 'surface') {
                            const gy = groundYAt(x);
                            if (gy < 0 || gy > h * 0.55) continue;
                            y = gy - 1;
                        } else {
                            y = clampI((dn * h) | 0, 10, h - 11);
                            y += randInt(-12, 12);
                            y = clampI(y, 10, h - 11);
                        }
                        placed = tryPlace(desc, x, y);
                    }
                }
            }
        };

        WorldGenerator.prototype._carveConnectorTunnel = function (tiles, walls, x, y, dir, len, wallId) {
            const w = this.w, h = this.h;
            let dx = 0, dy = 0;
            switch (dir) {
                case 'left': dx = -1; break;
                case 'right': dx = 1; break;
                case 'up': dy = -1; break;
                case 'down': dy = 1; break;
                default: return;
            }

            // ä»è¿æ¥ç‚¹å¼€å§‹å‘å¤–â€œæ‰¾ç©ºè…”â€ï¼šæœ€å¤š len æ ¼ï¼›é‡åˆ°è¿ç»­ç©ºæ°”ï¼ˆå·²æœ‰æ´ç©´/é€šé“ï¼‰å°±åœ
            let ax = x, ay = y;
            let airStreak = 0;
            for (let i = 0; i < len; i++) {
                ax += dx; ay += dy;
                if (ax < 1 || ax >= w - 1 || ay < 1 || ay >= h - 1) break;

                const cur = tiles[ax][ay];
                if (cur === BLOCK.AIR) {
                    airStreak++;
                    if (i > 3 && airStreak >= 2) break;
                } else {
                    airStreak = 0;
                }

                tiles[ax][ay] = BLOCK.AIR;
                if (wallId) walls[ax][ay] = wallId & 255;

                // åšä¸€ç‚¹ç‚¹å®½åº¦ï¼ˆé¿å… 1 æ ¼é€šé“å¤ªåˆ«æ‰­ï¼‰
                if (i > 1 && (dx !== 0)) {
                    if (ay - 1 > 0) { tiles[ax][ay - 1] = BLOCK.AIR; if (wallId) walls[ax][ay - 1] = wallId & 255; }
                    if (ay + 1 < h - 1) { tiles[ax][ay + 1] = BLOCK.AIR; if (wallId) walls[ax][ay + 1] = wallId & 255; }
                } else if (i > 1 && (dy !== 0)) {
                    if (ax - 1 > 0) { tiles[ax - 1][ay] = BLOCK.AIR; if (wallId) walls[ax - 1][ay] = wallId & 255; }
                    if (ax + 1 < w - 1) { tiles[ax + 1][ay] = BLOCK.AIR; if (wallId) walls[ax + 1][ay] = wallId & 255; }
                }
            }
        };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 10: Particles & Effects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class ParticleSystem {
            constructor(max = 400) {
                this.particles = [];
                this.max = max;

                // å¤ç”¨å¯¹è±¡ï¼Œé™ä½ GCï¼›head ç”¨äº O(1) â€œä¸¢å¼ƒæœ€æ—§ç²’å­â€ï¼ˆæ›¿ä»£ shiftï¼‰
                this._pool = [];
                this._head = 0;
            }

            emit(x, y, opts = {}) {
                const count = opts.count || 5;
                const baseSpeed = opts.speed || 3;
                const baseLife = opts.life || 1;
                const baseSize = opts.size || 4;
                const color = opts.color || '#fff';
                const gravity = opts.gravity || 0.1;
                const glow = opts.glow || false;

                for (let i = 0; i < count; i++) {
                    // ä¿æŒâ€œè¶…è¿‡ä¸Šé™å°±ç§»é™¤æœ€æ—§ç²’å­â€çš„åŸè¯­ä¹‰ï¼Œä½†é¿å… O(n) çš„ shift()
                    if ((this.particles.length - this._head) >= this.max) {
                        const old = this.particles[this._head++];
                        if (old) this._pool.push(old);
                    }

                    const angle = Math.random() * Math.PI * 2;
                    const speed = baseSpeed * (0.3 + Math.random() * 0.7);

                    const p = this._pool.pop() || {};
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed + (opts.up ? -speed : 0);
                    p.life = baseLife;
                    p.maxLife = baseLife;
                    p.color = color;
                    p.size = baseSize * (0.5 + Math.random() * 0.5);
                    p.gravity = gravity;
                    p.glow = glow;
                    p.rotation = Math.random() * Math.PI;
                    p.rotationSpeed = (Math.random() - 0.5) * 0.2;

                    this.particles.push(p);
                }
            }

            update(dtScale = 1) {
                // ç¨³å®šå‹ç¼©ï¼ˆä¿æŒæ¸²æŸ“é¡ºåºä¸å˜ï¼‰ï¼ŒåŒæ—¶æŠŠæ­»äº¡ç²’å­å›æ”¶åˆ° pool
                let write = 0;
                const arr = this.particles;

                for (let i = this._head; i < arr.length; i++) {
                    const p = arr[i];
                    if (!p) continue;

                    p.x += p.vx * dtScale;
                    p.y += p.vy * dtScale;
                    p.vy += p.gravity * dtScale;
                    p.vx *= Math.pow(0.98, dtScale);
                    p.life -= 0.02 * dtScale;
                    p.rotation += p.rotationSpeed * dtScale;

                    if (p.life > 0) {
                        arr[write++] = p;
                    } else {
                        this._pool.push(p);
                    }
                }

                arr.length = write;
                this._head = 0;
            }

            render(ctx, cam) {
                ctx.save();

                for (const p of this.particles) {
                    const px = p.x - cam.x;
                    const py = p.y - cam.y;

                    if (p.glow) {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 10;
                    }

                    ctx.globalAlpha = p.life * 0.8;
                    ctx.fillStyle = p.color;

                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(p.rotation);
                    const s = p.size * p.life;
                    ctx.fillRect(-s / 2, -s / 2, s, s);
                    ctx.restore();

                    ctx.shadowBlur = 0;
                }

                ctx.restore();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                 æ‰è½ç‰©ç³»ç»Ÿ

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { ParticleSystem });

        class DroppedItem {
            constructor(x, y, blockId, count = 1) {
                this.x = x;
                this.y = y;
                this.w = 12;
                this.h = 12;
                this.vx = (Math.random() - 0.5) * 4; // éšæœºæ°´å¹³é€Ÿåº¦
                this.vy = -3 - Math.random() * 2; // å‘ä¸Šå¼¹å‡º
                this.blockId = blockId;
                this.count = count;
                this.age = 0;
                this.maxAge = 60000; // 60ç§’åæ¶ˆå¤±
                this.bobOffset = Math.random() * Math.PI * 2; // æµ®åŠ¨åŠ¨ç”»åç§»
                this.rotation = 0;
                this.grounded = false;
                this.pickupDelay = 500; // 500msåæ‰èƒ½æ‹¾å–ï¼Œé˜²æ­¢åˆšæŒ–æ˜å°±æ¡èµ·
                this.magnetRange = 48; // ç£å¸èŒƒå›´ï¼ˆåƒç´ ï¼‰
                this.pickupRange = 20; // æ‹¾å–èŒƒå›´ï¼ˆåƒç´ ï¼‰
                // æ‹¾å–åŠ¨ç”»çŠ¶æ€ï¼ˆå¯¹è±¡æ± å¤ç”¨æ—¶å¿…é¡»æ¸…ç†ï¼‰
                this._pickup = null;
                this._pickupAlpha = 1;
                this._pickupScale = 1;
            }

            // å¯¹è±¡æ± å¤ç”¨ï¼šé¿å…é¢‘ç¹ new/GCï¼ˆæ‰è½ç‰©å¯†é›†æ—¶æ˜æ˜¾æå‡æµç•…åº¦ï¼‰
            reset(x, y, blockId, count = 1) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = -3 - Math.random() * 2;
                this.blockId = blockId;
                this.count = count;
                this.age = 0;
                // maxAge / w / h ä¿æŒä¸å˜
                this.bobOffset = Math.random() * Math.PI * 2;
                this.rotation = 0;
                this.grounded = false;
                this.pickupDelay = 500;
                this.magnetRange = 48;
                this.pickupRange = 20;
                // æ¸…ç†æ‹¾å–åŠ¨ç”»æ®‹ç•™çŠ¶æ€ï¼ˆé¿å…å¯¹è±¡æ± å¤ç”¨å¯¼è‡´åç»­æ‰è½ç‰©ç¬é—´æ¶ˆå¤±/æ— æ³•æ‹¾å–ï¼‰
                this._pickup = null;
                this._pickupAlpha = 1;
                this._pickupScale = 1;
                return this;
            }

            update(world, player, dt) {
                this.age += dt;

                // è¶…æ—¶æ¶ˆå¤±
                if (this.age >= this.maxAge) {
                    return false; // è¿”å›falseè¡¨ç¤ºåº”è¯¥ç§»é™¤
                }

                // é‡åŠ›
                this.vy += CONFIG.GRAVITY * 0.5;
                this.vy = Math.min(this.vy, CONFIG.MAX_FALL_SPEED * 0.5);

                // æ‘©æ“¦åŠ›
                if (this.grounded) {
                    this.vx *= 0.85;
                } else {
                    this.vx *= 0.98;
                }

                // ç§»åŠ¨å’Œç¢°æ’
                this._moveCollide(world, this.vx, 0);
                this.grounded = false;
                this._moveCollide(world, 0, this.vy);

                // æ—‹è½¬ï¼ˆåªåœ¨ç©ºä¸­æ—‹è½¬ï¼‰
                if (!this.grounded) {
                    this.rotation += this.vx * 0.05;
                }

                // ç£å¸æ•ˆæœï¼šå½“ç©å®¶é è¿‘æ—¶ï¼Œæ‰è½ç‰©è¢«å¸å¼•
                if (this.age > this.pickupDelay) {
                    const dx = player.cx() - (this.x + this.w / 2);
                    const dy = player.cy() - (this.y + this.h / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // dist å¯èƒ½ä¸º 0ï¼ˆç©å®¶ä¸æ‰è½ç‰©ä¸­å¿ƒé‡åˆï¼‰ï¼Œé¿å…é™¤ä»¥ 0 å¯¼è‡´ NaN é€Ÿåº¦
                    if (dist > 1e-6 && dist < this.magnetRange) {
                        // è¶Šè¿‘å¸å¼•åŠ›è¶Šå¼º
                        const force = (1 - dist / this.magnetRange) * 0.5;
                        const inv = 1 / dist;
                        this.vx += dx * inv * force * 3;
                        this.vy += dy * inv * force * 3;
                        this.grounded = false; // è¢«å¸å¼•æ—¶å¯ä»¥é£èµ·æ¥
                    }
                }

                return true; // è¿”å›trueè¡¨ç¤ºç»§ç»­å­˜åœ¨
            }

            _moveCollide(world, dx, dy) {
                const ts = CONFIG.TILE_SIZE;

                // æ°´å¹³ç§»åŠ¨
                if (dx !== 0) {
                    this.x += dx;
                    if (this._collides(world)) {
                        this.x -= dx;
                        this.vx = -this.vx * 0.3; // åå¼¹
                    }
                }

                // å‚ç›´ç§»åŠ¨
                if (dy !== 0) {
                    this.y += dy;
                    if (this._collides(world)) {
                        this.y -= dy;
                        if (dy > 0) {
                            this.grounded = true;
                            this.vy = 0;
                        } else {
                            this.vy = 0;
                        }
                    }
                }

                // é˜²æ­¢æ‰å‡ºä¸–ç•Œè¾¹ç•Œ
                this.x = Utils.clamp(this.x, 0, world.w * ts - this.w);
                this.y = Utils.clamp(this.y, 0, world.h * ts - this.h);
            }

            _collides(world) {
                const ts = CONFIG.TILE_SIZE;
                const l = Math.floor(this.x / ts);
                const r = Math.floor((this.x + this.w - 0.001) / ts);
                const t = Math.floor(this.y / ts);
                const b = Math.floor((this.y + this.h - 0.001) / ts);

                for (let tx = l; tx <= r; tx++) {
                    if (tx < 0 || tx >= world.w) continue;
                    const col = world.tiles[tx];
                    for (let ty = t; ty <= b; ty++) {
                        if (ty < 0 || ty >= world.h) continue;
                        if (BLOCK_SOLID[col[ty]]) return true;
                    }
                }
                return false;
            }

            canPickup(player) {
                if (this.age < this.pickupDelay) return false;

                const dx = player.cx() - (this.x + this.w / 2);
                const dy = player.cy() - (this.y + this.h / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                return dist < this.pickupRange;
            }

            cx() { return this.x + this.w / 2; }
            cy() { return this.y + this.h / 2; }
        }

        class DroppedItemManager {
            constructor() {
                // ä½¿ç”¨â€œå¤´æŒ‡é’ˆ + ç©ºæ´â€æ¥é¿å… shift/splice çš„é«˜é¢‘ O(n) å¼€é”€
                this.items = [];
                this.maxItems = 200; // æœ€å¤§æ‰è½ç‰©æ•°é‡
                this._start = 0;
                this._holes = 0;

                // å¯¹è±¡æ± ï¼šå‡å°‘å¯†é›†æ‰è½æ—¶çš„ GC æŠ–åŠ¨
                this._pool = [];
                this._poolCap = 256;

                // Spatial hash (no allocations per-frame)
                this._shBucketCount = 1024; // power-of-two
                this._shMask = this._shBucketCount - 1;
                this._shHead = new Int32Array(this._shBucketCount);
                this._shNext = new Int32Array(this.maxItems);
                this._shCellSize = CONFIG.TILE_SIZE * 6; // px
                this._shLastCap = this.maxItems;
            }

            _acquire(x, y, blockId, count) {
                const it = this._pool.pop();
                if (it) return it.reset(x, y, blockId, count);
                return new DroppedItem(x, y, blockId, count);
            }

            _release(it) {
                if (!it) return;
                // æ¸…ç†æ‹¾å–åŠ¨ç”»æ®‹ç•™ï¼ˆä¸å¯¹è±¡æ± å¤ç”¨é…åˆï¼Œé¿å…ä¸‹ä¸€æ¬¡ spawn ç›´æ¥â€œç§’æ¶ˆå¤±â€ï¼‰
                it._pickup = null;
                it._pickupAlpha = 1;
                it._pickupScale = 1;
                if (this._pool.length < this._poolCap) this._pool.push(it);
            }

            _maybeCompact(force = false) {
                if (!force) {
                    // ç©ºæ´å¾ˆå¤š or å¤´æŒ‡é’ˆæ¨è¿›å¤ªå¤šæ—¶æ‰å‹ç¼©ï¼Œé¿å…æ¯å¸§åˆ†é…æ–°æ•°ç»„
                    if (this._holes < 96 && (this._start < 256 || this._start <= (this.items.length >> 1))) return;
                }
                const next = [];
                for (let i = this._start; i < this.items.length; i++) {
                    const it = this.items[i];
                    if (it) next.push(it);
                }
                this.items = next;
                this._start = 0;
                this._holes = 0;
            }

            spawn(x, y, blockId, count = 1) {
                if (count <= 0) return;

                // å¦‚æœæ‰è½ç‰©å¤ªå¤šï¼Œæ·˜æ±°æœ€è€çš„ï¼ˆO(1) æ‘Šè¿˜ï¼‰
                while ((this.items.length - this._start) >= this.maxItems) {
                    const old = this.items[this._start];
                    if (old) this._release(old);
                    this.items[this._start] = null;
                    this._start++;
                    this._holes++;
                }

                this.items.push(this._acquire(x, y, blockId, count));

                // é˜²æ­¢ items æ— é™å¢é•¿ï¼šå®šæœŸå‹ç¼©
                if (this._start > 128 && this._start > (this.items.length >> 1)) {
                    this._maybeCompact(true);
                }
            }

            update(world, player, dt, addToInventoryCallback) {
                // Rebuild spatial hash each frame (O(N), but bucketed query reduces pickup cost)
                // IMPORTANT: no allocations here.
                const head = this._shHead;
                head.fill(-1);

                // IMPORTANT: items æ•°ç»„ä¼šå› â€œå¤´æŒ‡é’ˆ+ç©ºæ´â€ç­–ç•¥è€Œå‡ºç° length > maxItems çš„æƒ…å†µï¼Œ
                // è¿™ä¼šå¯¼è‡´ä½¿ç”¨ items ç´¢å¼•å†™å…¥/è¯»å– _shNext è¶Šç•Œï¼Œä»è€Œåœ¨å“ˆå¸Œé“¾éå†æ—¶å‡ºç° undefined -> æ­»å¾ªç¯ã€‚
                // è¿™é‡Œç¡®ä¿ _shNext çš„å®¹é‡å§‹ç»ˆè¦†ç›– items.lengthã€‚
                let next = this._shNext;
                const need = this.items.length;
                if (!next || next.length < need) {
                    let cap = (next && next.length) ? next.length : 16;
                    while (cap < need) cap <<= 1;
                    next = this._shNext = new Int32Array(cap);
                    this._shLastCap = cap;
                }

                const cs = this._shCellSize;
                const mask = this._shMask;

                // Update physics for all items + build hash for alive items
                for (let i = this.items.length - 1; i >= this._start; i--) {
                    const item = this.items[i];
                    if (!item) continue;

                    const alive = item.update(world, player, dt);
                    if (!alive) {
                        this._release(item);
                        this.items[i] = null;
                        this._holes++;
                        continue;
                    }

                    // Hash insert (bucket-only, collisions tolerated; distance check later)
                    const cx = (item.x / cs) | 0;
                    const cy = (item.y / cs) | 0;
                    const h = (((cx * 73856093) ^ (cy * 19349663)) >>> 0) & mask;
                    next[i] = head[h];
                    head[h] = i;
                }

                // Fast pickup query: only cells near player
                const px = player.cx ? player.cx() : (player.x || 0);
                const py = player.cy ? player.cy() : (player.y || 0);
                const pr = CONFIG.TILE_SIZE * 3; // pickup reach approx
                const minCx = ((px - pr) / cs) | 0, maxCx = ((px + pr) / cs) | 0;
                const minCy = ((py - pr) / cs) | 0, maxCy = ((py + pr) / cs) | 0;

                for (let cy = minCy; cy <= maxCy; cy++) {
                    for (let cx = minCx; cx <= maxCx; cx++) {
                        const h = (((cx * 73856093) ^ (cy * 19349663)) >>> 0) & mask;
                        let idx = head[h];
                        while (idx !== -1) {
                            const it = this.items[idx];
                            const nxt = next[idx];
                            if (it) {
                                // precise check
                                if (it.canPickup(player)) {
                                    const picked = addToInventoryCallback(it.blockId, it.count);
                                    if (picked) {
                                        this._release(it);
                                        this.items[idx] = null;
                                        this._holes++;
                                    }
                                }
                            }
                            idx = nxt;
                        }
                    }
                }

                // Advance head pointer (skip holes)
                while (this._start < this.items.length && !this.items[this._start]) {
                    this._start++;
                    this._holes = Math.max(0, this._holes - 1);
                }

                this._maybeCompact(false);
            }

            render(ctx, cam, textures, timeOfDay) {
                const ts = CONFIG.TILE_SIZE;
                const now = performance.now();
                const blinkPhase = Math.floor(now / 200) % 2;

                for (let i = this._start; i < this.items.length; i++) {
                    const item = this.items[i];
                    if (!item) continue;
                    const sx = item.x - cam.x;
                    const sy = item.y - cam.y;

                    // æµ®åŠ¨æ•ˆæœ
                    const bob = Math.sin(now * 0.005 + item.bobOffset) * 3;

                    // é—ªçƒæ•ˆæœï¼ˆå¿«æ¶ˆå¤±æ—¶ï¼‰
                    const timeLeft = item.maxAge - item.age;
                    if (timeLeft < 5000 && blinkPhase === 0) {
                        continue; // è·³è¿‡æ¸²æŸ“å®ç°é—ªçƒ
                    }

                    ctx.save();
                    ctx.translate(sx + item.w / 2, sy + item.h / 2 + bob);
                    ctx.rotate(item.rotation);

                    // å‘å…‰æ•ˆæœï¼ˆç”¨æŸ¥è¡¨é¿å…æ¯å¸§å¯¹è±¡æŸ¥æ‰¾ï¼‰
                    const lightLv = BLOCK_LIGHT[item.blockId];
                    if (lightLv > 0) {
                        ctx.shadowColor = BLOCK_COLOR[item.blockId] || '#fff';
                        ctx.shadowBlur = 15;
                    } else {
                        // æ™®é€šç‰©å“ä¹Ÿæœ‰è½»å¾®å‘å…‰
                        ctx.shadowColor = '#ffeaa7';
                        ctx.shadowBlur = 8;
                    }

                    // ç»˜åˆ¶ç‰©å“
                    const tex = textures.get(item.blockId);
                    if (tex) {
                        ctx.drawImage(tex, -item.w / 2, -item.h / 2, item.w, item.h);
                    } else {
                        // åå¤‡æ¸²æŸ“
                        ctx.fillStyle = bd?.color || '#fff';
                        ctx.fillRect(-item.w / 2, -item.h / 2, item.w, item.h);
                    }

                    ctx.shadowBlur = 0;

                    // æ˜¾ç¤ºæ•°é‡ï¼ˆå¦‚æœå¤§äº1ï¼‰
                    if (item.count > 1) {
                        ctx.fillStyle = '#ffeaa7';
                        ctx.font = 'bold 8px Arial';
                        ctx.textAlign = 'right';
                        ctx.fillText(item.count.toString(), item.w / 2, item.h / 2);
                    }

                    ctx.restore();
                }
            }

            clear() {
                for (let i = this._start; i < this.items.length; i++) {
                    const it = this.items[i];
                    if (it) this._release(it);
                }
                this.items = [];
                this._start = 0;
                this._holes = 0;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                 ç¯å¢ƒç²’å­ç³»ç»Ÿ

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { DroppedItem, DroppedItemManager });

        class AmbientParticles {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.particles = [];
                this.mode = 'none';
                this._night = 0;
                this._lastOpacity = -1;
            }

            update(timeOfDay, weather) {
                if (!this.container) return;

                const reducedMotion = !!(window.GAME_SETTINGS && window.GAME_SETTINGS.reducedMotion);
                if (reducedMotion) {
                    if (this.mode !== 'none' || this.particles.length) this._clearAll();
                    this.mode = 'none';
                    return;
                }

                const nightFactor = Utils.nightFactor(timeOfDay);

                const wType = (weather && weather.type) ? weather.type : 'clear';
                const wInt = (weather && Number.isFinite(weather.intensity)) ? weather.intensity : 0;

                let mode = 'none';
                let target = 0;

                // å¤©æ°”ä¼˜å…ˆï¼šé›¨/é›ªä¼šæ›¿ä»£å¤œæ™šè¤ç«è™«
                if ((wType === 'rain' || wType === 'thunder') && wInt > 0.06) {
                    mode = 'rain';
                    target = Math.round(35 + wInt * 95);   // 35 ~ 130
                } else if (wType === 'snow' && wInt > 0.06) {
                    mode = 'snow';
                    target = Math.round(20 + wInt * 70);   // 20 ~ 90
                } else if (nightFactor > 0.25) {
                    mode = 'firefly';
                    target = Math.round(10 + nightFactor * 18); // 10 ~ 28
                }

                // ä½ç”»è´¨ï¼šé€‚å½“å‡é‡ï¼ˆDOM ç²’å­æ›´çœï¼‰
                try {
                    const gs = window.GAME_SETTINGS || {};
                    const cap = (typeof gs.__dprCapEffective === 'number') ? gs.__dprCapEffective : gs.dprCap;
                    if (cap && cap <= 1.25) target = Math.floor(target * 0.75);
                } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                // åˆ‡æ¢æ¨¡å¼ï¼šé‡å»ºç²’å­ï¼ˆé¿å…åŒæ—¶å­˜åœ¨å¤šç§ç²’å­é€ æˆå†—ä½™å¼€é”€ï¼‰
                if (mode !== this.mode) {
                    this._clearAll();
                    this.mode = mode;
                }

                // å®¹å™¨é€æ˜åº¦ï¼šåªåœ¨å˜åŒ–æ˜æ˜¾æ—¶å†™å…¥ï¼Œå‡å°‘ layout/style æŠ–åŠ¨
                let opacity = 0;
                if (mode === 'firefly') opacity = 0.25 + nightFactor * 0.75;
                else if (mode === 'rain') opacity = 0.35 + wInt * 0.65;
                else if (mode === 'snow') opacity = 0.25 + wInt * 0.75;
                opacity = Math.min(1, Math.max(0, opacity));
                if (this._lastOpacity < 0 || Math.abs(opacity - this._lastOpacity) > 0.03) {
                    this.container.style.opacity = opacity.toFixed(3);
                    this._lastOpacity = opacity;
                }

                // æ•°é‡è°ƒæ•´ï¼ˆä¸Šé™ä¿æŠ¤ï¼‰
                target = Math.max(0, Math.min(target, mode === 'rain' ? 140 : 110));
                if (this.particles.length < target) this._spawn(target - this.particles.length, mode, wInt, nightFactor);
                else if (this.particles.length > target) {
                    for (let i = this.particles.length - 1; i >= target; i--) {
                        const p = this.particles.pop();
                        if (p && p.parentNode) p.parentNode.removeChild(p);
                    }
                }

                // è¤ç«è™«ï¼šå¤œæ™šå› å­å˜åŒ–æ—¶ï¼Œæ‰æ›´æ–°æ¯ä¸ªç²’å­ opacity
                if (mode === 'firefly') {
                    if (Math.abs(nightFactor - this._night) > 0.03) {
                        this._night = nightFactor;
                        for (const p of this.particles) {
                            const o = (p._baseOpacity || 1) * nightFactor;
                            p.style.opacity = o.toFixed(3);
                        }
                    }
                }
            }

            _spawn(n, mode, intensity, nightFactor) {
                const frag = document.createDocumentFragment();

                for (let i = 0; i < n; i++) {
                    const p = document.createElement('div');

                    if (mode === 'firefly') {
                        p.className = 'firefly';
                        p.style.left = (Math.random() * 100).toFixed(2) + '%';
                        p.style.top = (30 + Math.random() * 40).toFixed(2) + '%';
                        p.style.animationDelay = (-Math.random() * 8).toFixed(2) + 's';
                        p.style.animationDuration = (6 + Math.random() * 4).toFixed(2) + 's';
                        const base = 0.2 + Math.random() * 0.8;
                        p._baseOpacity = base;
                        p.style.opacity = (base * nightFactor).toFixed(3);
                    }
                    else if (mode === 'rain') {
                        p.className = 'raindrop';
                        p.style.left = (Math.random() * 100).toFixed(2) + '%';
                        p.style.top = (-20 - Math.random() * 35).toFixed(2) + '%';
                        const len = 10 + Math.random() * 18;
                        p.style.height = len.toFixed(1) + 'px';
                        p.style.opacity = (0.25 + Math.random() * 0.55).toFixed(3);
                        const baseDur = 1.05 - 0.45 * intensity;
                        const dur = Math.max(0.45, baseDur + (Math.random() * 0.35));
                        p.style.animationDuration = dur.toFixed(2) + 's';
                        p.style.animationDelay = (-Math.random() * 1.5).toFixed(2) + 's';
                    }
                    else if (mode === 'snow') {
                        p.className = 'snowflake';
                        p.style.left = (Math.random() * 100).toFixed(2) + '%';
                        p.style.top = (-10 - Math.random() * 25).toFixed(2) + '%';
                        const size = 2 + Math.random() * 3.5;
                        p.style.width = size.toFixed(1) + 'px';
                        p.style.height = size.toFixed(1) + 'px';
                        p.style.opacity = (0.35 + Math.random() * 0.55).toFixed(3);
                        const drift = (Math.random() * 80 - 40).toFixed(0) + 'px';
                        p.style.setProperty('--drift', drift);
                        const baseDur = 6.5 - 2.2 * intensity;
                        const dur = Math.max(3.0, baseDur + (Math.random() * 3.0));
                        p.style.animationDuration = dur.toFixed(2) + 's';
                        p.style.animationDelay = (-Math.random() * 3.5).toFixed(2) + 's';
                    }
                    else {
                        continue;
                    }

                    frag.appendChild(p);
                    this.particles.push(p);
                }

                this.container.appendChild(frag);
            }

            _clearAll() {
                for (const p of this.particles) {
                    if (p && p.parentNode) p.parentNode.removeChild(p);
                }
                this.particles.length = 0;
                this._night = 0;
                this._lastOpacity = -1;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                      ç©å®¶

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { AmbientParticles });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 11: Player
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class Player {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.w = 16; this.h = 40;
                this.vx = 0; this.vy = 0;
                this.grounded = false;
                this.facingRight = true;
                this.health = 100; this.maxHealth = 100;
                this.mana = 50; this.maxMana = 50;
                this.animFrame = 0; this.animTimer = 0;
                // Sprint state
                // - _sprinting: raw "wants sprint" from input (hold/shift)
                // - _sprintActive: sprint is actually active (ground-only, with perfect-landing resume)
                this._sprinting = false;
                this._sprintActive = false;
                this._sprintBoostMs = 0;
                this._sprintVfxMs = 0;
                this._sprintLeanMs = 0;
                this._sprintCarryArmed = false;
                this._perfectLandMs = 0;
                this.inventory = [
                    { id: 'pickaxe', name: 'é“œé•', count: 1, power: 40, speed: 2, icon: 'â›ï¸' },
                    { id: BLOCK.DIRT, name: 'åœŸå—', count: 50 },
                    { id: BLOCK.STONE, name: 'çŸ³å—', count: 50 },
                    { id: BLOCK.PLANKS, name: 'æœ¨æ¿', count: 30 },
                    { id: BLOCK.TORCH, name: 'ç«æŠŠ', count: 50 },
                    { id: BLOCK.GLASS, name: 'ç»ç’ƒ', count: 20 }
                    // å¿«æ·æ é¢„ç•™3ä¸ªç©ºä½ç»™æ–°æŒ–æ˜çš„ç‰©å“
                ];
                this.selectedSlot = 0;
                // é¢„ç”Ÿæˆç©å®¶åƒç´  Spriteï¼ˆå¤´+èº«ä½“ï¼‰ï¼Œé¿å…æ¯å¸§é€åƒç´  fillRectï¼ˆæ€§èƒ½å¤§å¹…æå‡ï¼‰
                if (!Player._spriteCanvases) Player._initSpriteCache();

                // è·³è·ƒæ‰‹æ„Ÿï¼šåœŸç‹¼æ—¶é—´ + è·³è·ƒç¼“å†² + é˜²æŒ‰ä½è¿è·³
                this._jumpHeld = false;
                this._coyoteMs = 0;
                this._jumpBufferMs = 0;
            }

            static _initSpriteCache() {
                // é¢œè‰²è¡¨ä¸åŸ render() å†…å®šä¹‰ä¿æŒä¸€è‡´
                const colors = {
                    '#': '#ffcc80', // çš®è‚¤
                    'X': '#7e57c2', // ç´«è‰²ä¸Šè¡£
                    'Y': '#5e35b1', // è¡£æœé˜´å½±
                    'L': '#455a64', // è£¤å­
                    'H': '#3e2723', // å¤´å‘æ·±è‰²
                    'h': '#5d4037', // å¤´å‘äº®è‰²
                    'E': '#ffffff', // çœ¼ç™½
                    'e': '#333333', // ç³å­”
                    'S': '#212121', // é‹å­
                    'G': '#ffd700', // çš®å¸¦æ‰£
                    'B': '#3e2723'  // çš®å¸¦
                };

                const headSprite = [
                    '..HHHHHH..',
                    '.HHhHHHhH.',
                    'HHHhHHHHHH',
                    'HH######HH',
                    'HH#E#E##HH',
                    'H##e#e###H',
                    '.########.',
                    '.########.',
                    '..######..',
                    '..........'
                ];
                const bodyBase = [
                    '.XXXXXX.',
                    'XXXXXXXX',
                    'XXXXXXXX',
                    'XYXXXXYX',
                    'XYXXXXYX',
                    'XYXXXXYX',
                    'BBGBBBBB',
                    'LL....LL',
                    'LL....LL',
                    'SS....SS'
                ];

                // åŸå§‹ç»˜åˆ¶åæ ‡ï¼ˆä»¥ç©å®¶ä¸­å¿ƒä¸ºåŸç‚¹ï¼‰
                // head: (-10, -22), 10x10, scale=2  => 20x20
                // body: (-8,  -4),  8x10, scale=2  => 16x20
                // åˆå¹¶åŒ…å›´ç›’ï¼šx [-10, 10) => 20ï¼Œy [-22, 16) => 38
                const W = 20, H = 38;
                const padX = 10, padY = 22;
                const scale = 2;

                const makeCanvas = (bodyLines) => {
                    const c = document.createElement('canvas');
                    c.width = W;
                    c.height = H;
                    const cx = c.getContext('2d', { willReadFrequently: true });
                    cx.imageSmoothingEnabled = false;

                    const drawPixelMatrix = (matrix, offsetX, offsetY) => {
                        for (let y = 0; y < matrix.length; y++) {
                            const row = matrix[y];
                            for (let x = 0; x < row.length; x++) {
                                const ch = row[x];
                                const col = colors[ch];
                                if (col) {
                                    cx.fillStyle = col;
                                    cx.fillRect(offsetX + x * scale, offsetY + y * scale, scale, scale);
                                }
                            }
                        }
                    };

                    // èº«ä½“ + å¤´éƒ¨ï¼ˆbob ç”±è¿è¡Œæ—¶åœ¨ drawImage æ—¶åŠ åç§»ï¼Œä¿æŒä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
                    drawPixelMatrix(bodyLines, -8 + padX, -4 + padY);
                    drawPixelMatrix(headSprite, -10 + padX, -22 + padY);
                    return c;
                };

                // walkFrame 0/1/2/3 çš„èº«ä½“è¡Œï¼ˆä¸åŸ render() ä¿®æ”¹ bodySprite[7..9] å®Œå…¨ä¸€è‡´ï¼‰
                const f0 = bodyBase.slice();
                const f1 = bodyBase.slice();
                const f2 = bodyBase.slice();

                // frame 1 / 3
                f1[7] = 'LL....L.';
                f1[8] = 'LL....L.';
                f1[9] = 'SS....S.';

                // frame 2
                f2[7] = '.L....LL';
                f2[8] = '.L....LL';
                f2[9] = '.S....SS';

                const c0 = makeCanvas(f0);
                const c1 = makeCanvas(f1);
                const c2 = makeCanvas(f2);

                Player._spriteCanvases = [c0, c1, c2, c1];
                Player._spriteColors = colors;
                Player._spriteOffset = { x: padX, y: padY };
            }

            update(input, world, dt) {
                this.input = input; // ä¿å­˜è¾“å…¥çŠ¶æ€ç”¨äºæ¸²æŸ“åŠ¨ç”»

                // ç»Ÿä¸€ä»¥ 60FPS ä¸ºåŸºå‡†åšæ—¶é—´ç¼©æ”¾ï¼ˆä¿æŒåŸæ‰‹æ„Ÿï¼ŒåŒæ—¶è®©ä¸åŒå¸§ç‡ä¸‹é€Ÿåº¦ä¸€è‡´ï¼‰
                const dtClamped = Math.min(dt, 50);
                const dtScale = dtClamped / 16.6667;

                const wasGrounded = this.grounded;

                // Perfect landing window countdown (ms)
                if (this._perfectLandMs > 0) this._perfectLandMs = Math.max(0, this._perfectLandMs - dtClamped);

                // â”€â”€ å†²åˆºåˆ¤å®šï¼ˆåœ°é¢æ‰å…è®¸å†²åˆºï¼›ç©ºä¸­å¼ºåˆ¶å–æ¶ˆï¼‰
                // input.sprintï¼šæ¥è‡ª â€œé•¿æŒ‰ A/Dâ€ æˆ– Shift çš„åŸå§‹æ„å›¾
                const wantsSprint = !!input.sprint;
                this._sprinting = wantsSprint;

                // è½åœ° 0.1s å†…ï¼ˆPERFECT_LAND_MSï¼‰å¦‚æœä»åœ¨æŒ‰æ–¹å‘é”®ï¼Œå¯â€œç«‹åˆ»ç»­å†²â€ï¼ˆä¸å¿…é‡æ–°é•¿æŒ‰ï¼‰
                const hasDir = !!(input.left || input.right);
                const sprintActive = wasGrounded && (wantsSprint || (this._perfectLandMs > 0 && hasDir));

                const justStartedSprint = sprintActive && !this._sprintActive;
                this._sprintActive = sprintActive;

                // å†²åˆºèµ·æ­¥ï¼šçˆ†å‘ + å‰å€¾
                if (justStartedSprint) {
                    this._sprintBoostMs = CONFIG.SPRINT_BOOST_MS;
                    this._sprintVfxMs = CONFIG.SPRINT_VFX_MS;
                    this._sprintLeanMs = CONFIG.SPRINT_LEAN_MS;

                    // Small kick makes sprint feel snappy (ground only)
                    let dir = 0;
                    if (input.left && !input.right) dir = -1;
                    else if (input.right && !input.left) dir = 1;
                    else dir = this.facingRight ? 1 : -1;

                    this.vx += dir * CONFIG.SPRINT_KICK;
                }

                if (this._sprintBoostMs > 0) this._sprintBoostMs = Math.max(0, this._sprintBoostMs - dtClamped);
                if (this._sprintVfxMs > 0) this._sprintVfxMs = Math.max(0, this._sprintVfxMs - dtClamped);
                if (this._sprintLeanMs > 0) this._sprintLeanMs = Math.max(0, this._sprintLeanMs - dtClamped);

                // Air: keep a bit of inertia, but do NOT allow sprint acceleration
                const baseSpeed = CONFIG.PLAYER_SPEED;
                const groundMax = baseSpeed * (sprintActive ? CONFIG.SPRINT_MULT : 1);
                const airMax = baseSpeed * CONFIG.AIR_INERTIA_MULT;
                const maxSpeed = wasGrounded ? groundMax : airMax;

                const accel = wasGrounded ? 1 : CONFIG.AIR_CONTROL;
                const sprintAccelMult = (sprintActive && wasGrounded && this._sprintBoostMs > 0) ? CONFIG.SPRINT_BOOST_ACCEL_MULT : 1;
                const accelSpeed = wasGrounded ? groundMax : baseSpeed;

                // â”€â”€ è·³è·ƒï¼šåœŸç‹¼æ—¶é—´ + è·³è·ƒç¼“å†²ï¼ˆæ›´â€œè·Ÿæ‰‹â€ï¼‰
                const COYOTE_MS = 100;
                const JUMP_BUFFER_MS = 120;

                // åªåœ¨â€œæŒ‰ä¸‹ç¬é—´â€è®°å½•è·³è·ƒï¼ˆé¿å…æŒ‰ä½é”®è‡ªåŠ¨è¿è·³ï¼‰
                const jumpPressed = !!input.jump && !this._jumpHeld;
                this._jumpHeld = !!input.jump;

                if (this.grounded) this._coyoteMs = COYOTE_MS;
                else this._coyoteMs = Math.max(0, this._coyoteMs - dtClamped);

                if (jumpPressed) this._jumpBufferMs = JUMP_BUFFER_MS;
                else this._jumpBufferMs = Math.max(0, this._jumpBufferMs - dtClamped);

                // â”€â”€ æ°´å¹³ç§»åŠ¨ï¼ˆåœ°é¢å†²åˆºçˆ†å‘ï¼›ç©ºä¸­ä¸åŠ é€Ÿå†²åˆºï¼‰
                if (input.left) { this.vx -= accelSpeed * 0.22 * accel * sprintAccelMult * dtScale; this.facingRight = false; }
                if (input.right) { this.vx += accelSpeed * 0.22 * accel * sprintAccelMult * dtScale; this.facingRight = true; }

                // æ‘©æ“¦ï¼šæŒ‰ dtScale è¿›è¡Œå¹‚ç¼©æ”¾ï¼Œé¿å…å¸§ç‡å˜åŒ–å¯¼è‡´â€œæ»‘/ç²˜â€
                this.vx *= Math.pow(CONFIG.FRICTION, dtScale);
                if (Math.abs(this.vx) < 0.1) this.vx = 0;

                // é€Ÿåº¦ä¸Šé™ï¼šåœ°é¢=æ­£å¸¸/å†²åˆºï¼›ç©ºä¸­=ä¿ç•™å°‘é‡æƒ¯æ€§ï¼Œä½†ä¸è®©å®ƒæ— é™å¿«
                this.vx = Utils.clamp(this.vx, -maxSpeed, maxSpeed);

                // æ»¡è¶³ç¼“å†² & åœŸç‹¼æ—¶é—´æ‰èµ·è·³
                if (this._jumpBufferMs > 0 && this._coyoteMs > 0) {
                    this.vy = -CONFIG.JUMP_FORCE;
                    this.grounded = false;
                    this._jumpBufferMs = 0;
                    this._coyoteMs = 0;
                }

                // é‡åŠ›ï¼ˆdtScaleï¼‰
                this.vy += CONFIG.GRAVITY * dtScale;
                this.vy = Math.min(this.vy, CONFIG.MAX_FALL_SPEED);

                // ç¢°æ’ç§»åŠ¨ï¼ˆæŒ‰ dtScale è®©ä½ç§»ä¸æ—¶é—´æˆæ­£æ¯”ï¼‰
                this._moveCollide(world, this.vx * dtScale, 0);

                // è®°å½•â€œç¦»åœ°â€ï¼ˆä»åœ°é¢è¿›å…¥ç©ºä¸­ï¼‰ç”¨äºï¼šå†²åˆºè½åœ°åé¦ˆ / å®Œç¾è¸©ç‚¹ç»­å†²
                // æ³¨æ„ï¼šå¿…é¡»åœ¨æŠŠ grounded ç½® false ä¹‹å‰åˆ¤æ–­
                // ï¼ˆè¿™é‡Œ wasGrounded ä»£è¡¨ä¸Šä¸€å¸§æ˜¯å¦åœ¨åœ°é¢ï¼‰
                this.grounded = false;
                this._moveCollide(world, 0, this.vy * dtScale);

                const leftGround = wasGrounded && !this.grounded;
                if (leftGround) {
                    // ä»…å½“â€œåœ°é¢å†²åˆºä¸­ç¦»åœ°â€æ‰æ­¦è£…è½åœ°ç»­å†²
                    this._sprintCarryArmed = !!sprintActive;
                    // ç©ºä¸­å¼ºåˆ¶å–æ¶ˆå†²åˆºï¼ˆä¸å½±å“å·²æœ‰æƒ¯æ€§ï¼‰
                    this._sprintActive = false;
                    this._sprintBoostMs = 0;
                    this._sprintLeanMs = 0;
                }

                const justLanded = (!wasGrounded && this.grounded);
                if (justLanded) {
                    if (this._sprintCarryArmed) {
                        // å®Œç¾è¸©ç‚¹ï¼šè½åœ° 0.1s å†…ï¼ŒæŒ‰ä½æ–¹å‘å³å¯ç¬é—´ç»­å†²
                        this._perfectLandMs = CONFIG.PERFECT_LAND_MS;

                        // å†²åˆºè½åœ°åé¦ˆï¼šdust + è½»å¾®éœ‡å±
                        try {
                            const g = window.__GAME_INSTANCE__;
                            if (g && g.settings && g.settings.particles && g.particles && typeof g.particles.emit === 'function') {
                                g.particles.emit(this.cx(), this.y + this.h - 2, {
                                    count: CONFIG.LAND_DUST_COUNT,
                                    speed: 2.6,
                                    life: 0.55,
                                    size: 3.2,
                                    gravity: 0.12,
                                    spread: 1.2,
                                    color: 'rgba(235, 230, 220, 0.95)',
                                    glow: true
                                });
                            }
                            if (g && typeof g.addCameraShake === 'function') g.addCameraShake(CONFIG.LAND_SHAKE_AMP, CONFIG.LAND_SHAKE_MS);
                        } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                    }
                    this._sprintCarryArmed = false;
                }

                // åŠ¨ç”»è®¡æ—¶ä¿æŒæ¯«ç§’
                if (Math.abs(this.vx) > 0.5 && this.grounded) {
                    this.animTimer += dtClamped;
                    if (this.animTimer > 100) { this.animTimer = 0; this.animFrame = (this.animFrame + 1) % 4; }
                } else this.animFrame = 0;

                // å¸§æœ«å°¾ï¼šç©ºä¸­å¼ºåˆ¶å–æ¶ˆå†²åˆºï¼ˆå…œåº•ï¼Œé˜²æ­¢ä»»ä½•â€œç©ºä¸­ä¹±å†²â€ï¼‰
                if (!this.grounded) this._sprintActive = false;
            }

            _moveCollide(world, dx, dy) {
                const steps = Math.ceil(Math.max(Math.abs(dx), Math.abs(dy)));
                const sx = dx / (steps || 1), sy = dy / (steps || 1);

                for (let i = 0; i < steps; i++) {
                    this.x += sx;
                    if (this._collides(world)) { this.x -= sx; this.vx = 0; break; }
                }
                for (let i = 0; i < steps; i++) {
                    this.y += sy;
                    if (this._collides(world)) {
                        this.y -= sy;
                        if (dy > 0) this.grounded = true;
                        this.vy = 0;
                        break;
                    }
                }
            }

            _collides(world) {
                const ts = CONFIG.TILE_SIZE;
                const l = Math.floor(this.x / ts), r = Math.floor((this.x + this.w - 0.001) / ts);
                const t = Math.floor(this.y / ts), b = Math.floor((this.y + this.h - 0.001) / ts);

                for (let tx = l; tx <= r; tx++) {
                    if (tx < 0 || tx >= world.w) continue;
                    const col = world.tiles[tx];
                    for (let ty = t; ty <= b; ty++) {
                        if (ty < 0 || ty >= world.h) continue;
                        if (BLOCK_SOLID[col[ty]]) return true;
                    }
                }
                return false;
            }

            render(ctx, cam) {
                // Pixel-aligned camera math: match world renderer rounding to avoid sprint-camera jitter
                const camPxX = Math.ceil(cam.x);
                const camPxY = Math.ceil(cam.y);
                const sx = Math.floor(this.x) - camPxX;
                const sy = Math.floor(this.y) - camPxY;

                ctx.save();
                ctx.translate(sx + this.w / 2, sy + this.h / 2);

                // åƒç´ è‰ºæœ¯æ¸²æŸ“ï¼šç¦ç”¨å¹³æ»‘
                ctx.imageSmoothingEnabled = false;

                // ç¿»è½¬
                if (!this.facingRight) ctx.scale(-1, 1);

                // å†²åˆºèµ·æ­¥å‰å€¾ï¼šä»…åœ¨çŸ­æ—¶é—´å†…ç”Ÿæ•ˆï¼ˆæ›´â€œæœ‰é‡é‡æ„Ÿâ€ï¼‰
                if (this._sprintLeanMs > 0 && this.grounded) {
                    const t = Utils.clamp(this._sprintLeanMs / Math.max(1, CONFIG.SPRINT_LEAN_MS), 0, 1);
                    // ease-outï¼šä¸€å¼€å§‹å‰å€¾æ˜æ˜¾ï¼Œéšåå¿«é€Ÿå›æ­£
                    const k = t * t;
                    ctx.rotate(-CONFIG.SPRINT_LEAN_ANGLE * k);
                }

                // --- åŠ¨ç”»çŠ¶æ€ ---
                const isMoving = Math.abs(this.vx) > 0.1;
                const useTool = this.input && (this.input.mouseLeft || this.input.mouseRight);

                // ç®€å•çš„å¸§åŠ¨ç”»è®¡æ—¶å™¨ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
                const now = Date.now();
                const tick = Math.floor(now / 100);
                const walkFrame = isMoving ? (tick % 4) : 0;
                const toolFrame = useTool ? (tick % 3) : 0;

                // é¢„æ¸²æŸ“çš„å¤´+èº«ä½“ Spriteï¼ˆä¿æŒåŸåƒç´ ç”»ä¸åæ ‡ä½“ç³»ä¸€è‡´ï¼‰
                const bob = (isMoving && (walkFrame === 1 || walkFrame === 3)) ? -2 : 0;
                const sprite = Player._spriteCanvases ? Player._spriteCanvases[walkFrame] : null;
                if (sprite) {
                    // åŸå§‹ top-left ä¸º (-10, -22)ï¼Œå› æ­¤ drawImage æ”¾åœ¨åŒæ ·ä½ç½®
                    ctx.drawImage(sprite, -10, -22 + bob);
                }

                // æ‰‹è‡‚é€»è¾‘ï¼ˆä¿æŒåŸæ•ˆæœï¼šæŒ¥èˆ/è¡Œèµ°æ‘†è‡‚ï¼‰
                const colors = Player._spriteColors;

                ctx.save();
                ctx.translate(0, -8 + bob); // è‚©è†€ä½ç½®

                let armRot = 0;
                if (useTool) {
                    // æŒ¥èˆå·¥å…·
                    armRot = (toolFrame * -0.5) + 0.5; // +0.5 -> 0 -> -0.5
                } else if (isMoving) {
                    armRot = Math.sin(now / 150) * 0.8;
                }

                ctx.rotate(armRot);

                // ç»˜åˆ¶æ‰‹è‡‚ (ç®€å•çš„çŸ©å½¢ç»„åˆï¼Œä¿æŒåƒç´ æ„Ÿ)
                ctx.fillStyle = colors['X']; // è¢–å­
                ctx.fillRect(-2, -2, 4, 6);
                ctx.fillStyle = colors['#']; // æ‰‹è‡‚
                ctx.fillRect(-2, 4, 4, 8);

                // æ‰‹æŒç‰©å“
                const item = this.getItem();
                if (item) {
                    ctx.save();
                    ctx.translate(6, 12);

                    // ç‰©å“æ—‹è½¬ä¿®æ­£
                    ctx.rotate(-Math.PI / 2);

                    if (item.id === 'pickaxe') {
                        // åƒç´ é£é•å­
                        ctx.fillStyle = '#8d6e63'; // æ£•è‰²æŸ„
                        ctx.fillRect(0, -2, 14, 4);

                        // é•å¤´
                        ctx.fillStyle = '#cfd8dc'; // é“¶è‰²
                        // ç®€å•çš„åƒç´ é•å¤´å½¢çŠ¶ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
                        const pickHead = [
                            [0, -6], [2, -6], [4, -4], [6, -2], [8, 0], [10, 2], // ä¸ŠåŠéƒ¨åˆ†
                            [0, 6], [2, 6], [4, 4], [6, 2], [8, 0] // ä¸‹åŠéƒ¨åˆ†
                        ];
                        for (let p of pickHead) {
                            ctx.fillRect(8 + p[0], p[1], 2, 2);
                        }
                        // å°–ç«¯
                        ctx.fillStyle = '#eceff1';
                        ctx.fillRect(18, 2, 2, 2);
                        ctx.fillRect(18, -6, 2, 2);

                    } else {
                        // æ‰‹æŒæ–¹å—ï¼šç»˜åˆ¶ç¼©å°ç‰ˆå›¾æ ‡
                        ctx.rotate(Math.PI / 2); // è½¬å›æ¥
                        ctx.translate(-6, -6);
                        // å°è¯•è·å–æ–¹å—é¢œè‰²ï¼ˆæŸ¥è¡¨æ›´å¿«ï¼‰
                        const col = (typeof item.id === 'number') ? BLOCK_COLOR[item.id] : null;
                        if (col) {
                            ctx.fillStyle = col;
                            ctx.fillRect(0, 0, 10, 10);
                            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(0, 0, 10, 10);
                        }
                    }

                    ctx.restore();
                }

                ctx.restore(); // æ¢å¤æ‰‹è‡‚å˜æ¢
                ctx.restore(); // æ¢å¤æ•´ä½“å˜æ¢
            }

            cx() { return this.x + this.w / 2; }
            cy() { return this.y + this.h / 2; }
            getItem() {
                const item = this.inventory[this.selectedSlot];
                // å¦‚æœæ§½ä½ä¸ºç©ºæˆ–ç‰©å“æ•°é‡ä¸º0ï¼Œè¿”å›null
                if (!item || (item.count === 0 && item.id !== 'pickaxe')) {
                    return null;
                }
                return item;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                              ç§»åŠ¨ç«¯è§¦æ§æ§åˆ¶å™¨

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { Player });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 12: Touch Controller
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class TouchController {
            constructor(game) {
                this.game = game;
                this.joystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
                this.buttons = { jump: false, mine: false, place: false };
                this.crosshair = { x: 0, y: 0, visible: false };
                this.targetTouchId = null;

                this._init();
                // å¤ç”¨è¾“å…¥å¯¹è±¡ï¼Œé¿å…æ¯å¸§åˆ†é…æ–°å¯¹è±¡ï¼ˆç§»åŠ¨ç«¯ GC å‹åŠ›å¤§ï¼‰
                this._input = { left: false, right: false, jump: false, sprint: false, mine: false, place: false, targetX: 0, targetY: 0, hasTarget: false };

            }

            _init() {
                const joystickEl = document.getElementById('joystick');
                const thumbEl = document.getElementById('joystick-thumb');
                const crosshairEl = document.getElementById('crosshair');

                // å…œåº•ï¼šè‹¥ç§»åŠ¨ç«¯ UI èŠ‚ç‚¹ç¼ºå¤±ï¼ˆè¢«è£å‰ª/äºŒæ¬¡å°è£…ï¼‰ï¼Œä¸è¦ç›´æ¥å´©æºƒ
                if (!joystickEl || !thumbEl || !crosshairEl) return;

                joystickEl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystickEl.getBoundingClientRect();
                    this.joystick.active = true;
                    this.joystick.startX = rect.left + rect.width / 2;
                    this.joystick.startY = rect.top + rect.height / 2;
                    this._updateJoystick(touch.clientX, touch.clientY, thumbEl);
                }, { passive: false });
                joystickEl.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.joystick.active) return;
                    const touch = e.touches[0];
                    this._updateJoystick(touch.clientX, touch.clientY, thumbEl);
                }, { passive: false });
                joystickEl.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystick.active = false;
                    this.joystick.dx = 0;
                    this.joystick.dy = 0;
                    thumbEl.style.transform = 'translate(-50%, -50%)';
                }, { passive: false });
                this._setupButton('btn-jump', 'jump');
                this._setupButton('btn-mine', 'mine');
                this._setupButton('btn-place', 'place');

                const canvas = this.game.canvas;
                canvas.addEventListener('touchstart', (e) => {
                    for (const touch of e.changedTouches) {
                        if (touch.clientX < 200 && touch.clientY > window.innerHeight - 220) continue;
                        if (touch.clientX > window.innerWidth - 200 && touch.clientY > window.innerHeight - 220) continue;

                        this.targetTouchId = touch.identifier;
                        this._updateCrosshair(touch.clientX, touch.clientY, crosshairEl);
                        this.crosshair.visible = true;
                        crosshairEl.style.display = 'block';
                    }
                }, { passive: false });
                canvas.addEventListener('touchmove', (e) => {
                    for (const touch of e.changedTouches) {
                        if (touch.identifier === this.targetTouchId) {
                            this._updateCrosshair(touch.clientX, touch.clientY, crosshairEl);
                        }
                    }
                }, { passive: false });
                canvas.addEventListener('touchend', (e) => {
                    for (const touch of e.changedTouches) {
                        if (touch.identifier === this.targetTouchId) {
                            this.targetTouchId = null;
                        }
                    }
                }, { passive: false });
            }

            _updateJoystick(tx, ty, thumbEl) {
                let dx = tx - this.joystick.startX;
                let dy = ty - this.joystick.startY;

                // æ ¹æ®è®¾ç½®åŠ¨æ€ç¼©æ”¾æ‘‡æ†è¡Œç¨‹ï¼ˆé€‚é…ä¸åŒæ‘‡æ†å°ºå¯¸ï¼‰
                const size = (this.game && this.game.settings && this.game.settings.joystickSize) ? this.game.settings.joystickSize : 140;
                const maxDist = Math.max(34, size * 0.33);

                const dist = Math.hypot(dx, dy);

                if (dist > maxDist) {
                    dx = dx / dist * maxDist;
                    dy = dy / dist * maxDist;
                }

                // å½’ä¸€åŒ–è¾“å…¥
                let nx = dx / maxDist;
                let ny = dy / maxDist;

                // æ­»åŒº + çµæ•åº¦æ›²çº¿ï¼ˆå¹³æ–¹/ç«‹æ–¹ç­‰ï¼‰
                const dz = (this.game && this.game.settings && typeof this.game.settings.joystickDeadzone === 'number')
                    ? this.game.settings.joystickDeadzone
                    : 0.14;
                const curve = (this.game && this.game.settings && typeof this.game.settings.joystickCurve === 'number')
                    ? this.game.settings.joystickCurve
                    : 2.2;

                let mag = Math.hypot(nx, ny);

                if (mag < dz) {
                    nx = 0; ny = 0; dx = 0; dy = 0;
                } else {
                    const t = (mag - dz) / (1 - dz);
                    const eased = Math.pow(Math.max(0, Math.min(1, t)), curve);
                    const s = (mag > 1e-5) ? (eased / mag) : 0;
                    nx *= s; ny *= s;
                    dx = nx * maxDist;
                    dy = ny * maxDist;
                }

                this.joystick.dx = nx;
                this.joystick.dy = ny;

                thumbEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            }

            _updateCrosshair(x, y, el) {
                this.crosshair.x = x;
                this.crosshair.y = y;
                el.style.left = (x - 20) + 'px';
                el.style.top = (y - 20) + 'px';
            }

            _setupButton(id, action) {
                const btn = document.getElementById(id);
                if (!btn) return;

                const vibrate = (ms) => {
                    try {
                        const s = this.game && this.game.settings;
                        if (s && s.vibration && navigator.vibrate) navigator.vibrate(ms);
                    } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                };

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.buttons[action] = true;
                    btn.classList.add('active');
                    vibrate(10);
                }, { passive: false });

                const up = (e) => {
                    e.preventDefault();
                    this.buttons[action] = false;
                    btn.classList.remove('active');
                };
                btn.addEventListener('touchend', up, { passive: false });
                btn.addEventListener('touchcancel', up, { passive: false });
            }

            getInput() {
                const o = this._input;
                o.left = this.joystick.dx < -0.3;
                o.right = this.joystick.dx > 0.3;
                o.jump = this.buttons.jump;
                o.sprint = Math.abs(this.joystick.dx) > 0.85;
                o.mine = this.buttons.mine;
                o.place = this.buttons.place;
                o.targetX = this.crosshair.x;
                o.targetY = this.crosshair.y;
                o.hasTarget = this.crosshair.visible;
                return o;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                   æ¸²æŸ“å™¨ (ç¾åŒ–ç‰ˆ)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                           Render constants (ç¼“å­˜å‡å°‘åˆ†é…)

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { TouchController });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 13: Renderer (with chunk batching, parallax, postFX)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const WALL_COLORS = ['#2b2f3a', '#353b48', '#2d3436', '#1e272e'];
        const PARALLAX_LAYERS = [
            // æ›´ç²¾è‡´çš„å¤šå±‚å±±è„‰ï¼ˆæ ¹æ®æ˜¼å¤œè‡ªåŠ¨æ¢è‰²ï¼‰
            {
                p: 0.05, y: 260, amp: 145, freq: 0.0019, detail: 0.0065, sharp: 1.60, seed: 17,
                snow: 1, snowLine: 0.74,
                palette: {
                    night: ['#070a18', '#111a33'],
                    dawn: ['#20122f', '#3a1f48'],
                    day: ['#b7d4f4', '#7a9cc2'],
                    dusk: ['#1c1430', '#3b2953']
                }
            },
            {
                p: 0.10, y: 215, amp: 120, freq: 0.0025, detail: 0.0078, sharp: 1.45, seed: 33,
                snow: 1, snowLine: 0.76,
                palette: {
                    night: ['#0b1024', '#18284a'],
                    dawn: ['#2a1430', '#5a2a3f'],
                    day: ['#9cc0e0', '#5f86b5'],
                    dusk: ['#22193f', '#5a3b6d']
                }
            },
            {
                p: 0.18, y: 165, amp: 105, freq: 0.0034, detail: 0.0105, sharp: 1.30, seed: 57,
                snow: 0, snowLine: 0.0,
                palette: {
                    night: ['#111c2c', '#243a4e'],
                    dawn: ['#3a2340', '#7a3b4b'],
                    day: ['#7db6c9', '#3d6f86'],
                    dusk: ['#2b2447', '#7a4b6d']
                }
            },
            {
                p: 0.30, y: 110, amp: 90, freq: 0.0046, detail: 0.0135, sharp: 1.18, seed: 89,
                snow: 0, snowLine: 0.0,
                palette: {
                    night: ['#162a2f', '#2f4a45'],
                    dawn: ['#3a2f3c', '#8a4a4a'],
                    day: ['#5fa39b', '#2f6b5f'],
                    dusk: ['#2a2f47', '#6a5a6d']
                }
            },
            {
                p: 0.45, y: 65, amp: 70, freq: 0.0060, detail: 0.0180, sharp: 1.10, seed: 123,
                snow: 0, snowLine: 0.0,
                palette: {
                    night: ['#1b2a2a', '#3a4a3f'],
                    dawn: ['#3a2a2a', '#7a3a2f'],
                    day: ['#4f8a4f', '#2e5f35'],
                    dusk: ['#2a2a3a', '#4a3a3f']
                }
            }
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                    Parallax Mountains (é‡ç»˜ç¾åŒ–ç‰ˆ)
        //   ç›®æ ‡ï¼šæ›´åƒâ€œå±‚å è¿œå±± + ç©ºæ°”é€è§† + ç»†èŠ‚è„Šçº¿â€ï¼Œæ›¿ä»£åŸæœ¬çš„æ­£å¼¦æ³¢å±±ä¸˜
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const _PX = (() => {
            // å¿«é€Ÿ 1D å™ªå£°ï¼ˆæ•´æ•° hash + smoothstep æ’å€¼ï¼‰ï¼Œè¶³å¤Ÿåšå±±è„Šè½®å»“ä¸”å¾ˆè½»é‡ã€‚
            const hash = (n) => {
                n = (n << 13) ^ n;
                return 1.0 - (((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
            };

            const smooth = (t) => t * t * (3 - 2 * t);

            const noise1 = (x, seed) => {
                const i = Math.floor(x);
                const f = x - i;
                const u = smooth(f);
                const a = hash(((i + seed) | 0));
                const b = hash(((i + 1 + seed) | 0));
                return a + (b - a) * u; // -1..1
            };

            const fbm = (x, seed, oct = 4) => {
                let v = 0;
                let amp = 0.55;
                let freq = 1;
                for (let o = 0; o < oct; o++) {
                    v += amp * noise1(x * freq, seed + o * 101);
                    freq *= 2;
                    amp *= 0.5;
                }
                return v; // ~[-1,1]
            };

            // ridged fbmï¼šæ›´â€œå°–â€çš„å±±è„Š
            const ridged = (x, seed, oct = 4) => {
                let v = 0;
                let amp = 0.65;
                let freq = 1;
                for (let o = 0; o < oct; o++) {
                    let n = noise1(x * freq, seed + o * 131);
                    n = 1 - Math.abs(n);
                    v += (n * n) * amp;
                    freq *= 2;
                    amp *= 0.55;
                }
                return v; // ~[0,1]
            };

            return { fbm, ridged };
        })();

        function renderParallaxMountains(renderer, cam, time = 0.5) {
            const ctx = renderer.ctx;
            const w = (renderer.w | 0);
            const h = (renderer.h | 0);
            if (!ctx || w <= 0 || h <= 0) return;

            // å¯é€‰ï¼šç”¨æˆ·ä¸»åŠ¨å…³é—­â€œèƒŒæ™¯å¢™å±±è„‰â€æˆ–æ€§èƒ½ç®¡ç†å™¨ä¸´æ—¶ç¦ç”¨
            try {
                const gs = window.GAME_SETTINGS || {};
                if (gs.bgMountains === false) return;
                if (gs.__bgMountainsEffective === false) return;
            } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

            const PM = renderParallaxMountains.__PM || (renderParallaxMountains.__PM = (() => {
                const CHUNK_W = 512;   // å±±è„‰â€œæ¨ªå‘ç¼“å­˜å—â€å®½åº¦ï¼ˆpxï¼‰
                const OVERLAP = 64;    // ä¸¤ä¾§é‡å ï¼Œé¿å… chunk æ‹¼æ¥å¤„çš„æè¾¹æ–­è£‚
                const PAD_CHUNKS = 2;  // è§†é‡å¤–å¤šç¼“å­˜å‡ ä¸ª chunkï¼Œå‡å°‘ç§»åŠ¨æ—¶æŠ–åŠ¨/ç¬æ—¶ç”Ÿæˆ

                const makeCanvas = (cw, ch) => {
                    let c = null;
                    // OffscreenCanvasï¼šæ›´å¿«ä¸”ä¸è¿› DOMï¼ˆä¸æ”¯æŒä¼šå›é€€ï¼‰
                    if (typeof OffscreenCanvas !== 'undefined') {
                        try { c = new OffscreenCanvas(cw, ch); } catch (_) { c = null; }
                    }
                    if (!c) {
                        c = document.createElement('canvas');
                    }
                    // æ— è®º OffscreenCanvas / Canvas éƒ½æ”¯æŒ width/height
                    c.width = cw;
                    c.height = ch;
                    return c;
                };

                const getCtx = (c) => {
                    try { return c.getContext('2d', { alpha: true }); } catch (e) {
                        try { return c.getContext('2d', { willReadFrequently: true }); } catch (_) { return null; }
                    }
                };

                return { CHUNK_W, OVERLAP, PAD_CHUNKS, makeCanvas, getCtx };
            })());

            const low = !!renderer.lowPower;
            const step = low ? 24 : 12;
            const layers = low ? PARALLAX_LAYERS.slice(0, 3) : PARALLAX_LAYERS;

            // â”€â”€ Mountain Rendering Patch v2: deterministic theme derivation â”€â”€
            // Always derive the theme directly from the time value, never from
            // renderer._getSkyBucket which has multiple conflicting implementations
            // (class returns t*100, patch returns 0-3). This guarantees theme
            // is always correct regardless of which _getSkyBucket is active.
            const theme = (time < 0.2) ? 'night'
                        : (time < 0.3) ? 'dawn'
                        : (time < 0.7) ? 'day'
                        : (time < 0.8) ? 'dusk'
                        : 'night';

            const cacheKey = theme + '|' + h + '|' + (low ? 1 : 0) + '|' + step + '|' + layers.length;
            let cache = renderer._parallaxMountainCache;
            if (!cache || cache.key !== cacheKey) {
                cache = renderer._parallaxMountainCache = {
                    key: cacheKey,
                    theme,
                    h,
                    low,
                    step,
                    chunkW: PM.CHUNK_W,
                    over: PM.OVERLAP,
                    pad: PM.PAD_CHUNKS,
                    layerMaps: Array.from({ length: layers.length }, () => new Map()),
                    fogKey: '',
                    fogGrad: null
                };
            } else {
                // ä¿é™©ï¼šå±‚æ•°å˜åŒ–æ—¶è¡¥é½/è£å‰ª map
                while (cache.layerMaps.length < layers.length) cache.layerMaps.push(new Map());
                if (cache.layerMaps.length > layers.length) cache.layerMaps.length = layers.length;
            }

            const ridgeStroke = (theme === 'day') ? 'rgba(255,255,255,0.20)' : 'rgba(220,230,255,0.14)';
            const snowStroke = (theme === 'day') ? 'rgba(255,255,255,0.75)' : 'rgba(220,230,255,0.55)';

            const chunkW = cache.chunkW;
            const over = cache.over;
            const fullW = chunkW + over * 2;

            // chunk æ„å»ºï¼šåªåœ¨â€œç¬¬ä¸€æ¬¡è¿›å…¥è§†é‡â€æ—¶ç”Ÿæˆï¼ˆå¤§å¹…å‡å°‘æ¯å¸§å™ªå£°/è·¯å¾„è®¡ç®—ï¼‰
            const buildChunk = (layer, li, chunkIndex) => {
                const canvas = PM.makeCanvas(fullW, h);
                const g = PM.getCtx(canvas);
                if (!g) return { canvas };

                g.clearRect(0, 0, fullW, h);

                // æ¸å˜å¡«å……
                const cols = (layer.palette && layer.palette[theme]) ? layer.palette[theme]
                    : (layer.palette ? layer.palette.night : ['#222', '#444']);
                const grad = g.createLinearGradient(0, h - layer.y - 160, 0, h);
                grad.addColorStop(0, cols[0]);
                grad.addColorStop(1, cols[1]);
                g.fillStyle = grad;

                const worldStart = chunkIndex * chunkW; // â€œå±±è„‰ç©ºé—´â€çš„èµ·ç‚¹
                const x0 = -over;
                const x1 = chunkW + over;

                // è®°å½•ç‚¹ï¼šç”¨äºè„Šçº¿é«˜å…‰ä¸é›ªçº¿ï¼ˆé¿å…äºŒæ¬¡é‡‡æ ·ï¼‰
                const pts = [];

                // è½®å»“å¡«å……
                g.beginPath();
                g.moveTo(0, h + 2);

                // é‡‡æ ·ï¼ˆç”¨ < å†è¡¥ä¸€ä¸ªç«¯ç‚¹ï¼Œç¡®ä¿æ‹¼æ¥å¤„ä¸¥æ ¼å¯¹é½ï¼‰
                for (let x = x0; x < x1; x += step) {
                    const wx = worldStart + x;
                    const r = _PX.ridged(wx * layer.freq, layer.seed);
                    const f = _PX.fbm(wx * layer.detail, layer.seed + 999);

                    const contour = 0.72 * r + 0.28 * Math.pow(r, layer.sharp || 1.2);
                    const wobble = 0.86 + 0.14 * f;
                    const hh = layer.amp * contour * wobble;

                    const y = h - layer.y - hh;
                    const cx = x + over;
                    pts.push(cx, y, hh);
                    g.lineTo(cx, y);
                }

                // æœ«ç«¯ç²¾ç¡®è¡¥ç‚¹ï¼ˆx1ï¼‰
                {
                    const x = x1;
                    const wx = worldStart + x;
                    const r = _PX.ridged(wx * layer.freq, layer.seed);
                    const f = _PX.fbm(wx * layer.detail, layer.seed + 999);

                    const contour = 0.72 * r + 0.28 * Math.pow(r, layer.sharp || 1.2);
                    const wobble = 0.86 + 0.14 * f;
                    const hh = layer.amp * contour * wobble;

                    const y = h - layer.y - hh;
                    const cx = x + over;
                    pts.push(cx, y, hh);
                    g.lineTo(cx, y);
                }

                g.lineTo(fullW, h + 2);
                g.closePath();
                g.fill();

                // è„Šçº¿é«˜å…‰ï¼ˆè–„è–„ä¸€æ¡ï¼Œå¢å¼ºç«‹ä½“æ„Ÿï¼‰
                g.save();
                g.globalAlpha = low ? 0.10 : (0.12 + li * 0.02);
                g.strokeStyle = ridgeStroke;
                g.lineWidth = low ? 1 : 2;
                g.lineJoin = 'round';
                g.lineCap = 'round';
                g.beginPath();
                if (pts.length >= 3) {
                    g.moveTo(pts[0], pts[1]);
                    for (let i = 3; i < pts.length; i += 3) g.lineTo(pts[i], pts[i + 1]);
                }
                g.stroke();
                g.restore();

                // é›ªçº¿ï¼ˆåªç»™æœ€è¿œä¸¤å±‚ï¼Œé¿å…â€œåˆ°å¤„å‘ç™½â€ï¼‰
                if (layer.snow && !low) {
                    const threshold = (layer.snowLine || 0.75) * layer.amp;
                    g.save();
                    g.globalAlpha = (theme === 'day') ? 0.22 : 0.15;
                    g.strokeStyle = snowStroke;
                    g.lineWidth = 2;
                    g.lineJoin = 'round';
                    g.lineCap = 'round';
                    g.beginPath();
                    let inSeg = false;
                    for (let i = 0; i < pts.length; i += 3) {
                        const x = pts[i];
                        const y = pts[i + 1];
                        const hh = pts[i + 2];
                        if (hh > threshold) {
                            if (!inSeg) { g.moveTo(x, y + 1); inSeg = true; }
                            else g.lineTo(x, y + 1);
                        } else {
                            inSeg = false;
                        }
                    }
                    g.stroke();
                    g.restore();
                }

                return { canvas };
            };

            for (let li = 0; li < layers.length; li++) {
                const layer = layers[li];
                const map = cache.layerMaps[li];

                // cam.x -> â€œå±±è„‰ç©ºé—´â€åç§»ï¼ˆä¸æ—§å®ç°ä¿æŒä¸€è‡´ï¼‰
                const camP = (cam.x || 0) * layer.p;

                // è¦†ç›–èŒƒå›´ï¼šä¸æ—§ç‰ˆä¸€è‡´ï¼Œå·¦å³å¤šç”»ä¸€ç‚¹é¿å…è¾¹ç¼˜éœ²åº•
                const startWX = camP - 80;
                const endWX = camP + w + 80;

                const first = Math.floor(startWX / chunkW);
                const last = Math.floor(endWX / chunkW);

                const keepMin = first - cache.pad;
                const keepMax = last + cache.pad;

                // ç”Ÿæˆç¼ºå¤± chunk
                for (let ci = keepMin; ci <= keepMax; ci++) {
                    if (!map.has(ci)) {
                        map.set(ci, buildChunk(layer, li, ci));
                    }
                }

                // æ¸…ç†è¿œç¦»è§†é‡çš„ chunkï¼ˆæ§åˆ¶å†…å­˜ + Map éå†æˆæœ¬ï¼‰
                for (const k of map.keys()) {
                    if (k < keepMin || k > keepMax) map.delete(k);
                }

                // ç»˜åˆ¶å¯è§ chunkï¼ˆè£å‰ªæ‰ overlap åŒºåŸŸï¼Œæ‹¼æ¥å¤„æ— ç¼ï¼‰
                for (let ci = first; ci <= last; ci++) {
                    const chunk = map.get(ci);
                    if (!chunk || !chunk.canvas) continue;

                    const dx = (ci * chunkW) - camP; // chunkStart - camOffset
                    try {
                        ctx.drawImage(chunk.canvas, over, 0, chunkW, h, dx, 0, chunkW, h);
                    } catch (_) {
                        // æŸäº›æç«¯ç¯å¢ƒä¸‹ OffscreenCanvas.drawImage å¯èƒ½å¤±è´¥ï¼šé™çº§ä¸ºä¸æ¸²æŸ“å±±è„‰ï¼ˆä¸å½±å“æ¸¸æˆï¼‰
                    }
                }
            }

            const fogKey = theme + '|' + h;
            if (!cache.fogGrad || cache.fogKey !== fogKey) {
                const fog = ctx.createLinearGradient(0, h * 0.35, 0, h);
                if (theme === 'day') {
                    fog.addColorStop(0, 'rgba(255,255,255,0.00)');
                    fog.addColorStop(0.72, 'rgba(220,235,255,0.10)');
                    fog.addColorStop(1, 'rgba(200,230,255,0.14)');
                } else if (theme === 'dawn') {
                    fog.addColorStop(0, 'rgba(255,120,180,0.00)');
                    fog.addColorStop(0.72, 'rgba(255,170,140,0.06)');
                    fog.addColorStop(1, 'rgba(190,210,255,0.10)');
                } else if (theme === 'dusk') {
                    fog.addColorStop(0, 'rgba(170,140,255,0.00)');
                    fog.addColorStop(0.72, 'rgba(255,160,120,0.05)');
                    fog.addColorStop(1, 'rgba(140,170,230,0.10)');
                } else {
                    fog.addColorStop(0, 'rgba(190,210,255,0.00)');
                    fog.addColorStop(0.72, 'rgba(160,180,255,0.06)');
                    fog.addColorStop(1, 'rgba(110,140,210,0.12)');
                }
                cache.fogGrad = fog;
                cache.fogKey = fogKey;
            }

            ctx.save();
            ctx.fillStyle = cache.fogGrad;
            ctx.fillRect(0, h * 0.35, w, h);
            ctx.restore();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• æ¸²æŸ“æ‰¹é‡ä¼˜åŒ– â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const RenderBatcher = {
            _batches: new Map(),

            begin() {
                this._batches.clear();
            },

            add(texture, x, y, alpha = 1) {
                if (!this._batches.has(texture)) {
                    this._batches.set(texture, []);
                }
                this._batches.get(texture).push({ x, y, alpha });
            },

            render(ctx) {
                for (const [texture, positions] of this._batches) {
                    ctx.save();
                    for (const pos of positions) {
                        if (pos.alpha !== 1) {
                            ctx.globalAlpha = pos.alpha;
                        }
                        ctx.drawImage(texture, pos.x, pos.y);
                        if (pos.alpha !== 1) {
                            ctx.globalAlpha = 1;
                        }
                    }
                    ctx.restore();
                }
            }
        };

        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = null;
                if (canvas && canvas.getContext) {
                    try { this.ctx = canvas.getContext('2d', { alpha: false, desynchronized: true }); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                    if (!this.ctx) {
                        try { this.ctx = canvas.getContext('2d', { alpha: false }); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                    }
                }
                if (!this.ctx) {
                    throw new Error('Canvas 2D context åˆå§‹åŒ–å¤±è´¥');
                }
                this._pp = {
                    canvas: document.createElement('canvas'),
                    ctx: null,
                    noise: document.createElement('canvas'),
                    nctx: null,
                    seed: 0,
                    _bloom: null
                };
                this._pp.ctx = this._pp.canvas.getContext('2d', { alpha: false });
                this._pp.nctx = this._pp.noise.getContext('2d', { alpha: true });
                this.textures = new TextureGenerator();
                this.enableGlow = true;
                this.lowPower = false;
                this.resolutionScale = 1;

                // Sprint Blur Props
                this._speedBlurAmt = 0;
                this._speedBlurDirX = 1;
                this._speedBlurBuf = null;

                // Caches
                this._tileBuckets = null;
                this._texArr = null;

                this.resize();
                this._resizeRAF = 0;
                this._resizeRafCb = this._resizeRafCb || (() => {
                    this._resizeRAF = 0;
                    this.resize();
                });
                this._onResize = this._onResize || (() => {
                    if (this._resizeRAF) return;
                    this._resizeRAF = requestAnimationFrame(this._resizeRafCb);
                });
                window.addEventListener('resize', this._onResize, { passive: true });
                window.addEventListener('orientationchange', this._onResize, { passive: true });
            }

            resize() {
                const gs = (window.GAME_SETTINGS || {});
                const effCap = (gs && typeof gs.__dprCapEffective === 'number') ? gs.__dprCapEffective : null;
                const dprCap = (effCap && effCap > 0) ? effCap : ((gs && gs.dprCap) ? gs.dprCap : 2);

                // åŸºç¡€ DPRï¼ˆç”¨æˆ·ä¸Šé™ + è®¾å¤‡ DPRï¼‰
                const baseDpr = Math.min(window.devicePixelRatio || 1, dprCap);

                // åŠ¨æ€åˆ†è¾¨ç‡ï¼šé€šè¿‡ resolutionScale è°ƒèŠ‚è´Ÿè½½ï¼Œä½†è¦é¿å…â€œåŠåƒç´ /éæ•´æ•°åƒç´ æ˜ å°„â€é€ æˆçš„ tile ç¼é—ªçƒ
                const scale = (typeof this.resolutionScale === 'number' && isFinite(this.resolutionScale)) ? this.resolutionScale : 1;

                // ç›®æ ‡ DPRï¼ˆå…ˆç®—ï¼Œå†åšé‡åŒ–ï¼‰
                let desiredDpr = Math.max(0.5, Math.min(3, baseDpr * scale));

                // å…³é”®ä¿®å¤ï¼šæŠŠ DPR é‡åŒ–åˆ° 0.25 æ­¥è¿›ï¼ˆ16px tile * 0.25 = 4pxï¼Œèƒ½æ˜¾è‘—é™ä½ tile è¾¹ç¼˜é‡‡æ ·/æ‹¼ç¼é—ªåŠ¨ï¼‰
                const DPR_STEP = 0.25;
                desiredDpr = Math.round(desiredDpr / DPR_STEP) * DPR_STEP;
                desiredDpr = Math.max(0.5, Math.min(3, desiredDpr));

                const wCss = window.innerWidth;
                const hCss = window.innerHeight;

                // å…³é”®ä¿®å¤ï¼šå…ˆæŒ‰å®½åº¦å–æ•´å¾—åˆ°åƒç´ å°ºå¯¸ï¼Œå†åç®—â€œçœŸå® DPRâ€ï¼Œå¹¶ç”¨åŒä¸€ä¸ª DPR æ¨å¯¼é«˜åº¦
                // è¿™æ · setTransform ä¸ canvas å®é™…åƒç´ æ¯”ä¾‹ä¸¥æ ¼ä¸€è‡´ï¼Œé¿å…æ¯æ¬¡ resize çš„å››èˆäº”å…¥è¯¯å·®å¼•èµ·çš„ç½‘æ ¼çº¿é—ªåŠ¨
                const wPx = Math.max(1, Math.round(wCss * desiredDpr));
                const dprActual = wPx / Math.max(1, wCss);
                const hPx = Math.max(1, Math.round(hCss * dprActual));

                // å²è¯—çº§ä¼˜åŒ–ï¼šé¿å…é‡å¤ resize è§¦å‘å¯¼è‡´çš„ canvas åå¤é‡åˆ†é…ï¼ˆæå®¹æ˜“å¼•å‘å¡é¡¿/é—ªé»‘ï¼‰
                if (this.canvas.width === wPx && this.canvas.height === hPx && this.w === wCss && this.h === hCss && Math.abs((this.dpr || 0) - dprActual) < 1e-6) {
                    return;
                }

                this.dpr = dprActual;

                // ç”»å¸ƒå†…éƒ¨åƒç´ ç¼©æ”¾ï¼ˆåŠ¨æ€åˆ†è¾¨ç‡ï¼‰ï¼šä¸å½±å“ UI å¸ƒå±€ï¼Œåªå½±å“æ¸²æŸ“è´Ÿè½½
                this.canvas.width = wPx;
                this.canvas.height = hPx;
                this.canvas.style.width = wCss + 'px';
                this.canvas.style.height = hCss + 'px';

                // PostFX ç¼“å†²åŒºå°ºå¯¸è·Ÿéšä¸»ç”»å¸ƒï¼ˆåƒç´ çº§ï¼‰
                if (this._pp && this._pp.canvas) {
                    this._pp.canvas.width = this.canvas.width;
                    this._pp.canvas.height = this.canvas.height;
                    // å™ªç‚¹çº¹ç†å›ºå®šè¾ƒå°å°ºå¯¸ï¼ŒæŒ‰éœ€é‡å»º
                    const n = this._pp.noise;
                    const nSize = 256;
                    if (n.width !== nSize || n.height !== nSize) {
                        n.width = nSize; n.height = nSize;
                        this._pp.seed = 0;
                    }
                }

                // ç”¨çœŸå® DPR åšå˜æ¢ï¼ˆä¸å®é™…åƒç´ å°ºå¯¸ä¸€è‡´ï¼‰
                this.ctx.setTransform(dprActual, 0, 0, dprActual, 0, 0);
                this.ctx.imageSmoothingEnabled = false;

                // w/h ä»ä»¥ CSS åƒç´ ä½œä¸ºä¸–ç•Œè§†çª—å•ä½
                this.w = wCss;
                this.h = hCss;
            }

            setResolutionScale(scale01) {
                const s = Math.max(0.5, Math.min(1, Number(scale01) || 1));
                if (Math.abs((this.resolutionScale || 1) - s) < 0.001) return;
                this.resolutionScale = s;
                this.resize();
            }

            clear() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.w, this.h);
            }

            renderSky(cam, time) {
                const ctx = this.ctx;
                // Ultra Visual FX v3 Sky Logic
                const kfs = this._skyKeyframes || (this._skyKeyframes = [
                    { t: 0.00, c: ['#0c0c1e', '#1a1a2e', '#16213e'] },
                    { t: 0.22, c: ['#0c0c1e', '#1a1a2e', '#16213e'] },
                    { t: 0.30, c: ['#1a1a2e', '#4a1942', '#ff6b6b'] },
                    { t: 0.36, c: ['#74b9ff', '#81ecec', '#dfe6e9'] },
                    { t: 0.64, c: ['#74b9ff', '#81ecec', '#dfe6e9'] },
                    { t: 0.72, c: ['#6c5ce7', '#fd79a8', '#ffeaa7'] },
                    { t: 0.78, c: ['#0c0c1e', '#1a1a2e', '#16213e'] },
                    { t: 1.00, c: ['#0c0c1e', '#1a1a2e', '#16213e'] }
                ]);

                let i = 0;
                while (i < kfs.length - 2 && time >= kfs[i + 1].t) i++;
                const k0 = kfs[i], k1 = kfs[i + 1];
                const u = (k1.t === k0.t) ? 0 : Math.max(0, Math.min(1, (time - k0.t) / (k1.t - k0.t)));
                const eased = u * u * (3 - 2 * u); // smoothstep
                const colors = k0.c.map((c, idx) => Utils.lerpColor(c, k1.c[idx], eased));

                const grad = ctx.createLinearGradient(0, 0, 0, this.h * 0.75);
                grad.addColorStop(0, colors[0]);
                grad.addColorStop(0.5, colors[1]);
                grad.addColorStop(1, colors[2]);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, this.w, this.h);

                const night = Utils.nightFactor(time);
                // Stars
                if (night > 0.01) {
                    ctx.globalAlpha = night * 0.85;
                    if (!this._starCanvas) {
                        this._starCanvas = document.createElement('canvas');
                        this._starCanvas.width = this.w;
                        this._starCanvas.height = this.h * 0.6;
                        const sctx = this._starCanvas.getContext('2d');
                        for (let j = 0; j < 120; j++) {
                            const sx = Math.random() * this.w;
                            const sy = Math.random() * this.h * 0.5;
                            const size = Math.random() * 1.5 + 0.5;
                            sctx.fillStyle = '#fff';
                            sctx.beginPath();
                            sctx.arc(sx, sy, size, 0, Math.PI * 2);
                            sctx.fill();
                        }
                    }
                    if (this._starCanvas.width !== this.w) { this._starCanvas = null; } // dumb resize check
                    else ctx.drawImage(this._starCanvas, 0, 0);
                    ctx.globalAlpha = 1;
                }

                // Sun/Moon
                const cx = this.w * ((time + 0.25) % 1);
                const cy = this.h * 0.15 + Math.sin(((time + 0.25) % 1) * Math.PI) * (-this.h * 0.1);

                if (time > 0.2 && time < 0.8) {
                    // Sun
                    const sunGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                    sunGlow.addColorStop(0, 'rgba(255, 255, 220, 0.9)');
                    sunGlow.addColorStop(0.3, 'rgba(255, 240, 150, 0.4)');
                    sunGlow.addColorStop(1, 'rgba(255, 200, 50, 0)');
                    ctx.fillStyle = sunGlow;
                    ctx.beginPath(); ctx.arc(cx, cy, 50, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(cx, cy, 18, 0, Math.PI * 2); ctx.fill();
                } else {
                    // Moon
                    ctx.fillStyle = '#f0f0f5';
                    ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#d0d0d8';
                    ctx.beginPath(); ctx.arc(cx - 6, cy - 4, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx + 8, cy + 6, 4, 0, Math.PI * 2); ctx.fill();
                }

                // --- TU Mount Fix Logic (DISABLED) ---
                // Mountains are now drawn from a single authoritative call site in
                // Game.prototype.render (see "Mountain Rendering Patch v2" below).
                // Drawing them inside renderSky caused double-draws, cache
                // interference, and desync with the sky/lighting system.
            }

            renderParallax(cam, time = 0.5) {
                renderParallaxMountains(this, cam, time);
            }

            renderWorld(world, cam, time) {
                if (!world || !world.tiles || !world.light) return;

                const ctx = this.ctx;
                const ts = CONFIG.TILE_SIZE;
                const startX = Math.max(0, ((cam.x / ts) | 0) - 1);
                const startY = Math.max(0, ((cam.y / ts) | 0) - 1);
                const endX = Math.min(world.w - 1, startX + ((this.w / ts) | 0) + 3);
                const endY = Math.min(world.h - 1, startY + ((this.h / ts) | 0) + 3);
                const camCeilX = Math.ceil(cam.x);
                const camCeilY = Math.ceil(cam.y);
                const lut = window.BLOCK_LIGHT_LUT;
                if (!lut) return;

                // Prepare Bucket
                const bucket = this._getBucketState();
                bucket.reset();
                const texArr = this._ensureTexArray();

                const tiles = world.tiles;
                const light = world.light;
                const BL = window.BLOCK_LIGHT;
                const AIR = (window.BLOCK && window.BLOCK.AIR) || 0;

                // Fill buckets
                // Check for flatified world (optimization)
                if (world.tilesFlat && world.lightFlat && world.tilesFlat.length === world.w * world.h) {
                    const H = world.h | 0;
                    const tf = world.tilesFlat;
                    const lf = world.lightFlat;
                    for (let x = startX; x <= endX; x++) {
                        const base = x * H;
                        for (let y = startY; y <= endY; y++) {
                            const idx = base + y;
                            const block = tf[idx] | 0;
                            if (block === AIR) continue;

                            const px = x * ts - camCeilX;
                            const py = y * ts - camCeilY;
                            const pp = ((px & 0xffff) << 16) | (py & 0xffff);

                            const bl = BL[block] | 0;
                            if (bl > 5) {
                                if (bucket.glowLists[block].length === 0) bucket.glowKeys.push(block);
                                bucket.glowLists[block].push(pp);
                            }

                            const lv = lf[idx] & 255;
                            const a = lut[lv];
                            if (a) {
                                if (bucket.darkLists[lv].length === 0) bucket.darkKeys.push(lv);
                                bucket.darkLists[lv].push(pp);
                            }
                        }
                    }
                } else {
                    // Legacy array of arrays
                    for (let x = startX; x <= endX; x++) {
                        const colT = tiles[x];
                        const colL = light[x];
                        for (let y = startY; y <= endY; y++) {
                            const block = colT[y] | 0;
                            if (block === AIR) continue;

                            const px = x * ts - camCeilX;
                            const py = y * ts - camCeilY;
                            const pp = ((px & 0xffff) << 16) | (py & 0xffff);

                            const bl = BL[block] | 0;
                            if (bl > 5) {
                                if (bucket.glowLists[block].length === 0) bucket.glowKeys.push(block);
                                bucket.glowLists[block].push(pp);
                            }
                            const lv = colL[y] & 255;
                            const a = lut[lv];
                            if (a) {
                                if (bucket.darkLists[lv].length === 0) bucket.darkKeys.push(lv);
                                bucket.darkLists[lv].push(pp);
                            }
                        }
                    }
                }

                // Render Glow Tiles
                if (this.enableGlow) {
                    ctx.shadowBlur = 0; // optimized handling inside loop? no, batch shadow change
                    // Group by block to share shadow color
                    for (let i = 0; i < bucket.glowKeys.length; i++) {
                        const bid = bucket.glowKeys[i];
                        const list = bucket.glowLists[bid];
                        const tex = texArr ? texArr[bid] : this.textures.get(bid);
                        if (!tex) continue;

                        const color = BLOCK_COLOR[bid] || '#fff';
                        const bl = BL[bid];
                        ctx.shadowColor = color;
                        ctx.shadowBlur = bl * 2;

                        for (let j = 0; j < list.length; j++) {
                            const p = list[j];
                            ctx.drawImage(tex, (p >> 16) & 0xffff, p & 0xffff);
                        }
                    }
                    ctx.shadowBlur = 0;
                } else {
                    // No glow, just draw
                    for (let i = 0; i < bucket.glowKeys.length; i++) {
                        const bid = bucket.glowKeys[i];
                        const list = bucket.glowLists[bid];
                        const tex = texArr ? texArr[bid] : this.textures.get(bid);
                        if (!tex) continue;
                        for (let j = 0; j < list.length; j++) {
                            const p = list[j];
                            ctx.drawImage(tex, (p >> 16) & 0xffff, p & 0xffff);
                        }
                    }
                }

                // Render Dark Mask
                ctx.fillStyle = '#000';
                bucket.darkKeys.sort((a, b) => a - b);
                for (let i = 0; i < bucket.darkKeys.length; i++) {
                    const lv = bucket.darkKeys[i];
                    const list = bucket.darkLists[lv];
                    ctx.globalAlpha = lut[lv];
                    ctx.beginPath();
                    for (let j = 0; j < list.length; j++) {
                        const p = list[j];
                        ctx.rect((p >> 16) & 0xffff, p & 0xffff, ts, ts);
                    }
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            renderHighlight(tx, ty, cam, inRange) {
                const ctx = this.ctx;
                const ts = CONFIG.TILE_SIZE;
                const sx = tx * ts - Math.ceil(cam.x);
                const sy = ty * ts - Math.ceil(cam.y);

                if (inRange) {
                    // å‘å…‰é€‰æ¡†
                    ctx.shadowColor = '#ffeaa7';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = 'rgba(255, 234, 167, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sx, sy, ts, ts);
                    ctx.shadowBlur = 0;

                    ctx.fillStyle = 'rgba(255, 234, 167, 0.15)';
                    ctx.fillRect(sx, sy, ts, ts);
                } else {
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(sx, sy, ts, ts);
                }
            }

            // Unified Post Process (incorporating Sprint Blur and Ultra Visuals)
            applyPostFX(time, depth01, reducedMotion) {
                // 1. Sprint Blur (Speed Lines)
                const amtRaw = (typeof this._speedBlurAmt === 'number') ? this._speedBlurAmt : 0;
                const amt = Math.max(0, Math.min(1, amtRaw));

                if (!reducedMotion && amt > 0.04) {
                    try {
                        const canvas = this.canvas;
                        const wPx = canvas.width | 0;
                        const hPx = canvas.height | 0;

                        let buf = this._speedBlurBuf;
                        if (!buf) {
                            const c = document.createElement('canvas');
                            const ctx = c.getContext('2d', { alpha: false });
                            buf = this._speedBlurBuf = { c, ctx };
                        }
                        if (buf.c.width !== wPx || buf.c.height !== hPx) {
                            buf.c.width = wPx;
                            buf.c.height = hPx;
                        }

                        const bctx = buf.ctx;
                        bctx.setTransform(1, 0, 0, 1, 0, 0);
                        bctx.globalCompositeOperation = 'copy';
                        bctx.globalAlpha = 1;

                        // Directional blur simulation
                        const blurPx = Math.min(2.6, 0.7 + amt * 1.4);
                        bctx.filter = `blur(${blurPx.toFixed(2)}px)`;
                        bctx.drawImage(canvas, 0, 0);
                        bctx.filter = 'none';

                        const ctx = this.ctx;
                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);

                        const dir = (this._speedBlurDirX === -1) ? -1 : 1;
                        const off = (-dir) * Math.min(18, (4 + amt * 11));

                        ctx.globalCompositeOperation = 'screen';
                        ctx.globalAlpha = Math.min(0.22, 0.06 + amt * 0.14);
                        ctx.drawImage(buf.c, off, 0);

                        ctx.globalAlpha = Math.min(0.18, 0.04 + amt * 0.10);
                        ctx.drawImage(buf.c, off * 0.5, 0);
                        ctx.restore();
                    } catch (_) { }
                }

                // 2. Ultra Visual FX Logic
                const gs = (window.GAME_SETTINGS || {});
                let mode = (typeof gs.__postFxModeEffective === 'number') ? gs.__postFxModeEffective : Number(gs.postFxMode);
                if (!Number.isFinite(mode)) mode = 2;
                if (mode <= 0) return;
                if (this.lowPower && mode > 1) mode = 1;

                const ctx = this.ctx;
                const canvas = this.canvas;
                const dpr = this.dpr || 1;
                const wPx = canvas.width;
                const hPx = canvas.height;

                const night = Utils.nightFactor(time);
                const dusk = Math.max(0, 1 - Math.abs(time - 0.72) / 0.08);
                const dawn = Math.max(0, 1 - Math.abs(time - 0.34) / 0.08);
                const warm = Utils.clamp(dawn * 0.9 + dusk * 1.1, 0, 1);
                const cool = Utils.clamp(night * 0.9, 0, 1);

                const d = Utils.clamp(depth01 || 0, 0, 1);
                const underground = Utils.smoothstep(0.22, 0.62, d);

                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                // A) Mode 2: Bloom
                if (mode >= 2) {
                    const pp = this._pp;
                    if (pp && pp.canvas && pp.ctx) {
                        const bctx = pp.ctx;
                        bctx.setTransform(1, 0, 0, 1, 0, 0);
                        bctx.globalCompositeOperation = 'copy';
                        bctx.filter = 'none';
                        bctx.globalAlpha = 1;
                        bctx.drawImage(canvas, 0, 0);

                        // Grading
                        const contrast = 1.05 + warm * 0.03 + night * 0.06 + underground * 0.03;
                        const saturate = 1.07 + warm * 0.05 + cool * 0.03 - underground * 0.05;
                        const brightness = 1.01 + warm * 0.015 - cool * 0.008 - underground * 0.015;

                        ctx.globalCompositeOperation = 'copy';
                        ctx.filter = `contrast(${contrast.toFixed(3)}) saturate(${saturate.toFixed(3)}) brightness(${brightness.toFixed(3)})`;
                        ctx.drawImage(pp.canvas, 0, 0);
                        ctx.filter = 'none';

                        // Bloom
                        // (simplified for conciseness, assuming similar logic to v3)
                        const bloomBase = 0.33 + night * 0.10 + underground * 0.06;
                        const blur1 = Math.max(1, Math.round(2.5 * dpr));

                        ctx.globalCompositeOperation = 'screen';
                        ctx.filter = `blur(${blur1}px) brightness(1.2)`;
                        ctx.globalAlpha = bloomBase;
                        ctx.drawImage(pp.canvas, 0, 0);

                        ctx.filter = 'none';
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.globalAlpha = 1;
                    }
                }

                // B) Fog, Vignette, Grain (simplified)
                const fogAmt = Utils.smoothstep(0.18, 0.62, d) * (0.60 + night * 0.25);
                if (fogAmt > 0) {
                    const fog = ctx.createLinearGradient(0, hPx * 0.4, 0, hPx);
                    fog.addColorStop(0, 'rgba(30,20,50,0)');
                    fog.addColorStop(1, `rgba(30,20,50,${(0.25 * fogAmt).toFixed(2)})`);
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = fog;
                    ctx.fillRect(0, 0, wPx, hPx);
                }

                const vig = (0.2 + night * 0.2) * (mode === 1 ? 0.9 : 1);
                if (vig > 0.01) {
                    // simplified vignette
                    const vg = ctx.createRadialGradient(wPx / 2, hPx / 2, wPx * 0.3, wPx / 2, hPx / 2, wPx * 0.8);
                    vg.addColorStop(0, 'rgba(0,0,0,0)');
                    vg.addColorStop(1, `rgba(0,0,0,${vig.toFixed(2)})`);
                    ctx.fillStyle = vg;
                    ctx.fillRect(0, 0, wPx, hPx);
                }

                ctx.restore();
            }

            postProcess(time = 0.5) {
                this.applyPostFX(time, 0, false);
            }

            // --- Helper Methods (Consolidated from patches) ---

            renderBackgroundCached(cam, time, drawParallax = true) {
                // â”€â”€ Mountain Rendering Patch v2 â”€â”€
                // This method now ONLY caches the sky gradient + celestial bodies.
                // Mountains are drawn exclusively by Game.prototype.render after
                // this method returns, eliminating double-draw and cache-desync bugs.
                this._ensureBgCache();
                const bg = this._bgCache;
                if (!bg || !bg.canvas || !bg.ctx) {
                    this.renderSky(cam, time);
                    // Mountains intentionally NOT drawn here; Game.render handles them.
                    return;
                }

                this._resizeBgCache();

                const now = performance.now();
                const dt = now - (bg.lastAt || 0);
                const refreshInterval = this.lowPower ? 4600 : 750;
                const t = (typeof time === 'number' && isFinite(time)) ? time : (bg.lastTime || 0);

                // Check triggers
                const bucket = this._getSkyBucket(t);
                const bucketChanged = (bucket !== bg.lastBucket);
                const skyKey = this._getSkyKey(t, bucket);
                const skyKeyChanged = (skyKey != null && skyKey !== bg.lastSkyKey);
                const timeChanged = Math.abs(t - (bg.lastTime || 0)) > (this.lowPower ? 0.018 : 0.01);
                const needUpdate = !!bg.dirty || bucketChanged || skyKeyChanged || (dt >= refreshInterval && timeChanged);

                if (needUpdate) {
                    bg.dirty = false;
                    bg.lastAt = now;
                    bg.lastTime = t;
                    bg.lastBucket = bucket;
                    bg.lastSkyKey = skyKey;

                    const origCtx = this.ctx;
                    this.ctx = bg.ctx;
                    this._bgCacheDrawing = true;
                    try {
                        bg.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
                        bg.ctx.imageSmoothingEnabled = false;
                        bg.ctx.clearRect(0, 0, this.w, this.h);
                        this.renderSky(cam, t); // Only sky, not parallax
                    } finally {
                        this._bgCacheDrawing = false;
                        this.ctx = origCtx;
                    }
                }

                this.ctx.drawImage(bg.canvas, 0, 0, this.w, this.h);
                // Mountains intentionally NOT drawn here; Game.render handles them.
            }

            _ensureBgCache() {
                if (this._bgCache) return;
                const c = document.createElement('canvas');
                c.width = this.canvas.width;
                c.height = this.canvas.height;
                this._bgCache = {
                    canvas: c,
                    ctx: c.getContext('2d', { alpha: false }),
                    wPx: c.width,
                    hPx: c.height,
                    dirty: true
                };
            }

            _resizeBgCache() {
                const bg = this._bgCache;
                if (!bg) return;
                const w = this.canvas.width;
                const h = this.canvas.height;
                if (bg.wPx !== w || bg.hPx !== h) {
                    bg.canvas.width = w;
                    bg.canvas.height = h;
                    bg.wPx = w;
                    bg.hPx = h;
                    bg.dirty = true;
                }
            }

            _getSkyBucket(t) {
                // Simple bucket to avoid thrashing
                return (t * 100) | 0;
            }

            _getSkyKey(t, bucket) {
                // Simplified signature for sky color
                return bucket;
            }

            _ensureTexArray() {
                if (!this.textures || typeof this.textures.get !== 'function') return null;
                if (this._texArr && this._texArrMap === this.textures) return this._texArr;
                this._texArr = new Array(256).fill(null);
                try { this.textures.forEach((v, k) => { this._texArr[k & 255] = v; }); } catch (_) { }
                this._texArrMap = this.textures;
                return this._texArr;
            }

            _getBucketState() {
                if (this._tileBuckets) return this._tileBuckets;
                this._tileBuckets = {
                    glowKeys: [],
                    glowLists: new Array(256),
                    darkKeys: [],
                    darkLists: new Array(256),
                    reset() {
                        for (let i = 0; i < this.glowKeys.length; i++) this.glowLists[this.glowKeys[i]].length = 0;
                        for (let i = 0; i < this.darkKeys.length; i++) this.darkLists[this.darkKeys[i]].length = 0;
                        this.glowKeys.length = 0;
                        this.darkKeys.length = 0;
                    }
                };
                for (let i = 0; i < 256; i++) {
                    this._tileBuckets.glowLists[i] = [];
                    this._tileBuckets.darkLists[i] = [];
                }
                return this._tileBuckets;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                   é…æ–¹æ•°æ®
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const RECIPES = [
            { out: BLOCK.PLANKS, count: 4, req: [{ id: BLOCK.LOG, count: 1 }], desc: "åŸºç¡€å»ºç­‘ææ–™ï¼Œç”±åŸæœ¨åŠ å·¥è€Œæˆã€‚" },
            { out: BLOCK.TORCH, count: 4, req: [{ id: BLOCK.WOOD, count: 1 }], desc: "ç…§äº®é»‘æš—çš„å¿…éœ€å“ã€‚" },
            { out: BLOCK.BRICK, count: 4, req: [{ id: BLOCK.CLAY, count: 2 }], desc: "åšå›ºçš„çº¢è‰²ç –å—ã€‚" },
            { out: BLOCK.GLASS, count: 2, req: [{ id: BLOCK.SAND, count: 2 }], desc: "é€æ˜çš„è£…é¥°æ–¹å—ã€‚" },
            { out: BLOCK.TREASURE_CHEST, count: 1, req: [{ id: BLOCK.WOOD, count: 8 }], desc: "ç”¨äºå‚¨å­˜ç‰©å“çš„ç®±å­ã€‚" },
            { out: BLOCK.LANTERN, count: 1, req: [{ id: BLOCK.TORCH, count: 1 }, { id: BLOCK.IRON_ORE, count: 1 }], desc: "æ¯”ç«æŠŠæ›´ä¼˜é›…çš„ç…§æ˜å·¥å…·ã€‚" },
            { out: BLOCK.FROZEN_STONE, count: 4, req: [{ id: BLOCK.ICE, count: 2 }, { id: BLOCK.STONE, count: 2 }], desc: "å¯’å†·çš„å»ºç­‘çŸ³æã€‚" },
            { out: BLOCK.GLOWSTONE, count: 1, req: [{ id: BLOCK.GLASS, count: 1 }, { id: BLOCK.TORCH, count: 2 }], desc: "äººé€ å‘å…‰çŸ³å—ã€‚" },
            { out: BLOCK.METEORITE_BRICK, count: 4, req: [{ id: BLOCK.METEORITE, count: 1 }, { id: BLOCK.STONE, count: 1 }], desc: "æ¥è‡ªå¤–å¤ªç©ºçš„å»ºç­‘ææ–™ã€‚" },
            { out: BLOCK.RAINBOW_BRICK, count: 10, req: [{ id: BLOCK.CRYSTAL, count: 1 }, { id: BLOCK.BRICK, count: 10 }], desc: "æ•£å‘ç€å½©è™¹å…‰èŠ’çš„ç –å—ã€‚" },
            { out: BLOCK.PARTY_BLOCK, count: 5, req: [{ id: BLOCK.PINK_FLOWER, count: 1 }, { id: BLOCK.DIRT, count: 5 }], desc: "è®©æ¯ä¸€å¤©éƒ½å˜æˆæ´¾å¯¹ï¼" },
            { out: BLOCK.WOOD, count: 1, req: [{ id: BLOCK.PLANKS, count: 2 }], desc: "å°†æœ¨æ¿è¿˜åŸä¸ºæœ¨æã€‚" },
            { out: BLOCK.BONE, count: 2, req: [{ id: BLOCK.STONE, count: 1 }], desc: "ç”±çŸ³å¤´é›•åˆ»è€Œæˆçš„éª¨å¤´å½¢çŠ¶ã€‚" },
            { out: BLOCK.HAY, count: 4, req: [{ id: BLOCK.TALL_GRASS, count: 8 }], desc: "å¹²è‰å †ï¼Œé€‚åˆå»ºé€ å†œåœºã€‚" }
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                  åˆæˆç³»ç»Ÿ

        const RECIPES = [
            { out: BLOCK.PLANKS, count: 4, req: [{ id: BLOCK.LOG, count: 1 }], desc: "åŸºç¡€å»ºç­‘ææ–™ï¼Œç”±åŸæœ¨åŠ å·¥è€Œæˆã€‚" },
            { out: BLOCK.TORCH, count: 4, req: [{ id: BLOCK.WOOD, count: 1 }], desc: "ç…§äº®é»‘æš—çš„å¿…éœ€å“ã€‚" },
            { out: BLOCK.BRICK, count: 4, req: [{ id: BLOCK.CLAY, count: 2 }], desc: "åšå›ºçš„çº¢è‰²ç –å—ã€‚" },
            { out: BLOCK.GLASS, count: 2, req: [{ id: BLOCK.SAND, count: 2 }], desc: "é€æ˜çš„è£…é¥°æ–¹å—ã€‚" },
            { out: BLOCK.TREASURE_CHEST, count: 1, req: [{ id: BLOCK.WOOD, count: 8 }], desc: "ç”¨äºå‚¨å­˜ç‰©å“çš„ç®±å­ã€‚" },
            { out: BLOCK.LANTERN, count: 1, req: [{ id: BLOCK.TORCH, count: 1 }, { id: BLOCK.IRON_ORE, count: 1 }], desc: "æ¯”ç«æŠŠæ›´ä¼˜é›…çš„ç…§æ˜å·¥å…·ã€‚" },
            { out: BLOCK.FROZEN_STONE, count: 4, req: [{ id: BLOCK.ICE, count: 2 }, { id: BLOCK.STONE, count: 2 }], desc: "å¯’å†·çš„å»ºç­‘çŸ³æã€‚" },
            { out: BLOCK.GLOWSTONE, count: 1, req: [{ id: BLOCK.GLASS, count: 1 }, { id: BLOCK.TORCH, count: 2 }], desc: "äººé€ å‘å…‰çŸ³å—ã€‚" },
            { out: BLOCK.METEORITE_BRICK, count: 4, req: [{ id: BLOCK.METEORITE, count: 1 }, { id: BLOCK.STONE, count: 1 }], desc: "æ¥è‡ªå¤–å¤ªç©ºçš„å»ºç­‘ææ–™ã€‚" },
            { out: BLOCK.RAINBOW_BRICK, count: 10, req: [{ id: BLOCK.CRYSTAL, count: 1 }, { id: BLOCK.BRICK, count: 10 }], desc: "æ•£å‘ç€å½©è™¹å…‰èŠ’çš„ç –å—ã€‚" },
            { out: BLOCK.PARTY_BLOCK, count: 5, req: [{ id: BLOCK.PINK_FLOWER, count: 1 }, { id: BLOCK.DIRT, count: 5 }], desc: "è®©æ¯ä¸€å¤©éƒ½å˜æˆæ´¾å¯¹ï¼" },
            { out: BLOCK.WOOD, count: 1, req: [{ id: BLOCK.PLANKS, count: 2 }], desc: "å°†æœ¨æ¿è¿˜åŸä¸ºæœ¨æã€‚" },
            { out: BLOCK.BONE, count: 2, req: [{ id: BLOCK.STONE, count: 1 }], desc: "ç”±çŸ³å¤´é›•åˆ»è€Œæˆçš„éª¨å¤´å½¢çŠ¶ã€‚" },
            { out: BLOCK.HAY, count: 4, req: [{ id: BLOCK.TALL_GRASS, count: 8 }], desc: "å¹²è‰å †ï¼Œé€‚åˆå»ºé€ å†œåœºã€‚" }
        ];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 14: UI Systems
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class CraftingSystem {
            constructor(game) {
                this.game = game;
                this.isOpen = false;
                this.selectedRecipe = null;

                this.overlay = document.getElementById('crafting-overlay');
                this.grid = document.getElementById('craft-grid');
                this.closeBtn = document.getElementById('craft-close');
                this.craftBtn = document.getElementById('craft-action-btn');
                this.toggleBtn = document.getElementById('btn-craft-toggle');

                this._init();
            }

            _init() {
                this.closeBtn.addEventListener('click', () => this.close());
                this.toggleBtn.addEventListener('click', () => this.toggle());
                this.craftBtn.addEventListener('click', () => this.craft());

                // ç‚¹å‡»é®ç½©å…³é—­
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) this.close();
                });
            }

            toggle() {
                if (this.isOpen) this.close();
                else this.open();
            }

            open() {
                this.isOpen = true;
                if (Utils && Utils.resetGameInput) Utils.resetGameInput(this.game);
                this.overlay.classList.add('open');
                this.refresh();
                this.selectRecipe(this.selectedRecipe || RECIPES[0]);
            }

            close() {
                this.isOpen = false;
                this.overlay.classList.remove('open');
            }

            refresh() {
                this.grid.innerHTML = '';

                RECIPES.forEach(recipe => {
                    const canCraft = this._canCraft(recipe);
                    const slot = document.createElement('div');
                    slot.className = `craft-slot ${canCraft ? 'can-craft' : ''}`;
                    if (this.selectedRecipe === recipe) slot.classList.add('selected');

                    // ç»˜åˆ¶å›¾æ ‡
                    const tex = this.game.renderer.textures.get(recipe.out);
                    if (tex) {
                        const c = document.createElement('canvas');
                        c.width = 32; c.height = 32;
                        const ctx = c.getContext('2d', { willReadFrequently: true });
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(tex, 0, 0, 32, 32);
                        slot.appendChild(c);
                    }

                    slot.addEventListener('click', () => this.selectRecipe(recipe));
                    this.grid.appendChild(slot);
                });
            }

            selectRecipe(recipe) {
                this.selectedRecipe = recipe;

                // æ›´æ–°ç½‘æ ¼é€‰ä¸­çŠ¶æ€
                const slots = this.grid.children;
                RECIPES.forEach((r, i) => {
                    if (slots[i]) slots[i].classList.toggle('selected', r === recipe);
                });

                // æ›´æ–°è¯¦æƒ…
                const info = BLOCK_DATA[recipe.out];
                document.getElementById('craft-title').textContent = `${info.name} (x${recipe.count})`;
                document.getElementById('craft-desc').textContent = recipe.desc;

                // é¢„è§ˆå›¾
                const preview = document.getElementById('craft-preview');
                preview.innerHTML = '';
                const tex = this.game.renderer.textures.get(recipe.out);
                if (tex) {
                    const c = document.createElement('canvas');
                    c.width = 48; c.height = 48;
                    const ctx = c.getContext('2d', { willReadFrequently: true });
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(tex, 0, 0, 48, 48);
                    preview.appendChild(c);
                }

                // åŸæ–™åˆ—è¡¨
                const ingList = document.getElementById('craft-ingredients');
                ingList.innerHTML = '';
                let allHave = true;

                recipe.req.forEach(req => {
                    const have = this._countItem(req.id);
                    const needed = req.count;
                    const isEnough = have >= needed;
                    if (!isEnough) allHave = false;

                    const reqInfo = BLOCK_DATA[req.id];

                    const div = document.createElement('div');
                    div.className = `ingredient ${isEnough ? '' : 'missing'}`;
                    div.innerHTML = `
                <span class="ing-name">${reqInfo.name}</span>
                <span class="ing-count ${isEnough ? 'ok' : 'bad'}">${have}/${needed}</span>
            `;
                    ingList.appendChild(div);
                });

                // æŒ‰é’®çŠ¶æ€
                this.craftBtn.disabled = !allHave;
                this.craftBtn.textContent = allHave ? "åˆ¶é€ " : "ææ–™ä¸è¶³";
            }

            craft() {
                if (!this.selectedRecipe || !this._canCraft(this.selectedRecipe)) return;

                // æ‰£é™¤ææ–™
                this.selectedRecipe.req.forEach(req => {
                    this._consumeItem(req.id, req.count);
                });

                // æ·»åŠ ç»“æœ
                this.game._addToInventory(this.selectedRecipe.out, this.selectedRecipe.count);

                // åˆ·æ–°ç•Œé¢
                this.refresh();
                this.selectRecipe(this.selectedRecipe);

                // æ›´æ–°å¿«æ·æ 
                this.game.ui.buildHotbar();
            }

            _canCraft(recipe) {
                return recipe.req.every(req => this._countItem(req.id) >= req.count);
            }

            _countItem(id) {
                let count = 0;
                for (const item of this.game.player.inventory) {
                    if (item.id === id) count += item.count;
                }
                return count;
            }

            _consumeItem(id, count) {
                let remaining = count;
                for (const item of this.game.player.inventory) {
                    if (item.id === id) {
                        const take = Math.min(item.count, remaining);
                        item.count -= take;
                        remaining -= take;
                        if (remaining <= 0) break;
                    }
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                   UIç®¡ç†å™¨ (ç¾åŒ–ç‰ˆ)

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { CraftingSystem });

            class UIFlushScheduler {
                constructor() {
                    this._map = new Map();
                    this._order = [];
                    this._flushing = false;
                }

                enqueue(key, fn) {
                    if (!key || typeof fn !== 'function') return;
                    const k = String(key);
                    if (!this._map.has(k)) this._order.push(k);
                    this._map.set(k, fn);
                }

                clear() {
                    this._map.clear();
                    this._order.length = 0;
                }

                flush() {
                    if (this._flushing) return;
                    if (this._order.length === 0) return;

                    this._flushing = true;
                    try {
                        for (let i = 0; i < this._order.length; i++) {
                            const k = this._order[i];
                            const fn = this._map.get(k);
                            if (fn) {
                                try { fn(); } catch (e) { /* å•ä¸ª UI å†™å…¥å¤±è´¥ä¸å½±å“ä¸»å¾ªç¯ */ }
                            }
                        }
                    } finally {
                        this.clear();
                        this._flushing = false;
                    }
                }
            }

            TU.UIFlushScheduler = UIFlushScheduler;

            class QualityManager {
                constructor(game) {
                    this.game = game;
                    this.device = detectDevice();

                    this.state = {
                        hidden: !!(typeof document !== 'undefined' && document.hidden),
                        fps: 60,
                        level: (game && game._perf && game._perf.level) ? game._perf.level : 'high',
                        reason: 'init',
                    };

                    this.effective = {};
                    this._last = { __dprCapEffective: null };

                    // åˆæ¬¡ä¸‹å‘ï¼ˆä¸ä¾èµ–åç»­ patchï¼‰
                    this.apply({ force: true, reason: 'init' });
                }

                onVisibilityChange(hidden) {
                    this.state.hidden = !!hidden;
                    this.apply({ force: true, reason: hidden ? 'hidden' : 'visible' });
                }

                onSettingsChanged() {
                    this.apply({ force: true, reason: 'settings' });
                }

                onFpsSample(fps, spanMs = 500) {
                    if (!isNum(fps)) return;

                    const g = this.game;
                    const gs = (g && g.settings) ? g.settings : (window.GAME_SETTINGS || {});
                    const auto = !!(gs && gs.autoQuality);

                    this.state.fps = fps;

                    const p = (g && g._perf) ? g._perf : null;
                    const span = isNum(spanMs) ? spanMs : 500;

                    if (this.state.hidden) {
                        this.apply({ force: false, reason: 'hidden-fps' });
                        return;
                    }

                    if (p) {
                        if (auto) {
                            if (fps < 45) { p.lowForMs = (p.lowForMs || 0) + span; p.highForMs = 0; }
                            else if (fps > 56) { p.highForMs = (p.highForMs || 0) + span; p.lowForMs = 0; }
                            else { p.lowForMs = 0; p.highForMs = 0; }

                            // ä½ç«¯è®¾å¤‡ï¼šæ›´ç§¯æé™çº§ï¼ˆé¿å…æŠ–åŠ¨ï¼‰
                            const wantLow = (p.lowForMs >= 1000) || (this.device.lowEnd && p.lowForMs >= 600);
                            const wantHigh = (p.highForMs >= 1400);

                            if (wantLow && p.level !== 'low') {
                                p.level = 'low';
                                this.state.level = 'low';
                                this.state.reason = 'fps-low';
                                if (typeof g._setQuality === 'function') g._setQuality('low');
                            } else if (wantHigh && p.level !== 'high') {
                                p.level = 'high';
                                this.state.level = 'high';
                                this.state.reason = 'fps-high';
                                if (typeof g._setQuality === 'function') g._setQuality('high');
                            }
                        } else {
                            // å…³é—­è‡ªåŠ¨ç”»è´¨ï¼šä¿æŒé«˜ç”»è´¨ï¼ˆå°Šé‡ç”¨æˆ·æ˜¾å¼é€‰æ‹©ï¼‰
                            p.lowForMs = 0; p.highForMs = 0;
                            if (p.level !== 'high') {
                                p.level = 'high';
                                this.state.level = 'high';
                                this.state.reason = 'manual';
                                if (typeof g._setQuality === 'function') g._setQuality('high');
                            }
                        }
                    }

                    // åŠ¨æ€åˆ†è¾¨ç‡ï¼ˆautoQuality æ‰å¯ç”¨ï¼‰
                    this._updateResolutionScale(fps, auto);

                    // ä¸‹å‘å…¶å®ƒé¢‘ç‡/å¼€å…³
                    this.apply({ force: false, reason: 'fps' });
                }

                _updateResolutionScale(fps, auto) {
                    const g = this.game;
                    if (!g || !g.renderer || typeof g.renderer.setResolutionScale !== 'function') return;

                    // å†…éƒ¨çŠ¶æ€ï¼ˆç”¨äºèŠ‚æµä¸æ»å›ï¼Œé¿å…é¢‘ç¹ resize é€ æˆâ€œç½‘æ ¼çº¿é—ªåŠ¨â€ï¼‰
                    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                    const st = this._dynResState || (this._dynResState = { good: 0, bad: 0, lastChange: 0 });

                    if (!auto) {
                        // ç”¨æˆ·æ‰‹åŠ¨ï¼šè¿˜åŸåˆ° 1ï¼ˆé¿å…â€œæˆ‘å…³äº†è‡ªåŠ¨ç”»è´¨ä½†è¿˜æ˜¯ç³Šâ€çš„å›°æƒ‘ï¼‰
                        st.good = 0; st.bad = 0; st.lastChange = now;
                        if (g.renderer.resolutionScale !== 1) g.renderer.setResolutionScale(1);
                        return;
                    }

                    const level = (g._perf && g._perf.level) ? g._perf.level : this.state.level;
                    const low = (level === 'low');

                    let minScale = low ? 0.75 : 0.82;
                    if (this.device.lowEnd) minScale -= 0.04;
                    minScale = clamp(minScale, 0.6, 1);

                    const t01 = clamp((fps - 28) / (50 - 28), 0, 1);
                    const target = minScale + (1 - minScale) * t01;

                    // å…³é”®ä¿®å¤ï¼šé‡åŒ–åˆ°å›ºå®šæ­¥è¿›ï¼Œå¹¶å¢åŠ æ»å›/èŠ‚æµï¼Œé¿å… 500ms ä¸€æ¬¡çš„å°å¹…å˜åŒ–è§¦å‘ resize
                    const STEP = 0.125; // 1/8ï¼šé…åˆ DPR_STEP=0.25ï¼ˆå½“ baseDprâ‰ˆ2 æ—¶ï¼‰ï¼Œèƒ½æ›´ç¨³å®šåœ°è½åœ¨ tile åƒç´ ç½‘æ ¼ä¸Š
                    const clamp01 = (v) => clamp(v, 0.5, 1);
                    const quant = (v) => clamp01(Math.round(v / STEP) * STEP);

                    const curRaw = isNum(g.renderer.resolutionScale) ? g.renderer.resolutionScale : 1;
                    const cur = quant(curRaw);
                    const want = quant(target);

                    // å·²ç»åœ¨åŒä¸€æ¡£ï¼šæŠŠå®é™…å€¼è½»å¾®â€œå¸é™„â€åˆ°æ¡£ä½ï¼Œé¿å…æ¼‚ç§»
                    if (Math.abs(want - cur) < (STEP * 0.5)) {
                        st.good = 0; st.bad = 0;
                        if (Math.abs(curRaw - cur) > 0.002) g.renderer.setResolutionScale(cur);
                        return;
                    }

                    const dirDown = (want < cur);

                    // ä¸€æ¬¡åªå˜åŠ¨ä¸€æ¡£ï¼Œé¿å…çªç„¶è·³å˜
                    const next = dirDown ? (cur - STEP) : (cur + STEP);
                    const nextClamped = clamp01(next);

                    if (dirDown) {
                        st.bad += 1; st.good = 0;

                        // é™æ¡£è¦å¿«ä¸€ç‚¹ï¼Œä½†ä¹Ÿä¸è¦æŠ–ï¼šè‡³å°‘é—´éš” 350ms
                        if (st.bad >= 1 && (now - st.lastChange) > 350) {
                            g.renderer.setResolutionScale(nextClamped);
                            st.lastChange = now;
                            st.bad = 0;
                        }
                    } else {
                        st.good += 1; st.bad = 0;

                        // å‡æ¡£æ›´ä¿å®ˆï¼šéœ€è¦è¿ç»­â€œå¥½å¸§â€æ ·æœ¬ï¼Œå¹¶ä¸”æ›´é•¿å†·å´ï¼Œé˜²æ­¢ä¸Šä¸‹åå¤
                        if (st.good >= 3 && (now - st.lastChange) > 1600) {
                            g.renderer.setResolutionScale(nextClamped);
                            st.lastChange = now;
                            st.good = 0;
                        }
                    }
                }

                _computeEffective() {
                    const g = this.game;
                    const gs = (g && g.settings) ? g.settings : (window.GAME_SETTINGS || {});
                    const auto = !!gs.autoQuality;
                    const hidden = !!this.state.hidden;
                    const level = (g && g._perf && g._perf.level) ? g._perf.level : this.state.level;

                    // DPR capï¼šç”¨æˆ·å€¼ä¸ºä¸Šé™ï¼›autoQuality æ—¶å†å åŠ è®¾å¤‡/ä½å¸§çº¦æŸ
                    const userDpr = isNum(gs.dprCap) ? gs.dprCap : 2;
                    const deviceCap = (this.device.mobile && this.device.lowEnd) ? 1.5 : 2;

                    let dprCap = userDpr;
                    if (hidden) dprCap = 1;
                    else if (auto) {
                        dprCap = Math.min(dprCap, deviceCap);
                        if (level === 'low') dprCap = Math.min(dprCap, this.device.mobile ? 1.25 : 1.5);
                    }

                    // ç²’å­ä¸Šé™ï¼šå°Šé‡å¼€å…³ï¼ˆparticles=false => 0ï¼‰
                    const particlesEnabled = !!gs.particles;
                    let particlesMax = particlesEnabled ? 400 : 0;
                    if (hidden) particlesMax = 0;
                    else if (auto) {
                        if (level === 'low') particlesMax = this.device.lowEnd ? 160 : 220;
                        else if (this.device.lowEnd) particlesMax = 260;
                    }

                    // å°åœ°å›¾åˆ·æ–°é¢‘ç‡ï¼ˆé‡å»ºèŠ‚æµï¼‰
                    let minimapIntervalMs = 120;
                    if (hidden) minimapIntervalMs = 400;
                    else if (auto) {
                        if (level === 'low') minimapIntervalMs = this.device.lowEnd ? 220 : 180;
                        else if (this.device.lowEnd) minimapIntervalMs = 150;
                    }

                    // å…‰ç…§åˆ·æ–°é¢‘ç‡ï¼ˆåˆå¹¶èŠ‚æµï¼‰
                    let lightIntervalMs = 0;
                    if (hidden) lightIntervalMs = 200;
                    else if (auto) {
                        if (level === 'low') lightIntervalMs = this.device.lowEnd ? 90 : 60;
                        else if (this.device.lowEnd) lightIntervalMs = 30;
                    }

                    // åæœŸç‰¹æ•ˆï¼šautoQuality/ä½ç«¯æœº è‡ªåŠ¨ä¸Šé™
                    const userPostFx = isNum(gs.postFxMode) ? gs.postFxMode : 2;
                    let postFxMode = userPostFx;
                    if (hidden) postFxMode = 0;
                    else if (auto) {
                        if (level === 'low') postFxMode = Math.min(postFxMode, 1);
                        else if (this.device.lowEnd) postFxMode = Math.min(postFxMode, 1);
                    }

                    // èƒŒæ™¯å±±è„‰ï¼šç”¨æˆ·å¼€å…³ + autoQuality ä½æ¡£/åå°ä¸´æ—¶ç¦ç”¨
                    const userMountains = (gs.bgMountains !== undefined) ? !!gs.bgMountains : true;
                    let bgMountains = userMountains;
                    if (hidden) bgMountains = false;
                    else if (auto && level === 'low') bgMountains = false;

                    // æ¸²æŸ“ç‰¹æ•ˆå¼€å…³ï¼šè¾‰å…‰åœ¨ä½æ¡£/åå°å…³é—­
                    const enableGlow = (!hidden) && (!auto || level !== 'low');
                    const lowPower = hidden || (auto && level === 'low');

                    return {
                        level, hidden,
                        dprCap,
                        particlesMax,
                        minimapIntervalMs,
                        lightIntervalMs,
                        postFxMode,
                        bgMountains,
                        enableGlow,
                        lowPower,
                    };
                }

                apply({ force = false, reason = '' } = {}) {
                    const g = this.game;
                    if (!g) return;

                    const eff = this._computeEffective();
                    this.effective = eff;
                    if (reason) this.state.reason = reason;

                    // ä¸‹å‘åˆ°å…¨å±€ settingsï¼ˆéæšä¸¾ï¼Œé¿å…å­˜ç›˜æ±¡æŸ“ï¼‰
                    const gs = (window.GAME_SETTINGS || g.settings || null);
                    if (gs) {
                        defineRuntimeSetting(gs, '__dprCapEffective', eff.dprCap);
                        defineRuntimeSetting(gs, '__postFxModeEffective', eff.postFxMode);
                        defineRuntimeSetting(gs, '__bgMountainsEffective', eff.bgMountains);
                        // é¢å¤–ä¸‹å‘ï¼šæ–¹ä¾¿å…¶å®ƒæ¨¡å—/æ ·å¼æ ¹æ®â€œä½åŠŸè€—â€åšé™çº§ï¼ˆéæšä¸¾ï¼Œé¿å…å­˜ç›˜æ±¡æŸ“ï¼‰
                        defineRuntimeSetting(gs, '__lowPowerEffective', !!eff.lowPower);
                        defineRuntimeSetting(gs, '__enableGlowEffective', !!eff.enableGlow);
                    }

                    // åŒæ­¥åˆ° DOMï¼šä½åŠŸè€—ï¼ˆautoQuality é™æ¡£/åå°ï¼‰æ—¶é™ä½ UI ç‰¹æ•ˆå¼€é”€
                    try {
                        if (typeof document !== 'undefined' && document.documentElement) {
                            document.documentElement.classList.toggle('tu-low-power', !!eff.lowPower);
                        }
                    } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                    // ç²’å­ä¸Šé™
                    if (g.particles && typeof g.particles.max === 'number') {
                        if (force || g.particles.max !== eff.particlesMax) g.particles.max = eff.particlesMax;
                    }

                    // å°åœ°å›¾é‡å»ºèŠ‚æµ
                    if (g.minimap) {
                        if (force || g.minimap.buildIntervalMs !== eff.minimapIntervalMs) g.minimap.buildIntervalMs = eff.minimapIntervalMs;
                    }

                    // å…‰ç…§åˆ·æ–°èŠ‚æµ
                    if (force || g._lightIntervalMs !== eff.lightIntervalMs) g._lightIntervalMs = eff.lightIntervalMs;

                    // æ¸²æŸ“å™¨å¼€å…³
                    if (g.renderer) {
                        if (force || g.renderer.enableGlow !== eff.enableGlow) g.renderer.enableGlow = eff.enableGlow;
                        if (force || g.renderer.lowPower !== eff.lowPower) g.renderer.lowPower = eff.lowPower;
                    }

                    // DPR cap å˜åŒ–ï¼šè§¦å‘ resizeï¼ˆé¿å…æ¯å¸§ resizeï¼‰
                    const last = this._last.__dprCapEffective;
                    if (force || !isNum(last) || Math.abs(last - eff.dprCap) > 0.01) {
                        this._last.__dprCapEffective = eff.dprCap;
                        if (g.renderer && typeof g.renderer.resize === 'function') g.renderer.resize();
                    }
                }
            }

            TU.QualityManager = QualityManager;

        class UIManager {
            constructor(player, textures, uiFlush) {
                this.uiFlush = uiFlush || null;
                this.player = player;
                this.textures = textures;

                // ç¼“å­˜é«˜é¢‘ DOM å¼•ç”¨ï¼ˆé¿å…æ¯å¸§ getElementById/querySelectorï¼‰
                this.hotbarEl = document.getElementById('hotbar');
                this.miningBarEl = document.getElementById('mining-bar');
                this.itemHintEl = document.getElementById('item-hint');

                this.healthFillEl = document.getElementById('health-fill');
                this.manaFillEl = document.getElementById('mana-fill');
                this.healthValueEl = document.getElementById('health-value');
                this.manaValueEl = document.getElementById('mana-value');

                this.timeTextEl = document.getElementById('time-text');
                this.timeIconEl = document.getElementById('time-icon');

                this.miningFillEl = this.miningBarEl ? this.miningBarEl.querySelector('.fill') : null;

                // æ–°ç‰ˆæŒ–æ˜ HUDï¼šåç§°/ç™¾åˆ†æ¯”/å›¾æ ‡ï¼ˆæ›´ç¨³ + æ›´å¥½çœ‹ï¼‰
                this.miningNameEl = document.getElementById('mining-name');
                this.miningPercentEl = document.getElementById('mining-percent');
                this.miningIconEl = document.getElementById('mining-icon');
                this.miningIconCtx = this.miningIconEl ? this.miningIconEl.getContext('2d', { willReadFrequently: true }) : null;
                if (this.miningIconCtx) this.miningIconCtx.imageSmoothingEnabled = false;

                // æŒ–æ˜ HUD ç¼“å­˜ï¼ˆå‡å°‘é‡å¤å†™ DOMï¼‰
                this._miningVisible = false;
                this._miningLastId = null;
                this._miningLastPct = -1;
                this._miningLastWidth = '';
                this._miningHideTimer = 0;
                this._miningDimW = 200;
                this._miningDimH = 56;
                this._miningDimMeasured = false;

                // å˜æ›´æ£€æµ‹ï¼ˆä¸æ”¹å˜æ˜¾ç¤ºï¼Œåªå‡å°‘é‡å¤å†™ DOMï¼‰
                this._lastHp = -1;
                this._lastMaxHp = -1;
                this._lastMp = -1;
                this._lastMaxMp = -1;
                this._lastHpWidth = '';
                this._lastMpWidth = '';
                this._lastHpText = '';
                this._lastMpText = '';

                this._lastTimeStr = '';
                this._lastTimeIcon = '';
                this._hintTimer = 0;
                this._lastHintText = '';

                this.buildHotbar();

                // ç§»åŠ¨ç«¯ï¼šå¿«æ·æ æ”¯æŒå·¦å³æ»‘åŠ¨åˆ‡æ¢ï¼ˆæ›´å®¹æ˜“å•æ‰‹æ“ä½œï¼‰
                if (Utils && Utils.isMobile && Utils.isMobile()) {
                    this._bindHotbarSwipe();
                }

                // é¦–æ¬¡ï¼šåŒæ­¥ä¸€æ¬¡ç‰©å“æç¤º
                this._updateItemHint(false);
            }

            buildHotbar() {
                const HOTBAR_SIZE = 9; // å¿«æ·æ å›ºå®š9æ ¼

                // é¦–æ¬¡æ„å»ºï¼šåˆ›å»º DOMï¼Œå¹¶ç¼“å­˜å¼•ç”¨ï¼›åç»­åªåšâ€œå¢é‡æ›´æ–°â€ï¼Œé¿å…é¢‘ç¹ innerHTML/åˆ›å»º canvas
                if (!this._hotbarSlots) {
                    this._hotbarSlots = new Array(HOTBAR_SIZE);
                    this._hotbarCanvases = new Array(HOTBAR_SIZE);
                    this._hotbarCtx = new Array(HOTBAR_SIZE);
                    this._hotbarCountEls = new Array(HOTBAR_SIZE);
                    this._hotbarLastId = new Array(HOTBAR_SIZE).fill(null);

                    this.hotbarEl.innerHTML = '';

                    for (let i = 0; i < HOTBAR_SIZE; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'slot';

                        if (!Utils.isMobile()) {
                            const key = document.createElement('span');
                            key.className = 'key';
                            key.textContent = String(i + 1);
                            slot.appendChild(key);
                        }

                        // pickaxe iconï¼ˆå¤ç”¨ï¼Œä¸ç”¨æ¯æ¬¡åˆ›å»ºï¼‰
                        const pickaxeIcon = document.createElement('span');
                        pickaxeIcon.className = 'item-icon';
                        pickaxeIcon.textContent = 'â›ï¸';
                        pickaxeIcon.style.display = 'none';
                        slot.appendChild(pickaxeIcon);
                        slot._pickaxeIcon = pickaxeIcon;

                        // ç‰©å“è´´å›¾ canvasï¼ˆå¤ç”¨ï¼‰
                        const c = document.createElement('canvas');
                        c.width = c.height = 32;
                        c.style.display = 'none';
                        const cx = c.getContext('2d', { willReadFrequently: true });
                        cx.imageSmoothingEnabled = false;
                        slot.appendChild(c);

                        // æ•°é‡æ ‡ç­¾ï¼ˆå¤ç”¨ï¼‰
                        const count = document.createElement('span');
                        count.className = 'count';
                        count.style.display = 'none';
                        slot.appendChild(count);

                        // äº‹ä»¶ç»‘å®šä¸€æ¬¡å³å¯
                        slot.addEventListener('click', () => this.selectSlot(i));
                        slot.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            this.selectSlot(i);
                        }, { passive: false });

                        this.hotbarEl.appendChild(slot);

                        this._hotbarSlots[i] = slot;
                        this._hotbarCanvases[i] = c;
                        this._hotbarCtx[i] = cx;
                        this._hotbarCountEls[i] = count;
                    }
                }

                for (let i = 0; i < HOTBAR_SIZE; i++) {
                    const item = this.player.inventory[i]; // å¯èƒ½ä¸º undefined
                    const slot = this._hotbarSlots[i];
                    const canvas = this._hotbarCanvases[i];
                    const cx = this._hotbarCtx[i];
                    const countEl = this._hotbarCountEls[i];
                    const pickaxeIcon = slot._pickaxeIcon;

                    slot.classList.toggle('active', i === this.player.selectedSlot);

                    // å¦‚æœæ²¡æœ‰ç‰©å“æˆ–æ•°é‡ä¸º0ï¼Œæ·»åŠ emptyæ ·å¼
                    const empty = (!item || (item.count === 0 && item.id !== 'pickaxe'));
                    slot.classList.toggle('empty', empty);

                    if (!item || item.count === 0) {
                        pickaxeIcon.style.display = 'none';
                        canvas.style.display = 'none';
                        countEl.style.display = 'none';
                        this._hotbarLastId[i] = null;
                        continue;
                    }

                    if (item.id === 'pickaxe') {
                        pickaxeIcon.style.display = '';
                        canvas.style.display = 'none';
                        countEl.style.display = 'none';
                        this._hotbarLastId[i] = 'pickaxe';
                        continue;
                    }

                    // æ™®é€šæ–¹å—/ç‰©å“
                    pickaxeIcon.style.display = 'none';
                    canvas.style.display = '';

                    // ä»…åœ¨ç‰©å“ç±»å‹å˜åŒ–æ—¶é‡ç»˜ iconï¼ˆcount å˜åŒ–åªæ›´æ–°æ–‡å­—ï¼‰
                    if (this._hotbarLastId[i] !== item.id) {
                        cx.clearRect(0, 0, 32, 32);
                        const tex = this.textures.get(item.id);
                        if (tex) cx.drawImage(tex, 0, 0, 32, 32);
                        this._hotbarLastId[i] = item.id;
                    }

                    if (item.count >= 1) {
                        countEl.textContent = String(item.count);
                        countEl.style.display = '';
                    } else {
                        countEl.style.display = 'none';
                    }
                }

                // åŒæ­¥é€‰ä¸­ç‰©å“æç¤ºï¼ˆè®¡æ•°å˜åŒ–ä¹Ÿä¼šæ›´æ–°ï¼Œä½†ä¸å¼ºåˆ¶æ˜¾ç¤ºï¼‰
                this._updateItemHint(false);

                // é€šçŸ¥èƒŒåŒ…/å…¶å®ƒ UI åˆ·æ–°ï¼ˆé¿å…ç›´æ¥è€¦åˆ Game å®ä¾‹ï¼‰
                try {
                    document.dispatchEvent(new CustomEvent('tu:inventoryChanged'));
                } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
            }

            selectSlot(i) {
                this.player.selectedSlot = i;

                // èµ°ç¼“å­˜å¼•ç”¨ï¼Œé¿å…æ¯æ¬¡ querySelectorAll
                if (this._hotbarSlots) {
                    for (let j = 0; j < this._hotbarSlots.length; j++) {
                        this._hotbarSlots[j].classList.toggle('active', i === j);
                    }
                } else {
                    this.hotbarEl.querySelectorAll('.slot').forEach((el, j) => el.classList.toggle('active', i === j));
                }
                this._updateItemHint(true);
            }

            _updateItemHint(forceShow) {
                if (!this.itemHintEl) return;

                const item = this.player.getItem();
                let text = '';
                if (!item) {
                    text = 'ç©ºæ‰‹';
                } else if (item.id === 'pickaxe') {
                    text = 'â›ï¸ é•å­';
                } else {
                    const meta = (typeof BLOCK_DATA === 'object' && BLOCK_DATA[item.id]) ? BLOCK_DATA[item.id] : null;
                    const name = (meta && meta.name) ? meta.name : ('æ–¹å— #' + item.id);
                    const count = (typeof item.count === 'number') ? item.count : 0;
                    text = name + (count >= 1 ? (' Ã—' + count) : '');
                }

                // ä»…å½“å†…å®¹å˜åŒ–æ—¶å†™ DOM
                if (text !== this._lastHintText) {
                    this.itemHintEl.textContent = text;
                    this._lastHintText = text;
                }

                // é€‰ä¸­/åˆ‡æ¢ç‰©å“æ—¶çŸ­æš‚æ˜¾ç¤ºä¸€ä¸‹ï¼Œé¿å…é•¿æœŸå ä½
                if (forceShow) {
                    this.itemHintEl.classList.add('show');
                    clearTimeout(this._hintTimer);
                    this._hintTimer = setTimeout(() => {
                        try { this.itemHintEl.classList.remove('show'); } catch { }
                    }, 1400);
                }
            }

            _bindHotbarSwipe() {
                if (!this.hotbarEl) return;

                let active = false;
                let startX = 0;
                let startY = 0;
                const threshold = 22; // pxï¼šè¶Šå°è¶Šæ•æ„Ÿ

                const onStart = (e) => {
                    if (!e.touches || e.touches.length !== 1) return;
                    active = true;
                    const t = e.touches[0];
                    startX = t.clientX;
                    startY = t.clientY;
                };
                const onMove = (e) => {
                    if (!active || !e.touches || e.touches.length !== 1) return;
                    const t = e.touches[0];
                    const dx = t.clientX - startX;
                    const dy = t.clientY - startY;

                    // æ˜æ˜¾çºµå‘æ»‘åŠ¨ï¼šæ”¾è¡Œï¼ˆé¿å…ä¸é¡µé¢/é¢æ¿æ»šåŠ¨å†²çªï¼‰
                    if (Math.abs(dy) > Math.abs(dx) * 1.2) return;

                    if (Math.abs(dx) >= threshold) {
                        e.preventDefault();
                        const dir = dx < 0 ? 1 : -1; // å·¦æ»‘=ä¸‹ä¸€ä¸ªï¼Œå³æ»‘=ä¸Šä¸€ä¸ª
                        const size = 9;
                        const next = (this.player.selectedSlot + dir + size) % size;
                        this.selectSlot(next);

                        // è½»å¾®éœ‡åŠ¨åé¦ˆï¼ˆå¯é€‰ï¼‰
                        try {
                            if (window.GAME_SETTINGS && window.GAME_SETTINGS.vibration && navigator.vibrate) navigator.vibrate(4);
                        } catch { }

                        startX = t.clientX;
                        startY = t.clientY;
                    }
                };
                const onEnd = () => { active = false; };

                this.hotbarEl.addEventListener('touchstart', onStart, { passive: true });
                this.hotbarEl.addEventListener('touchmove', onMove, { passive: false });
                this.hotbarEl.addEventListener('touchend', onEnd, { passive: true });
                this.hotbarEl.addEventListener('touchcancel', onEnd, { passive: true });
            }

            updateStats() {
                const p = this.player;
                const hp = p.health, maxHp = p.maxHealth;
                const mp = p.mana, maxMp = p.maxMana;

                const flush = this.uiFlush;
                const enqueue = (key, fn) => {
                    if (flush && typeof flush.enqueue === 'function') flush.enqueue(key, fn);
                    else fn();
                };

                if (hp !== this._lastHp || maxHp !== this._lastMaxHp) {
                    const w = (hp / maxHp * 100) + '%';
                    if (w !== this._lastHpWidth) {
                        const el = this.healthFillEl;
                        const v = w;
                        enqueue('hud:hp:fill', () => { if (el) el.style.width = v; });
                        this._lastHpWidth = w;
                    }
                    const t = `${hp}/${maxHp}`;
                    if (t !== this._lastHpText) {
                        const el = this.healthValueEl;
                        const v = t;
                        enqueue('hud:hp:text', () => { if (el) el.textContent = v; });
                        this._lastHpText = t;
                    }
                    this._lastHp = hp;
                    this._lastMaxHp = maxHp;
                }

                if (mp !== this._lastMp || maxMp !== this._lastMaxMp) {
                    const w = (mp / maxMp * 100) + '%';
                    if (w !== this._lastMpWidth) {
                        const el = this.manaFillEl;
                        const v = w;
                        enqueue('hud:mp:fill', () => { if (el) el.style.width = v; });
                        this._lastMpWidth = w;
                    }
                    const t = `${mp}/${maxMp}`;
                    if (t !== this._lastMpText) {
                        const el = this.manaValueEl;
                        const v = t;
                        enqueue('hud:mp:text', () => { if (el) el.textContent = v; });
                        this._lastMpText = t;
                    }
                    this._lastMp = mp;
                    this._lastMaxMp = maxMp;
                }
            }

            updateTime(timeOfDay) {
                const hours = Math.floor(timeOfDay * 24);
                const minutes = Math.floor((timeOfDay * 24 - hours) * 60);
                const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

                const flush = this.uiFlush;
                const enqueue = (key, fn) => {
                    if (flush && typeof flush.enqueue === 'function') flush.enqueue(key, fn);
                    else fn();
                };

                if (timeStr !== this._lastTimeStr) {
                    const el = this.timeTextEl;
                    const v = timeStr;
                    enqueue('hud:time:text', () => { if (el) el.textContent = v; });
                    this._lastTimeStr = timeStr;
                }

                const icon = timeOfDay > 0.25 && timeOfDay < 0.75 ? 'â˜€ï¸' : 'ğŸŒ™';
                if (icon !== this._lastTimeIcon) {
                    const el = this.timeIconEl;
                    const v = icon;
                    enqueue('hud:time:icon', () => { if (el) el.textContent = v; });
                    this._lastTimeIcon = icon;
                }
            }

            showMining(x, y, progress, blockId) {
                if (!this.miningBarEl || !this.miningFillEl) return;

                // Clamp progress
                let p = Number(progress);
                if (!Number.isFinite(p)) p = 0;
                if (p < 0) p = 0;
                if (p > 1) p = 1;

                // Show (fade-in)
                if (!this._miningVisible) {
                    this._miningVisible = true;
                    clearTimeout(this._miningHideTimer);
                    this.miningBarEl.style.display = 'block';
                    try { void this.miningBarEl.offsetWidth; } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                    this.miningBarEl.classList.add('show');

                    // Measure once for smarter clamping
                    if (!this._miningDimMeasured) {
                        try {
                            const r = this.miningBarEl.getBoundingClientRect();
                            if (r && r.width) {
                                this._miningDimW = r.width;
                                this._miningDimH = r.height;
                                this._miningDimMeasured = true;
                            }
                        } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                    }
                }

                // Update label/icon only when target changes
                if (typeof blockId === 'number' && blockId !== this._miningLastId) {
                    this._miningLastId = blockId;

                    // Name
                    let name = '';
                    try {
                        const meta = (typeof BLOCK_DATA === 'object' && BLOCK_DATA && BLOCK_DATA[blockId]) ? BLOCK_DATA[blockId] : null;
                        name = (meta && meta.name) ? meta.name : ('æ–¹å— #' + blockId);
                    } catch (_) {
                        name = 'æ–¹å— #' + blockId;
                    }
                    if (this.miningNameEl) this.miningNameEl.textContent = name;

                    // Accent color based on block
                    try {
                        const col = (typeof BLOCK_COLOR === 'object' && BLOCK_COLOR && BLOCK_COLOR[blockId]) ? BLOCK_COLOR[blockId] : '#ffeaa7';
                        this.miningBarEl.style.setProperty('--mb-accent', col);
                    } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                    // Icon
                    if (this.miningIconCtx && this.miningIconEl) {
                        try {
                            const w = this.miningIconEl.width || 18;
                            const h = this.miningIconEl.height || 18;
                            this.miningIconCtx.clearRect(0, 0, w, h);

                            const tex = (this.textures && this.textures.get) ? this.textures.get(blockId) : null;
                            if (tex) {
                                this.miningIconCtx.drawImage(tex, 0, 0, w, h);
                            } else {
                                const col = (typeof BLOCK_COLOR === 'object' && BLOCK_COLOR && BLOCK_COLOR[blockId]) ? BLOCK_COLOR[blockId] : '#ffeaa7';
                                this.miningIconCtx.fillStyle = col;
                                this.miningIconCtx.fillRect(0, 0, w, h);
                            }
                        } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                    }
                }

                // Percent text
                const pct = Math.round(p * 100);
                if (this.miningPercentEl && pct !== this._miningLastPct) {
                    this.miningPercentEl.textContent = pct + '%';
                    this._miningLastPct = pct;
                }

                // Fill width (cache to reduce writes)
                const wStr = (p * 100).toFixed(1) + '%';
                if (wStr !== this._miningLastWidth) {
                    this.miningFillEl.style.width = wStr;
                    this._miningLastWidth = wStr;
                }

                // Position (anchor at bottom-center)
                const vw = window.innerWidth || 0;
                const vh = window.innerHeight || 0;
                const mw = this._miningDimW || 200;
                const mh = this._miningDimH || 56;
                const margin = 10;

                let sx = Number(x);
                let sy = Number(y);
                if (!Number.isFinite(sx)) sx = vw * 0.5;
                if (!Number.isFinite(sy)) sy = vh * 0.5;

                // Slight gap above target tile/cursor
                sy = sy - 8;

                const cx = Math.max(margin + mw * 0.5, Math.min(vw - margin - mw * 0.5, sx));
                const cy = Math.max(margin + mh, Math.min(vh - margin, sy));

                this.miningBarEl.style.left = cx + 'px';
                this.miningBarEl.style.top = cy + 'px';
            }

            hideMining() {
                if (!this.miningBarEl) return;

                if (!this._miningVisible) {
                    this.miningBarEl.style.display = 'none';
                    return;
                }

                this._miningVisible = false;
                this.miningBarEl.classList.remove('show');

                clearTimeout(this._miningHideTimer);
                this._miningHideTimer = setTimeout(() => {
                    if (!this._miningVisible) {
                        try { this.miningBarEl.style.display = 'none'; } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                    }
                }, 160);
            }

        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                   å°åœ°å›¾ (ç¾åŒ–ç‰ˆ)

        class Minimap {
            constructor(world) {
                this.canvas = document.getElementById('minimap-canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.ctx.imageSmoothingEnabled = false;
                this._lastBuildAt = 0;
                this.buildIntervalMs = 120; // å¯ç”± QualityManager åŠ¨æ€ä¸‹å‘

                this.world = world;
                this.canvas.width = 160;
                this.canvas.height = 100;

                // é™æ€åº•å›¾ï¼šOffscreenCanvasï¼ˆæ”¯æŒæ—¶ï¼‰/ å†…å­˜ canvasï¼ˆå›é€€ï¼‰
                const off = (typeof OffscreenCanvas !== 'undefined')
                    ? new OffscreenCanvas(160, 100)
                    : document.createElement('canvas');
                off.width = 160;
                off.height = 100;
                this._mapCanvas = off;
                this._mapCtx = off.getContext('2d', { willReadFrequently: true });
                this._mapCtx.imageSmoothingEnabled = false;

                this.imageData = this._mapCtx.createImageData(160, 100);
                this.dirty = true;
            }

            update() {
                if (!this.dirty) return;

                // å²è¯—çº§ä¼˜åŒ–ï¼šå°åœ°å›¾é‡å»ºèŠ‚æµï¼ˆæŒ–æ˜/æ”¾ç½®è¿å‘æ—¶é¿å…é¢‘ç¹ putImageDataï¼‰
                const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                const interval = (typeof this.buildIntervalMs === 'number' && isFinite(this.buildIntervalMs))
                    ? Math.max(30, this.buildIntervalMs)
                    : 120;
                if (this._lastBuildAt && (now - this._lastBuildAt) < interval) return;
                this._lastBuildAt = now;

                const tiles = this.world.tiles;
                const w = this.world.w;
                const h = this.world.h;

                const sx = w / 160;
                const sy = h / 100;
                const surfaceY = h * CONFIG.SURFACE_LEVEL;

                const data = this.imageData.data;
                let idx = 0;

                // æ”¹ä¸º y å¤–å±‚ / x å†…å±‚ï¼ŒæŒ‰å†…å­˜é¡ºåºå†™å…¥ ImageDataï¼Œæ›´å¿«ä¸”ä¸æ”¹å˜æ•ˆæœ
                for (let y = 0; y < 100; y++) {
                    const wy = Math.floor(y * sy);
                    const isSky = wy < surfaceY;

                    for (let x = 0; x < 160; x++) {
                        const wx = Math.floor(x * sx);
                        const b = tiles[wx][wy];

                        let r, g, bl;
                        if (b === BLOCK.AIR) {
                            if (isSky) { r = 116; g = 185; bl = 255; }
                            else { r = 30; g = 25; bl = 40; }
                        } else {
                            const packed = BLOCK_COLOR_PACKED[b];
                            r = (packed >> 16) & 255;
                            g = (packed >> 8) & 255;
                            bl = packed & 255;
                        }

                        data[idx++] = r;
                        data[idx++] = g;
                        data[idx++] = bl;
                        data[idx++] = 255;
                    }
                }

                // å†™å…¥ç¦»å±åº•å›¾ï¼ˆé™æ€ï¼‰
                this._mapCtx.putImageData(this.imageData, 0, 0);
                this.dirty = false;
            }

            render(px, py) {
                // æ¯å¸§ä»…åšä¸€æ¬¡ drawImage + ç”»ç©å®¶ç‚¹ï¼Œé¿å…ç©å®¶ç‚¹â€œæ‹–å°¾â€
                this.ctx.drawImage(this._mapCanvas, 0, 0);
                this.renderPlayer(px, py);
            }

            renderPlayer(px, py) {
                const mx = (px / CONFIG.TILE_SIZE / this.world.w) * 160;
                const my = (py / CONFIG.TILE_SIZE / this.world.h) * 100;

                // å‘å…‰ç©å®¶ç‚¹
                this.ctx.shadowColor = '#ffeaa7';
                this.ctx.shadowBlur = 6;
                this.ctx.fillStyle = '#ffeaa7';
                this.ctx.beginPath();
                this.ctx.arc(mx, my, 3, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }

            invalidate() { this.dirty = true; }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                    æ¸¸æˆä¸»ç±»
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                               ç³»ç»Ÿåˆ†å±‚ï¼ˆå¯ç»´æŠ¤æ€§ï¼‰

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { Minimap });

        class InventoryUI {
            /** @param {Game} game */
            constructor(game) {
                this.game = game;

                this.isOpen = false;
                this.MAX_SIZE = (window.INVENTORY_LIMITS && INVENTORY_LIMITS.MAX_SIZE) ? INVENTORY_LIMITS.MAX_SIZE : 36;
                this.MAX_STACK = (window.INVENTORY_LIMITS && INVENTORY_LIMITS.MAX_STACK) ? INVENTORY_LIMITS.MAX_STACK : 999;
                this.EMPTY_ID = '__empty__';

                this.overlay = document.getElementById('inventory-overlay');
                this.panel = document.getElementById('inventory-panel');

                this.hotbarGrid = document.getElementById('inv-hotbar-grid');
                this.backpackGrid = document.getElementById('inv-backpack-grid');

                this.closeBtn = document.getElementById('inv-close');
                this.capacityText = document.getElementById('inv-capacity-text');
                this.capacityFill = document.getElementById('inv-capacity-fill');

                this.previewBox = document.getElementById('inv-preview');
                this.nameEl = document.getElementById('inv-item-name');
                this.metaEl = document.getElementById('inv-item-meta');
                this.descEl = document.getElementById('inv-item-desc');

                this.btnSort = document.getElementById('inv-sort');
                this.btnToHotbar = document.getElementById('inv-to-hotbar');
                this.btnPutBack = document.getElementById('inv-put-back');
                this.btnDrop = document.getElementById('inv-drop');

                this.btnTop = document.getElementById('btn-inventory');
                this.btnFloat = document.getElementById('btn-bag-toggle');

                this.heldEl = document.getElementById('inv-held');

                this._slotEls = new Array(this.MAX_SIZE);
                this._slotCanvases = new Array(this.MAX_SIZE);
                this._slotCtx = new Array(this.MAX_SIZE);
                this._slotCountEls = new Array(this.MAX_SIZE);
                this._slotEmojiEls = new Array(this.MAX_SIZE);
                this._lastId = new Array(this.MAX_SIZE).fill(null);
                this._lastCount = new Array(this.MAX_SIZE).fill(-1);

                this._selectedIdx = 0;
                this._cursorItem = null;
                this._cursorFrom = -1;

                this._previewCanvas = document.createElement('canvas');
                this._previewCanvas.width = this._previewCanvas.height = 56;
                this._previewCtx = this._previewCanvas.getContext('2d', { willReadFrequently: true });
                this._previewCtx.imageSmoothingEnabled = false;

                this._previewEmoji = document.createElement('span');
                this._previewEmoji.className = 'item-icon';
                this._previewEmoji.style.display = 'none';

                this.previewBox.innerHTML = '';
                this.previewBox.appendChild(this._previewEmoji);
                this.previewBox.appendChild(this._previewCanvas);
                this._previewCanvas.style.display = 'none';

                this._heldCanvas = document.createElement('canvas');
                this._heldCanvas.width = this._heldCanvas.height = 34;
                this._heldCtx = this._heldCanvas.getContext('2d', { willReadFrequently: true });
                this._heldCtx.imageSmoothingEnabled = false;

                this._heldEmoji = document.createElement('span');
                this._heldEmoji.className = 'item-icon';
                this._heldEmoji.style.display = 'none';

                this._heldCount = document.createElement('span');
                this._heldCount.className = 'count';

                this.heldEl.innerHTML = '';
                this.heldEl.appendChild(this._heldEmoji);
                this.heldEl.appendChild(this._heldCanvas);
                this.heldEl.appendChild(this._heldCount);

                this._buildSlots();
                this._bind();
                this.ensureCapacity();
                this.refresh(true);

                // hotbar/buildHotbar ä¼šå‘å‡ºäº‹ä»¶ï¼ŒèƒŒåŒ…æ‰“å¼€æ—¶è·Ÿéšæ›´æ–°
                document.addEventListener('tu:inventoryChanged', () => {
                    if (this.isOpen) this.refresh(false);
                });
            }

            ensureCapacity() {
                const inv = this.game.player.inventory;
                for (let i = 0; i < this.MAX_SIZE; i++) {
                    if (!inv[i]) inv[i] = { id: this.EMPTY_ID, name: '', count: 0 };
                    if (inv[i].count == null) inv[i].count = 0;
                    if (!('id' in inv[i])) inv[i].id = this.EMPTY_ID;
                    if (!('name' in inv[i])) inv[i].name = '';
                }
            }

            toggle() { this.isOpen ? this.close() : this.open(); }

            open() {
                if (this.game.crafting && this.game.crafting.isOpen) this.game.crafting.close();
                this.ensureCapacity();
                this.isOpen = true;
                if (Utils && Utils.resetGameInput) Utils.resetGameInput(this.game);
                this.overlay.classList.add('open');
                this.overlay.setAttribute('aria-hidden', 'false');
                this._selectedIdx = (this.game.player && Number.isFinite(this.game.player.selectedSlot)) ? this.game.player.selectedSlot : 0;
                this.refresh(true);
                this._updateDetails();
            }

            close() {
                this._returnCursorItem();
                this.isOpen = false;
                this.overlay.classList.remove('open');
                this.overlay.setAttribute('aria-hidden', 'true');
                this._hideHeld();
            }

            /** @returns {boolean} */
            isBlockingInput() { return this.isOpen; }

            refresh(force = false) {
                this.ensureCapacity();

                const inv = this.game.player.inventory;
                const player = this.game.player;

                // å®¹é‡
                let used = 0;
                for (let i = 0; i < this.MAX_SIZE; i++) {
                    const it = inv[i];
                    if (it && it.count > 0) used++;
                }
                if (this.capacityText) this.capacityText.textContent = `${used}/${this.MAX_SIZE}`;
                if (this.capacityFill) this.capacityFill.style.width = `${Math.min(100, (used / this.MAX_SIZE) * 100)}%`;

                // slots
                for (let i = 0; i < this.MAX_SIZE; i++) {
                    const it = inv[i];
                    const empty = (!it || (it.count === 0 && it.id !== 'pickaxe'));
                    const slot = this._slotEls[i];

                    slot.classList.toggle('empty', empty);
                    slot.classList.toggle('active', (i < 9) && (i === player.selectedSlot));
                    slot.classList.toggle('selected', i === this._selectedIdx);

                    const idKey = empty ? null : it.id;
                    const countKey = empty ? 0 : it.count;

                    if (!force && this._lastId[i] === idKey && this._lastCount[i] === countKey) continue;
                    this._lastId[i] = idKey;
                    this._lastCount[i] = countKey;

                    const canvas = this._slotCanvases[i];
                    const cx = this._slotCtx[i];
                    const emoji = this._slotEmojiEls[i];
                    const countEl = this._slotCountEls[i];

                    // reset
                    canvas.style.display = 'none';
                    emoji.style.display = 'none';
                    countEl.style.display = 'none';

                    if (empty) continue;

                    if (it.id === 'pickaxe') {
                        emoji.textContent = it.icon || 'â›ï¸';
                        emoji.style.display = '';
                    } else {
                        canvas.style.display = '';
                        cx.clearRect(0, 0, 34, 34);
                        const tex = (this.game.ui && this.game.ui.textures) ? this.game.ui.textures.get(it.id) : (this.game.renderer && this.game.renderer.textures ? this.game.renderer.textures.get(it.id) : null);
                        if (tex) cx.drawImage(tex, 0, 0, 34, 34);
                    }

                    if (it.id !== 'pickaxe' && it.count > 1) {
                        countEl.textContent = String(it.count);
                        countEl.style.display = '';
                    }
                }

                // æŒ‰é’®çŠ¶æ€
                const sel = this._getSelectedItem();
                const selMovable = !!(sel && sel.count > 0);
                if (this.btnToHotbar) this.btnToHotbar.disabled = !selMovable;
                if (this.btnDrop) this.btnDrop.disabled = !(sel && typeof sel.id === 'number' && sel.count > 0);
                if (this.btnPutBack) this.btnPutBack.disabled = !this._cursorItem;

                this._updateDetails();
            }

            _buildSlots() {
                // æ¸…ç©ºå®¹å™¨ï¼ˆåªæ„å»ºä¸€æ¬¡ï¼‰
                this.hotbarGrid.innerHTML = '';
                this.backpackGrid.innerHTML = '';

                for (let i = 0; i < this.MAX_SIZE; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inv-slot';
                    slot.dataset.idx = String(i);

                    if (i < 9 && !this.game.isMobile) {
                        const key = document.createElement('span');
                        key.className = 'key';
                        key.textContent = String(i + 1);
                        slot.appendChild(key);
                    }

                    const emoji = document.createElement('span');
                    emoji.className = 'item-icon';
                    emoji.style.display = 'none';
                    slot.appendChild(emoji);

                    const c = document.createElement('canvas');
                    c.width = c.height = 34;
                    c.style.display = 'none';
                    const cx = c.getContext('2d', { willReadFrequently: true });
                    cx.imageSmoothingEnabled = false;
                    slot.appendChild(c);

                    const count = document.createElement('span');
                    count.className = 'count';
                    count.style.display = 'none';
                    slot.appendChild(count);

                    slot.addEventListener('pointerdown', (e) => this._onSlotPointerDown(e));
                    slot.addEventListener('contextmenu', (e) => e.preventDefault());

                    if (i < 9) this.hotbarGrid.appendChild(slot);
                    else this.backpackGrid.appendChild(slot);

                    this._slotEls[i] = slot;
                    this._slotCanvases[i] = c;
                    this._slotCtx[i] = cx;
                    this._slotCountEls[i] = count;
                    this._slotEmojiEls[i] = emoji;
                }
            }

            _bind() {
                // ç‚¹å‡»é®ç½©å…³é—­
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) this.close();
                });

                // close
                if (this.closeBtn) this.closeBtn.addEventListener('click', () => this.close());

                // ç§»åŠ¨ç«¯ï¼šæ»‘åŠ¨å…³é—­ï¼ˆä¸‹æ»‘ä¼˜å…ˆï¼Œè¾…ä»¥å³æ»‘ï¼‰
                try {
                    const isMobile = document.documentElement.classList.contains('is-mobile') ||
                        (window.matchMedia && (matchMedia('(pointer: coarse)').matches || matchMedia('(any-pointer: coarse)').matches));
                    if (isMobile && this.panel) {
                        let dragging = false;
                        let pid = null;
                        let sx = 0, sy = 0;
                        let lastDx = 0, lastDy = 0;

                        const canStart = (e) => {
                            // ä¸æŠ¢å æ ¼å­æ‹–æ‹½/æŒ‰é’®ç‚¹å‡»
                            if (e.target && e.target.closest) {
                                if (e.target.closest('.inv-slot, .inv-btn, button, a, input, select, textarea')) return false;
                            }
                            // å…è®¸ä»é¡¶éƒ¨åŒºåŸŸ/è¯¦æƒ…åŒºåŸŸæ»‘åŠ¨
                            return true;
                        };

                        const onDown = (e) => {
                            if (!this.isOpen) return;
                            try { e.preventDefault(); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                            if (e.pointerType !== 'touch') return;
                            if (!canStart(e)) return;
                            dragging = true;
                            pid = e.pointerId;
                            sx = e.clientX; sy = e.clientY;
                            lastDx = 0; lastDy = 0;
                            this.panel.classList.add('dragging');
                            try { this.panel.setPointerCapture(pid); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                        };

                        const onMove = (e) => {
                            if (!dragging || e.pointerId !== pid) return;
                            try { e.preventDefault(); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                            lastDx = e.clientX - sx;
                            lastDy = e.clientY - sy;

                            // ä»¥â€œä¸‹æ»‘å…³é—­â€ä¸ºä¸»ï¼›æ¨ªå‘è½»å¾®å®¹é”™
                            const dy = Math.max(0, lastDy);
                            const dx = Math.max(0, lastDx);

                            const useDy = dy > dx * 0.8;
                            const offset = useDy ? Math.min(260, dy) : Math.min(220, dx * 0.75);
                            this.panel.style.setProperty('--inv-drag-y', offset.toFixed(0) + 'px');
                        };

                        const endDrag = () => {
                            if (!dragging) return;
                            dragging = false;
                            this.panel.classList.remove('dragging');

                            const dy = Math.max(0, lastDy);
                            const dx = Math.max(0, lastDx);
                            const shouldClose = (dy > 160 && dy > dx) || (dx > 200 && dx > dy);

                            if (shouldClose) {
                                this.panel.style.setProperty('--inv-drag-y', '0px');
                                this.close();
                            } else {
                                // å›å¼¹
                                this.panel.style.setProperty('--inv-drag-y', '0px');
                            }

                            try { if (pid != null) this.panel.releasePointerCapture(pid); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                            pid = null;
                        };

                        this.panel.addEventListener('pointerdown', onDown, { passive: false });
                        this.panel.addEventListener('pointermove', onMove, { passive: false });
                        this.panel.addEventListener('pointerup', endDrag, { passive: true });
                        this.panel.addEventListener('pointercancel', endDrag, { passive: true });
                    }
                } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                // æŒ‰é’®
                if (this.btnTop) this.btnTop.addEventListener('click', () => this.toggle());
                if (this.btnFloat) this.btnFloat.addEventListener('click', () => this.toggle());

                if (this.btnSort) this.btnSort.addEventListener('click', () => { this._sortBackpack(); this._changed(); });
                if (this.btnToHotbar) this.btnToHotbar.addEventListener('click', () => { this._moveSelectedToHotbar(); this._changed(); });
                if (this.btnPutBack) this.btnPutBack.addEventListener('click', () => { this._returnCursorItem(); this._changed(); });
                if (this.btnDrop) this.btnDrop.addEventListener('click', () => { this._dropSelected(); this._changed(); });

                // è·Ÿéšé¼ æ ‡/è§¦æ‘¸æ˜¾ç¤ºæ‹¿èµ·çš„ç‰©å“
                this.overlay.addEventListener('pointermove', (e) => {
                    if (!this._cursorItem) return;
                    this._showHeldAt(e.clientX, e.clientY);
                }, { passive: true });

                this.overlay.addEventListener('pointerleave', () => {
                    // ç•™åœ¨å±å¹•è¾¹ç¼˜æ—¶ä¿æŒæ˜¾ç¤ºï¼ˆä¸éšè—ï¼‰
                });
            }

            _onSlotPointerDown(e) {
                e.preventDefault();

                const idx = parseInt(e.currentTarget.dataset.idx, 10);
                this._selectedIdx = idx;
                if (idx < 9 && this.game && this.game.player) this.game.player.selectedSlot = idx;

                // Shift+ç‚¹å‡»ï¼šå¿«é€Ÿç§»åŠ¨ï¼ˆæ¡Œé¢ï¼‰
                if (e.shiftKey && !this._cursorItem) {
                    this._quickMove(idx);
                    this._changed();
                    return;
                }

                // å³é”®ï¼šæ‹†åˆ†/æ”¾1ä¸ª
                const isRight = (e.button === 2);
                if (isRight) {
                    this._rightClick(idx);
                    this._changed();
                    return;
                }

                // å·¦é”®ï¼šæ‹¿èµ·/æ”¾ä¸‹/äº¤æ¢
                this._leftClick(idx);
                this._changed();
            }

            _cloneItem(it) {
                if (!it) return null;
                const out = {};
                for (const k in it) out[k] = it[k];
                return out;
            }

            _isEmptySlot(i) {
                const it = this.game.player.inventory[i];
                return !it || (it.count === 0 && it.id !== 'pickaxe');
            }

            _clearSlot(i) {
                const it = this.game.player.inventory[i];
                if (!it) {
                    this.game.player.inventory[i] = { id: this.EMPTY_ID, name: '', count: 0 };
                    return;
                }
                it.id = this.EMPTY_ID;
                it.name = '';
                it.count = 0;
                // æ¸…ç†é•å­å±æ€§ç­‰
                delete it.power; delete it.speed; delete it.icon;
            }

            _setSlot(i, item) {
                const inv = this.game.player.inventory;
                if (!inv[i]) inv[i] = { id: this.EMPTY_ID, name: '', count: 0 };

                if (!item || item.count <= 0) {
                    this._clearSlot(i);
                    return;
                }

                // ç›´æ¥è¦†ç›–å­—æ®µï¼ˆä¿æŒå¼•ç”¨ä¸å˜ï¼Œé¿å…å…¶å®ƒåœ°æ–¹æŒæœ‰ inv[i] æ—¶å¤±æ•ˆï¼‰
                const s = inv[i];
                for (const k in s) delete s[k];
                for (const k in item) s[k] = item[k];
                if (!('name' in s)) s.name = '';
            }

            _getSelectedItem() {
                const it = this.game.player.inventory[this._selectedIdx];
                if (!it) return null;
                if (it.count === 0 && it.id !== 'pickaxe') return null;
                return it;
            }

            _leftClick(idx) {
                const inv = this.game.player.inventory;
                const it = inv[idx];

                const empty = (!it || (it.count === 0 && it.id !== 'pickaxe'));
                if (!this._cursorItem) {
                    if (empty) { this._hideHeld(); return; }
                    this._cursorItem = this._cloneItem(it);
                    this._cursorFrom = idx;
                    this._clearSlot(idx);
                    this._renderHeld();
                    return;
                }

                // å·²æ‹¿èµ·ï¼šæ”¾ä¸‹/äº¤æ¢
                if (empty) {
                    this._setSlot(idx, this._cursorItem);
                    this._cursorItem = null;
                    this._cursorFrom = -1;
                    this._hideHeld();
                } else {
                    const tmp = this._cloneItem(it);
                    this._setSlot(idx, this._cursorItem);
                    this._cursorItem = tmp;
                    this._cursorFrom = idx;
                    this._renderHeld();
                }
            }

            _rightClick(idx) {
                const inv = this.game.player.inventory;
                const it = inv[idx];
                const empty = (!it || (it.count === 0 && it.id !== 'pickaxe'));

                // æ²¡æ‹¿ä¸œè¥¿ï¼šæ‹†åŠ
                if (!this._cursorItem) {
                    if (empty) return;
                    if (it.id === 'pickaxe') return;
                    if (it.count <= 1) return;

                    const take = Math.ceil(it.count / 2);
                    const remain = it.count - take;

                    this._cursorItem = this._cloneItem(it);
                    this._cursorItem.count = take;
                    this._cursorFrom = -1;

                    it.count = remain;
                    if (it.count <= 0) this._clearSlot(idx);

                    this._renderHeld();
                    return;
                }

                // æ‹¿ç€ä¸œè¥¿ï¼šå¾€ç›®æ ‡æ”¾ 1 ä¸ªï¼ˆåŒç±»å åŠ /ç©ºä½æ–°å»ºï¼‰
                if (this._cursorItem.id === 'pickaxe') return;
                if (this._cursorItem.count <= 0) { this._cursorItem = null; this._hideHeld(); return; }

                if (empty) {
                    const one = this._cloneItem(this._cursorItem);
                    one.count = 1;
                    this._setSlot(idx, one);
                    this._cursorItem.count -= 1;
                } else {
                    if (it.id !== this._cursorItem.id) return;
                    if (it.count >= this.MAX_STACK) return;
                    it.count += 1;
                    this._cursorItem.count -= 1;
                }

                if (this._cursorItem.count <= 0) {
                    this._cursorItem = null;
                    this._cursorFrom = -1;
                    this._hideHeld();
                } else {
                    this._renderHeld();
                }
            }

            _quickMove(idx) {
                const inv = this.game.player.inventory;
                const it = inv[idx];
                if (!it || (it.count === 0 && it.id !== 'pickaxe')) return;
                if (it.id === 'pickaxe') return; // ç®€åŒ–ï¼šé•å­ä¸å‚ä¸å¿«é€Ÿç§»åŠ¨

                const fromHotbar = idx < 9;
                const range = fromHotbar ? [9, this.MAX_SIZE - 1] : [0, 8];

                let remaining = it.count;

                // 1) å…ˆå åŠ åˆ°åŒç±»å †
                for (let i = range[0]; i <= range[1] && remaining > 0; i++) {
                    const t = inv[i];
                    if (!t || t.count === 0) continue;
                    if (t.id !== it.id) continue;
                    const canAdd = Math.min(remaining, this.MAX_STACK - t.count);
                    if (canAdd <= 0) continue;
                    t.count += canAdd;
                    remaining -= canAdd;
                }

                // 2) å†æ”¾åˆ°ç©ºæ ¼
                for (let i = range[0]; i <= range[1] && remaining > 0; i++) {
                    const t = inv[i];
                    if (!t || (t.count === 0 && t.id !== 'pickaxe')) {
                        const piece = this._cloneItem(it);
                        piece.count = Math.min(remaining, this.MAX_STACK);
                        this._setSlot(i, piece);
                        remaining -= piece.count;
                    }
                }

                // åŸæ ¼å­æ‰£é™¤
                if (remaining <= 0) {
                    this._clearSlot(idx);
                } else {
                    it.count = remaining;
                }
            }

            _sortBackpack() {
                const inv = this.game.player.inventory;
                const start = 9;

                // collect
                const items = [];
                for (let i = start; i < this.MAX_SIZE; i++) {
                    const it = inv[i];
                    if (!it || (it.count === 0 && it.id !== 'pickaxe')) continue;
                    if (it.id === 'pickaxe') continue;
                    items.push(this._cloneItem(it));
                }

                // merge by id
                const map = new Map();
                for (const it of items) {
                    const key = it.id;
                    const prev = map.get(key) || 0;
                    map.set(key, prev + (it.count || 0));
                }

                const merged = [];
                for (const [id, total] of map.entries()) {
                    let left = total;
                    while (left > 0) {
                        const take = Math.min(left, this.MAX_STACK);
                        const bd = (typeof id === 'number') ? BLOCK_DATA[id] : null;
                        merged.push({ id, name: bd ? bd.name : ('' + id), count: take });
                        left -= take;
                    }
                }

                // sort (by name)
                merged.sort((a, b) => (String(a.name)).localeCompare(String(b.name), 'zh-Hans-CN-u-co-pinyin'));

                // clear backpack slots
                for (let i = start; i < this.MAX_SIZE; i++) this._clearSlot(i);

                // refill
                let ptr = start;
                for (const it of merged) {
                    if (ptr >= this.MAX_SIZE) break;
                    this._setSlot(ptr, it);
                    ptr++;
                }
            }

            _moveSelectedToHotbar() {
                const inv = this.game.player.inventory;
                const idx = this._selectedIdx;
                const it = this._getSelectedItem();
                if (!it) return;

                if (idx < 9) return;

                // æ‰¾ç©ºä½ï¼Œå¦åˆ™ç”¨å½“å‰é€‰ä¸­æ ä½
                let target = -1;
                for (let i = 0; i < 9; i++) {
                    if (this._isEmptySlot(i)) { target = i; break; }
                }
                if (target < 0) target = this.game.player.selectedSlot || 0;

                const tmp = this._cloneItem(inv[target]);
                this._setSlot(target, this._cloneItem(it));
                if (tmp && !(tmp.count === 0 && tmp.id !== 'pickaxe')) {
                    this._setSlot(idx, tmp);
                } else {
                    this._clearSlot(idx);
                }

                this._selectedIdx = target;
            }

            _dropSelected() {
                const game = this.game;

                // ä¼˜å…ˆä¸¢å¼ƒâ€œæ‰‹ä¸Šæ‹¿èµ·çš„ç‰©å“â€
                if (this._cursorItem) {
                    if (typeof this._cursorItem.id !== 'number') return;
                    const px = game.player.cx ? game.player.cx() : (game.player.x + game.player.w / 2);
                    const py = game.player.cy ? game.player.cy() : (game.player.y + game.player.h / 2);
                    game.droppedItems && game.droppedItems.spawn(px, py, this._cursorItem.id, this._cursorItem.count);
                    this._cursorItem = null;
                    this._cursorFrom = -1;
                    this._hideHeld();
                    return;
                }

                const idx = this._selectedIdx;
                const it = this._getSelectedItem();
                if (!it) return;
                if (typeof it.id !== 'number') return;

                const px = game.player.cx ? game.player.cx() : (game.player.x + game.player.w / 2);
                const py = game.player.cy ? game.player.cy() : (game.player.y + game.player.h / 2);

                game.droppedItems && game.droppedItems.spawn(px, py, it.id, it.count);
                this._clearSlot(idx);
            }

            _returnCursorItem() {
                if (!this._cursorItem) return;
                const inv = this.game.player.inventory;

                // 1) å°è¯•å å›åŒç±»ï¼ˆå…¨èƒŒåŒ…èŒƒå›´ï¼‰
                if (this._cursorItem.id !== 'pickaxe') {
                    let remaining = this._cursorItem.count;
                    for (let i = 0; i < this.MAX_SIZE && remaining > 0; i++) {
                        const t = inv[i];
                        if (!t || t.count === 0) continue;
                        if (t.id !== this._cursorItem.id) continue;
                        const canAdd = Math.min(remaining, this.MAX_STACK - t.count);
                        if (canAdd <= 0) continue;
                        t.count += canAdd;
                        remaining -= canAdd;
                    }
                    this._cursorItem.count = remaining;
                    if (this._cursorItem.count <= 0) {
                        this._cursorItem = null;
                        this._cursorFrom = -1;
                        this._hideHeld();
                        return;
                    }
                }

                // 2) ä¼˜å…ˆæ”¾å›æ¥æºæ ¼ï¼ˆå¦‚æœç©ºï¼‰
                if (this._cursorFrom >= 0 && this._isEmptySlot(this._cursorFrom)) {
                    this._setSlot(this._cursorFrom, this._cursorItem);
                    this._cursorItem = null;
                    this._cursorFrom = -1;
                    this._hideHeld();
                    return;
                }

                // 3) æ‰¾ä»»æ„ç©ºä½
                for (let i = 0; i < this.MAX_SIZE; i++) {
                    if (this._isEmptySlot(i)) {
                        this._setSlot(i, this._cursorItem);
                        this._cursorItem = null;
                        this._cursorFrom = -1;
                        this._hideHeld();
                        return;
                    }
                }

                // 4) æ²¡ç©ºä½ï¼šæ”¾ä¸å›ï¼Œä¿æŒæ‹¿èµ·çŠ¶æ€ï¼ˆä¸ä¸¢å¤±ï¼‰
                this._renderHeld();
            }

            _changed() {
                // åŒæ­¥å¿«æ·æ  & è§¦å‘èƒŒåŒ…åˆ·æ–°ï¼ˆbuildHotbar å†…ä¼šæ´¾å‘ inventoryChanged äº‹ä»¶ï¼‰
                if (this.game.ui) this.game.ui.buildHotbar();
                else this.refresh(false);
            }

            _updateDetails() {
                const it = this._getSelectedItem();

                // é¢„è§ˆ
                this._previewCtx.clearRect(0, 0, 56, 56);
                this._previewCanvas.style.display = 'none';
                this._previewEmoji.style.display = 'none';

                if (!it) {
                    this.nameEl.textContent = 'æœªé€‰æ‹©';
                    this.metaEl.textContent = '';
                    this.descEl.textContent = this._cursorItem ? 'å·²æ‹¿èµ·ç‰©å“ï¼šå¯ç‚¹å‡»æ ¼å­æ”¾ä¸‹ï¼Œæˆ–ç‚¹â€œæ”¾å›â€ã€‚' : 'ç‚¹å‡»æ ¼å­æŸ¥çœ‹ï¼Œæˆ–æ‹–æ‹½/ç‚¹å‡»äº¤æ¢ã€‚';
                    return;
                }

                this.nameEl.textContent = it.name || (it.id === 'pickaxe' ? 'é•å­' : 'ç‰©å“');
                const meta = [];
                if (it.id === 'pickaxe') meta.push('å·¥å…·');
                else meta.push('æ–¹å—');
                if (it.count != null && it.id !== 'pickaxe') meta.push(`æ•°é‡ x${it.count}`);
                this.metaEl.textContent = meta.join(' Â· ');

                // æè¿°ï¼šä½¿ç”¨ BLOCK_DATA
                if (typeof it.id === 'number' && window.BLOCK_DATA && BLOCK_DATA[it.id] && BLOCK_DATA[it.id].desc) {
                    this.descEl.textContent = BLOCK_DATA[it.id].desc;
                } else if (it.id === 'pickaxe') {
                    this.descEl.textContent = 'ç”¨äºæŒ–æ˜æ–¹å—ã€‚æ‰“å¼€èƒŒåŒ…æ—¶å¯æ•´ç†ä¸ç§»åŠ¨ç‰©å“ã€‚';
                } else {
                    this.descEl.textContent = 'â€”';
                }

                if (it.id === 'pickaxe') {
                    this._previewEmoji.textContent = it.icon || 'â›ï¸';
                    this._previewEmoji.style.display = '';
                } else {
                    const tex = (this.game.ui && this.game.ui.textures) ? this.game.ui.textures.get(it.id) : (this.game.renderer && this.game.renderer.textures ? this.game.renderer.textures.get(it.id) : null);
                    if (tex) {
                        this._previewCanvas.style.display = '';
                        this._previewCtx.drawImage(tex, 0, 0, 56, 56);
                    }
                }

                // æŒ‰é’®çŠ¶æ€
                if (this.btnToHotbar) this.btnToHotbar.disabled = !(it && it.count > 0 && this._selectedIdx >= 9);
                if (this.btnDrop) this.btnDrop.disabled = !(it && typeof it.id === 'number' && it.count > 0);
            }

            _renderHeld() {
                if (!this._cursorItem) { this._hideHeld(); return; }

                this._heldCtx.clearRect(0, 0, 34, 34);
                this._heldCanvas.style.display = 'none';
                this._heldEmoji.style.display = 'none';

                if (this._cursorItem.id === 'pickaxe') {
                    this._heldEmoji.textContent = this._cursorItem.icon || 'â›ï¸';
                    this._heldEmoji.style.display = '';
                    this._heldCount.textContent = '';
                } else {
                    const tex = (this.game.ui && this.game.ui.textures) ? this.game.ui.textures.get(this._cursorItem.id) : (this.game.renderer && this.game.renderer.textures ? this.game.renderer.textures.get(this._cursorItem.id) : null);
                    if (tex) {
                        this._heldCanvas.style.display = '';
                        this._heldCtx.drawImage(tex, 0, 0, 34, 34);
                    }
                    this._heldCount.textContent = (this._cursorItem.count > 1) ? String(this._cursorItem.count) : '';
                }

                this.heldEl.style.display = 'flex';
            }

            _showHeldAt(x, y) {
                this.heldEl.style.left = x + 'px';
                this.heldEl.style.top = y + 'px';
            }

            _hideHeld() {
                this.heldEl.style.display = 'none';
            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { InventoryUI });

        class InputManager {
            /** @param {Game} game */
            constructor(game) {
                this.game = game;
                // Hold-to-sprint (keyboard): avoid key-repeat jitter, compute in fixed-step tick
                this._holdLeftMs = 0;
                this._holdRightMs = 0;
                this._holdSprint = false;
                this._holdDir = 0;
                this._holdJustStarted = false;
            }

            bind() {
                const game = this.game;
                const self = this;

                // è¯´æ˜ï¼šä¿æŒåŸæœ‰è¡Œä¸ºä¸å˜ï¼Œä»…å°†ç¡¬ç¼–ç çš„æŒ‰é”®/æŒ‰é’®é›†ä¸­åŒ–ä»¥ä¾¿ç»´æŠ¤

                const onKeyDown = (e) => {

                    const code = e.code;

                    const modalOpen = (game.inventoryUI && game.inventoryUI.isOpen) || (game.crafting && game.crafting.isOpen) || game.paused || game._inputBlocked;
                    if (modalOpen) {
                        const isMoveKey = INPUT_KEYS.LEFT.has(code) || INPUT_KEYS.RIGHT.has(code) || INPUT_KEYS.JUMP.has(code) || INPUT_KEYS.SPRINT.has(code);
                        if (isMoveKey) { e.preventDefault(); return; }
                    }
                    if (INPUT_KEYS.LEFT.has(code)) game.input.left = true;

                    if (INPUT_KEYS.RIGHT.has(code)) game.input.right = true;

                    if (INPUT_KEYS.JUMP.has(code)) game.input.jump = true;

                    if (INPUT_KEYS.SPRINT.has(code)) game.input.sprint = true;

                    const handled = INPUT_KEYS.LEFT.has(code) || INPUT_KEYS.RIGHT.has(code) || INPUT_KEYS.JUMP.has(code) || INPUT_KEYS.SPRINT.has(code);
                    if (handled) e.preventDefault();
                    // 1-9 åˆ‡æ¢å¿«æ·æ ï¼ˆä¿ç•™åŸé€»è¾‘ï¼šä¾èµ– game.ui æ˜¯å¦å·²åˆå§‹åŒ–ï¼‰

                    if (e.key >= '1' && e.key <= '9' && game.ui) {

                        game.ui.selectSlot(parseInt(e.key, 10) - 1);

                    }

                    // ç³»ç»Ÿé”®ï¼ˆç»Ÿä¸€åœ¨è¿™é‡Œå¤„ç†ï¼šåˆæˆ/èƒŒåŒ…/æš‚åœ/å¸®åŠ©ï¼‰ï¼Œé¿å…å¤šä¸ª keydown ç›‘å¬ç›¸äº’â€œæŠ¢é”®â€
                    const t = e.target;
                    const tag = (t && t.tagName) ? String(t.tagName).toLowerCase() : '';
                    const typing = (tag === 'input' || tag === 'textarea' || tag === 'select' || (t && t.isContentEditable));
                    if (!typing) {
                        // é˜²æ­¢æŒ‰ä½ä¸æ”¾å¯¼è‡´åå¤è§¦å‘å¼€å…³
                        const isToggleKey = (code === 'Escape' || code === 'KeyE' || code === 'KeyB' || code === 'KeyI' || code === 'KeyH' || code === 'KeyM' || code === 'KeyF' || code === 'KeyO' || code === 'KeyP');
                        if (e.repeat && isToggleKey) return;

                        const ux = game._ux;
                        const isGameBlocked = !!(game._inputBlocked || (ux && ux.isPauseOpen && ux.isPauseOpen()) || game.paused);

                        // Hï¼šå¸®åŠ©ï¼ˆä¸å¼ºåˆ¶æš‚åœï¼‰
                        if (code === 'KeyH' && ux && ux.toggleHelp) {
                            e.preventDefault(); e.stopPropagation();
                            ux.toggleHelp();
                            return;
                        }

                        // Mï¼šå°åœ°å›¾å±•å¼€/æ”¶èµ·ï¼ˆtransform åŠ¨ç”»æ›´çœç”µï¼‰
                        if (code === 'KeyM' && window.TU && typeof window.TU.toggleMinimap === 'function') {
                            e.preventDefault(); e.stopPropagation();
                            window.TU.toggleMinimap();
                            return;
                        }

                        // Fï¼šå…¨å±ï¼ˆå¯é…åˆæµè§ˆå™¨æ‰‹åŠ¿/ç³»ç»Ÿå¿«æ·é”®ï¼‰
                        if (code === 'KeyF') {
                            e.preventDefault(); e.stopPropagation();
                            const fm = window.TU && window.TU.FullscreenManager;
                            if (fm && typeof fm.toggle === 'function') fm.toggle();
                            else {
                                const btn = document.getElementById('fullscreen-btn');
                                if (btn) btn.click();
                            }
                            return;
                        }

                        // Ctrl/Cmd + Sï¼šä¿å­˜ï¼ˆé˜²æ­¢è¯¯è§¦æµè§ˆå™¨â€œä¿å­˜ç½‘é¡µâ€ï¼‰
                        if (code === 'KeyS' && (e.ctrlKey || e.metaKey) && game.saveSystem) {
                            e.preventDefault(); e.stopPropagation();
                            game.audio && game.audio.play('ui');
                            game.saveSystem.save('manual');
                            return;
                        }

                        // Oï¼šè®¾ç½®ï¼ˆä¸ UI æŒ‰é’®ä¸€è‡´é€»è¾‘ï¼‰
                        if (code === 'KeyO' && ux && ux.showOverlay && ux.settingsOverlay) {
                            e.preventDefault(); e.stopPropagation();
                            game.audio && game.audio.play('ui');
                            game._settingsReturnToPause = !!game.paused;
                            if (typeof syncSettingsControls === 'function') syncSettingsControls(game.settings);
                            game.paused = true;
                            ux.hideOverlay && ux.hideOverlay(ux.pauseOverlay);
                            ux.showOverlay(ux.settingsOverlay);
                            return;
                        }

                        // Pï¼šæš‚åœ/ç»§ç»­
                        if (code === 'KeyP' && ux && ux.setPaused) {
                            e.preventDefault(); e.stopPropagation();
                            game.audio && game.audio.play('ui');
                            ux.setPaused(!game.paused);
                            return;
                        }

                        // Eï¼šåˆæˆï¼ˆæš‚åœ/é¢æ¿æ‰“å¼€æ—¶ä¸è§¦å‘ï¼‰
                        if (code === 'KeyE' && game.crafting && !isGameBlocked && !(ux && ux.isSettingsOpen && ux.isSettingsOpen())) {
                            e.preventDefault(); e.stopPropagation();
                            if (game.inventoryUI && game.inventoryUI.isOpen) game.inventoryUI.close();
                            game.crafting.toggle();
                            return;
                        }

                        // B / Iï¼šèƒŒåŒ…ï¼ˆæš‚åœ/é¢æ¿æ‰“å¼€æ—¶ä¸è§¦å‘ï¼‰
                        if ((code === 'KeyB' || code === 'KeyI') && game.inventoryUI && !isGameBlocked && !(ux && ux.isSettingsOpen && ux.isSettingsOpen())) {
                            e.preventDefault(); e.stopPropagation();
                            if (game.crafting && game.crafting.isOpen) game.crafting.close();
                            game.inventoryUI.toggle();
                            return;
                        }

                        // Escï¼šä¼˜å…ˆå…³é—­â€œæœ€ä¸Šå±‚â€é¢æ¿ï¼ˆhelp/settings/èƒŒåŒ…/åˆæˆï¼‰ï¼Œå¦åˆ™åˆ‡æ¢æš‚åœ
                        if (code === 'Escape') {
                            e.preventDefault(); e.stopPropagation();

                            if (ux && ux.isHelpOpen && ux.isHelpOpen()) {
                                ux.hideOverlay && ux.hideOverlay(ux.helpOverlay);
                                try { localStorage.setItem('terraria_ultra_help_seen_v1', '1'); } catch { }
                                return;
                            }
                            if (ux && ux.isSettingsOpen && ux.isSettingsOpen()) {
                                if (ux.closeSettings) ux.closeSettings();
                                else ux.hideOverlay && ux.hideOverlay(ux.settingsOverlay);
                                return;
                            }
                            if (game.inventoryUI && game.inventoryUI.isOpen) { game.inventoryUI.close(); return; }
                            if (game.crafting && game.crafting.isOpen) { game.crafting.close(); return; }

                            if (ux && ux.setPaused) {
                                game.audio && game.audio.play('ui');
                                ux.setPaused(!game.paused);
                                return;
                            }
                            game.paused = !game.paused;
                            return;
                        }
                    }

                };

                const onKeyUp = (e) => {

                    const code = e.code;

                    const modalOpen = (game.inventoryUI && game.inventoryUI.isOpen) || (game.crafting && game.crafting.isOpen) || game.paused || game._inputBlocked;
                    if (modalOpen) {
                        const isMoveKey = INPUT_KEYS.LEFT.has(code) || INPUT_KEYS.RIGHT.has(code) || INPUT_KEYS.JUMP.has(code) || INPUT_KEYS.SPRINT.has(code);
                        if (isMoveKey) { e.preventDefault(); }
                    }
                    if (INPUT_KEYS.LEFT.has(code)) game.input.left = false;
                    if (INPUT_KEYS.LEFT.has(code)) self._holdLeftMs = 0;

                    if (INPUT_KEYS.RIGHT.has(code)) game.input.right = false;
                    if (INPUT_KEYS.RIGHT.has(code)) self._holdRightMs = 0;

                    if (INPUT_KEYS.JUMP.has(code)) game.input.jump = false;

                    if (INPUT_KEYS.SPRINT.has(code)) game.input.sprint = false;

                    const handled = INPUT_KEYS.LEFT.has(code) || INPUT_KEYS.RIGHT.has(code) || INPUT_KEYS.JUMP.has(code) || INPUT_KEYS.SPRINT.has(code);
                    if (handled) e.preventDefault();
                };

                window.addEventListener('keydown', onKeyDown);

                window.addEventListener('keyup', onKeyUp);

                game.canvas.addEventListener('mousemove', (e) => {

                    game.input.mouseX = e.clientX;

                    game.input.mouseY = e.clientY;

                }, { passive: true });

                game.canvas.addEventListener('mousedown', (e) => {

                    if (e.button === MOUSE_BUTTON.LEFT) game.input.mouseLeft = true;

                    if (e.button === MOUSE_BUTTON.RIGHT) game.input.mouseRight = true;

                });

                game.canvas.addEventListener('mouseup', (e) => {

                    if (e.button === MOUSE_BUTTON.LEFT) game.input.mouseLeft = false;

                    if (e.button === MOUSE_BUTTON.RIGHT) game.input.mouseRight = false;

                });

                game.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                const fullscreenBtn = DOM.byId(UI_IDS.fullscreenBtn);

                if (fullscreenBtn) {

                    fullscreenBtn.addEventListener('click', (e) => {
                        e.preventDefault(); e.stopPropagation();
                        const fm = window.TU && window.TU.FullscreenManager;
                        if (fm && typeof fm.toggle === 'function') {
                            fm.toggle();
                        } else {
                            if (document.fullscreenElement) document.exitFullscreen();
                            else document.documentElement.requestFullscreen();
                        }
                    });

                }

            }

            /**
             * Fixed-step tick to compute "hold A/D to sprint" without being affected by key repeat.
             * @param {number} dtMs
             */
            tick(dtMs) {
                const left = !!this.game.input.left;
                const right = !!this.game.input.right;

                // Only count hold when a single direction is pressed; switching direction resets.
                if (left && !right) this._holdLeftMs = Math.min(10000, (this._holdLeftMs || 0) + dtMs);
                else this._holdLeftMs = 0;

                if (right && !left) this._holdRightMs = Math.min(10000, (this._holdRightMs || 0) + dtMs);
                else this._holdRightMs = 0;

                const prev = !!this._holdSprint;
                let sprint = false;
                let dir = 0;
                if (this._holdLeftMs >= CONFIG.SPRINT_HOLD_MS) { sprint = true; dir = -1; }
                else if (this._holdRightMs >= CONFIG.SPRINT_HOLD_MS) { sprint = true; dir = 1; }

                this._holdSprint = sprint;
                this._holdDir = dir;
                this._holdJustStarted = (!prev && sprint);
            }

        }

        /**
         * InventorySystem
         * - è´Ÿè´£æ‹¾å–å…¥åŒ…ï¼ˆå †å /ç©ºæ§½/æ‰©å®¹/æ»¡åŒ…æ—¥å¿—ï¼‰
         * - âš ï¸ è¡Œä¸ºä¿æŒä¸æ—§ç‰ˆ Game._addToInventory å®Œå…¨ä¸€è‡´ï¼ˆä»£ç æ¬è¿ + thisâ†’game é‡å®šå‘ï¼‰
         */

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { InputManager });

        class InventorySystem {
            /** @param {Game} game */
            constructor(game) {
                this.game = game;
            }

            /**
             * @param {string} blockId
             * @param {number} [count=1]
             * @returns {boolean}
             */
            add(blockId, count = 1) {
                const game = this.game;

                const blockData = BLOCK_DATA[blockId];
                if (!blockData) return false;

                const MAX_INVENTORY_SIZE = INVENTORY_LIMITS.MAX_SIZE; // æœ€å¤§èƒŒåŒ…å®¹é‡ï¼ˆä¿æŒåŸå€¼ 36ï¼‰
                const MAX_STACK_SIZE = INVENTORY_LIMITS.MAX_STACK;    // å•ä¸ªç‰©å“å †å ä¸Šé™ï¼ˆä¿æŒåŸå€¼ 999ï¼‰

                let remaining = count;

                const refreshHotbar = () => {
                    // ä¿æŒåŸæœ‰è¡Œä¸ºï¼šæ¯æ¬¡å‘ç”Ÿå¯è§å˜æ›´æ—¶å³æ—¶åˆ·æ–°ï¼ˆä½†è¦å®¹é”™ï¼Œé¿å… UI å°šæœªåˆå§‹åŒ–æ—¶æŠ¥é”™ï¼‰
                    try {
                        if (game && game.ui && typeof game.ui.buildHotbar === 'function') game.ui.buildHotbar();
                    } catch { }
                };

                // 1) ä¼˜å…ˆå †å åˆ°å·²æœ‰åŒç±»ç‰©å“
                for (let item of game.player.inventory) {
                    if (item.id === blockId && item.count < MAX_STACK_SIZE) {
                        const canAdd = Math.min(remaining, MAX_STACK_SIZE - item.count);
                        item.count += canAdd;
                        remaining -= canAdd;

                        if (remaining <= 0) {
                            refreshHotbar();
                            return true;
                        }
                    }
                }

                // 2) å¡«å……ç©ºæ§½ä½ï¼ˆcount ä¸º 0 çš„æ ¼å­ï¼‰ï¼Œä¿ç•™åŸé€»è¾‘ï¼šä¸è¦†ç›–é•å­æ§½
                for (let item of game.player.inventory) {
                    if (item.count === 0 && item.id !== 'pickaxe') {
                        const canAdd = Math.min(remaining, MAX_STACK_SIZE);
                        item.id = blockId;
                        item.name = blockData.name;
                        item.count = canAdd;
                        remaining -= canAdd;

                        if (remaining <= 0) {
                            refreshHotbar();
                            return true;
                        }
                    }
                }

                // 3) å¦‚æœæ²¡æœ‰ç©ºæ§½ä½ï¼Œå°è¯•èƒŒåŒ…æ‰©å±•ï¼ˆpush æ–°æ§½ä½ï¼‰
                while (remaining > 0 && game.player.inventory.length < MAX_INVENTORY_SIZE) {
                    const canAdd = Math.min(remaining, MAX_STACK_SIZE);
                    game.player.inventory.push({
                        id: blockId,
                        name: blockData.name,
                        count: canAdd
                    });
                    remaining -= canAdd;
                }

                // 4) æ›´æ–° UIï¼ˆä¿æŒåŸé€»è¾‘ï¼šå³ä½¿æœªå®Œå…¨æ‹¾å–ä¹Ÿåˆ·æ–°å·²å˜åŒ–éƒ¨åˆ†ï¼‰
                refreshHotbar();

                if (remaining <= 0) return true;

                // 5) èƒŒåŒ…æ»¡ï¼šè¿”å› falseï¼Œè®©ç‰©å“ç•™åœ¨åœ°ä¸Šï¼ˆä¿æŒåŸè¾“å‡ºï¼‰
                try { Toast.show(`ğŸ’ èƒŒåŒ…å·²æ»¡ï¼š${blockData.name} æœªèƒ½å…¨éƒ¨æ‹¾å–`, 1600); } catch { }
                return false;

            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.TU = window.TU || {};
        Object.assign(window.TU, { InventorySystem });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 15: TileLogicEngine (with v12+v9 fluids Worker code)
//   Worker source defined as a clean constant string.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                                                function buildTileLogicWorkerSourceV9() {
                                                    // Keep message protocol identical to v12, but improve fluid + add plate/pump awareness in logic scan.
                                                    // NOTE: This string is intentionally "plain JS" (no template interpolations).
                                                    return `/* TileLogic Worker v12+ (v9 fluids) */
      (() => {
        let W = 0, H = 0;
        let tiles = null;
        let water = null;
        let solid = null;

        let AIR = 0, WATER = 27;
        let IDS = null;

        const region = { x0: 0, y0: 0, x1: -1, y1: -1, set: false };
        let lastRegionKey = '';
        let perfLevel = 'high';
        const MAX = 8;

        const waterQ = [];
        let waterMark = null;
        const logicQ = [];
        let logicMark = null;

        function idx(x, y) { return x * H + y; }

        function inRegionIndex(i) {
          if (!region.set) return false;
          const x = (i / H) | 0;
          const y = i - x * H;
          return (x >= region.x0 && x <= region.x1 && y >= region.y0 && y <= region.y1);
        }

        function isWire(id)   { return id === IDS.WIRE_OFF || id === IDS.WIRE_ON; }
        function isSwitch(id) { return id === IDS.SWITCH_OFF || id === IDS.SWITCH_ON || id === IDS.PLATE_OFF || id === IDS.PLATE_ON; }
        function isSource(id) { return id === IDS.SWITCH_ON || id === IDS.PLATE_ON; }
        function isLamp(id)   { return id === IDS.LAMP_OFF || id === IDS.LAMP_ON; }
        function isPump(id)   { return id === IDS.PUMP_IN || id === IDS.PUMP_OUT; }
        function isConductor(id) { return isWire(id) || isSwitch(id) || isPump(id); }

        function canWaterEnterTile(id) { return id === AIR || id === WATER; }

        function scheduleWater(i) {
          if (!waterMark) return;
          if (!inRegionIndex(i)) return;
          if (waterMark[i]) return;
          waterMark[i] = 1;
          waterQ.push(i);
        }

        function scheduleWaterAround(x, y) {
          if (x < 0 || y < 0 || x >= W || y >= H) return;
          scheduleWater(idx(x, y));
          if (x > 0) scheduleWater(idx(x - 1, y));
          if (x + 1 < W) scheduleWater(idx(x + 1, y));
          if (y > 0) scheduleWater(idx(x, y - 1));
          if (y + 1 < H) scheduleWater(idx(x, y + 1));
        }

        function scheduleLogic(i) {
          if (!logicMark) return;
          if (!inRegionIndex(i)) return;
          if (logicMark[i]) return;
          logicMark[i] = 1;
          logicQ.push(i);
        }

        function scheduleLogicAround(x, y) {
          if (x < 0 || y < 0 || x >= W || y >= H) return;
          scheduleLogic(idx(x, y));
          if (x > 0) scheduleLogic(idx(x - 1, y));
          if (x + 1 < W) scheduleLogic(idx(x + 1, y));
          if (y > 0) scheduleLogic(idx(x, y - 1));
          if (y + 1 < H) scheduleLogic(idx(x, y + 1));
        }

        function setTile(i, newId, changes) {
          const old = tiles[i];
          if (old === newId) return false;
          tiles[i] = newId;
          changes.push(i, old, newId);
          const x = (i / H) | 0;
          const y = i - x * H;
          scheduleWaterAround(x, y);
          scheduleLogicAround(x, y);
          return true;
        }

        function ensureWaterTile(i, changes) {
          if (water[i] > 0) {
            if (tiles[i] !== WATER) setTile(i, WATER, changes);
          } else {
            if (tiles[i] === WATER) setTile(i, AIR, changes);
          }
        }

        // Dynamic water with smoothing + limited pressure-up (U-tube-ish)
        function waterTick(i, changes) {
          waterMark[i] = 0;
          if (!inRegionIndex(i)) return;

          let a = water[i] | 0;
          if (a <= 0) return;

          const tid = tiles[i];
          if (tid !== WATER && tid !== AIR) { water[i] = 0; return; }

          const x = (i / H) | 0;
          const y = i - x * H;

          // Snapshot neighbors (avoid directional bias)
          const down = (y + 1 < H) ? (i + 1) : -1;
          const up   = (y > 0) ? (i - 1) : -1;
          const left = (x > 0) ? (i - H) : -1;
          const right= (x + 1 < W) ? (i + H) : -1;

          // 1) Down flow (strong)
          if (down !== -1 && canWaterEnterTile(tiles[down])) {
            const b = water[down] | 0;
            const space = MAX - b;
            if (space > 0) {
              const mv = (a < space) ? a : space;
              water[i] = a - mv;
              water[down] = b + mv;
              a = water[i] | 0;

              ensureWaterTile(i, changes);
              ensureWaterTile(down, changes);

              scheduleWater(down);
              scheduleWater(i);
              scheduleWaterAround(x, y);
              scheduleWaterAround(x, y + 1);
            }
          }
          if (a <= 0) return;

          // 2) Horizontal smoothing (simultaneous-ish)
          let a0 = a;
          let mvL = 0, mvR = 0;

          if (left !== -1 && canWaterEnterTile(tiles[left])) {
            const b = water[left] | 0;
            const diff = a0 - b;
            if (diff > 1) {
              mvL = (diff / 3) | 0; // gentler than half, smoother
              if (mvL < 1) mvL = 1;
              const space = MAX - b;
              if (mvL > space) mvL = space;
            }
          }
          if (right !== -1 && canWaterEnterTile(tiles[right])) {
            const b = water[right] | 0;
            const diff = a0 - b;
            if (diff > 1) {
              mvR = (diff / 3) | 0;
              if (mvR < 1) mvR = 1;
              const space = MAX - b;
              if (mvR > space) mvR = space;
            }
          }

          // Cap total move to available water
          const tot = mvL + mvR;
          if (tot > a0) {
            // scale down proportionally
            mvL = ((mvL * a0) / tot) | 0;
            mvR = a0 - mvL;
          }

          if (mvL > 0 && left !== -1) {
            water[i] = (water[i] | 0) - mvL;
            water[left] = (water[left] | 0) + mvL;
            ensureWaterTile(i, changes);
            ensureWaterTile(left, changes);
            scheduleWater(left); scheduleWater(i);
          }
          if (mvR > 0 && right !== -1) {
            water[i] = (water[i] | 0) - mvR;
            water[right] = (water[right] | 0) + mvR;
            ensureWaterTile(i, changes);
            ensureWaterTile(right, changes);
            scheduleWater(right); scheduleWater(i);
          }

          a = water[i] | 0;
          if (a <= 0) return;

          // 3) Pressure-up (limited): if fully pressurized and blocked below, allow a tiny move upward
          if (up !== -1 && canWaterEnterTile(tiles[up])) {
            const ub = water[up] | 0;
            const belowBlocked = (down === -1) || !canWaterEnterTile(tiles[down]) || (water[down] | 0) >= MAX;
            if (belowBlocked && a >= MAX && ub + 1 < a && ub < MAX) {
              water[i] = (water[i] | 0) - 1;
              water[up] = ub + 1;
              ensureWaterTile(i, changes);
              ensureWaterTile(up, changes);
              scheduleWater(up); scheduleWater(i);
            }
          }
        }

        // Logic: same as v12, but treat pressure plate as switch/source and pumps as conductors (for connectivity)
        let vis = null;
        let stamp = 1;
        function ensureVis() {
          const N = W * H;
          if (!vis || vis.length !== N) vis = new Uint32Array(N);
        }

        function lampShouldOn(iLamp) {
          const x = (iLamp / H) | 0;
          const y = iLamp - x * H;
          if (x > 0) { const t = tiles[iLamp - H]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON || t === IDS.PLATE_ON) return true; }
          if (x + 1 < W) { const t = tiles[iLamp + H]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON || t === IDS.PLATE_ON) return true; }
          if (y > 0) { const t = tiles[iLamp - 1]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON || t === IDS.PLATE_ON) return true; }
          if (y + 1 < H) { const t = tiles[iLamp + 1]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON || t === IDS.PLATE_ON) return true; }
          return false;
        }

        function updateLampAt(iLamp, changes) {
          const t = tiles[iLamp];
          if (!(t === IDS.LAMP_OFF || t === IDS.LAMP_ON)) return;
          const want = lampShouldOn(iLamp) ? IDS.LAMP_ON : IDS.LAMP_OFF;
          if (t !== want) setTile(iLamp, want, changes);
        }

        function logicRecomputeFromSeed(seed, changes) {
          logicMark[seed] = 0;

          ensureVis();
          stamp = (stamp + 1) >>> 0;
          if (stamp === 0) { stamp = 1; vis.fill(0); }

          const starts = [];
          const sid = tiles[seed];
          if (isConductor(sid) || isLamp(sid)) starts.push(seed);
          else {
            const x = (seed / H) | 0;
            const y = seed - x * H;
            if (x > 0) { const n = seed - H; if (isConductor(tiles[n]) || isLamp(tiles[n])) starts.push(n); }
            if (x + 1 < W) { const n = seed + H; if (isConductor(tiles[n]) || isLamp(tiles[n])) starts.push(n); }
            if (y > 0) { const n = seed - 1; if (isConductor(tiles[n]) || isLamp(tiles[n])) starts.push(n); }
            if (y + 1 < H) { const n = seed + 1; if (isConductor(tiles[n]) || isLamp(tiles[n])) starts.push(n); }
          }
          if (!starts.length) return;

          const q = [];
          const comp = [];
          let powered = false;

          for (let si = 0; si < starts.length; si++) {
            const s = starts[si];
            if (vis[s] === stamp) continue;
            vis[s] = stamp;
            q.push(s);

            while (q.length) {
              const i = q.pop();
              const t = tiles[i];
              if (!(isConductor(t) || isLamp(t))) continue;

              comp.push(i);
              if (isSource(t)) powered = true;

              const x = (i / H) | 0;
              const y = i - x * H;

              if (x > 0) { const n = i - H; if (vis[n] !== stamp && (isConductor(tiles[n]) || isLamp(tiles[n]))) { vis[n] = stamp; q.push(n); } }
              if (x + 1 < W) { const n = i + H; if (vis[n] !== stamp && (isConductor(tiles[n]) || isLamp(tiles[n]))) { vis[n] = stamp; q.push(n); } }
              if (y > 0) { const n = i - 1; if (vis[n] !== stamp && (isConductor(tiles[n]) || isLamp(tiles[n]))) { vis[n] = stamp; q.push(n); } }
              if (y + 1 < H) { const n = i + 1; if (vis[n] !== stamp && (isConductor(tiles[n]) || isLamp(tiles[n]))) { vis[n] = stamp; q.push(n); } }

              if (comp.length > 14000) break;
            }
            if (comp.length > 14000) break;
          }

          const wantWire = powered ? IDS.WIRE_ON : IDS.WIRE_OFF;
          for (let i = 0; i < comp.length; i++) {
            const p = comp[i];
            const t = tiles[p];
            if (isWire(t) && t !== wantWire) setTile(p, wantWire, changes);
            if (isLamp(t)) updateLampAt(p, changes);
          }
        }

        function primeRegionWork() {
          if (!region.set) return;
          for (let x = region.x0; x <= region.x1; x++) {
            const base = x * H;
            for (let y = region.y0; y <= region.y1; y++) {
              const i = base + y;
              if (water[i] > 0) scheduleWater(i);
              const t = tiles[i];
              if (t === IDS.SWITCH_ON || t === IDS.PLATE_ON || isWire(t) || isLamp(t) || isPump(t)) scheduleLogic(i);
            }
          }
        }

        // Optional: pump tick inside region (small budget), teleports 1 water unit between linked pumps along wires

                                    class TileLogicEngine {
                                        constructor(game) {
                                            this.game = game;
                                            this.world = game.world;
                                            this.w = this.world.w | 0;
                                            this.h = this.world.h | 0;

                                            this.worker = null;
                                            this.pending = []; // { arr:Int32Array, pos:number }
                                            this._applyScheduled = false;

                                            this._lastRegionSent = 0;
                                            this._lastPerfSent = '';
                                            this._minimapDirty = false;
                                            this._lastMinimapFlush = 0;
                                            this._enabled = true;

                                            this._idle = null; // fallback state
                                            this._initWorker();
                                        }

                                        _flattenTiles() {
                                            const out = new Uint8Array(this.w * this.h);
                                            for (let x = 0; x < this.w; x++) out.set(this.world.tiles[x], x * this.h);
                                            return out;
                                        }

                                        _initWorker() {
                                            if (typeof Worker === 'undefined') {
                                                console.warn('Worker not available; TileLogicEngine uses idle fallback');
                                                this._initIdleFallback();
                                                return;
                                            }

                                            const code = TileLogicEngine._workerSource();
                                            const blob = new Blob([code], { type: 'text/javascript' });
                                            const url = URL.createObjectURL(blob);

                                            let worker;
                                            try {
                                                worker = new Worker(url);
                                            } catch (e) {
                                                console.warn('Worker blocked; fallback to idle', e);
                                                try { URL.revokeObjectURL(url); } catch { }
                                                this._initIdleFallback();
                                                return;
                                            }

                                            try { URL.revokeObjectURL(url); } catch { }

                                            this.worker = worker;

                                            worker.onmessage = (e) => {
                                                const msg = e.data;
                                                if (!msg || !msg.type) return;
                                                if (msg.type === 'changes' && msg.buf) {
                                                    try {
                                                        const arr = new Int32Array(msg.buf);
                                                        this.pending.push({ arr, pos: 0 });
                                                        this._scheduleApply();
                                                    } catch { }
                                                }
                                            };

                                            worker.onerror = (e) => {
                                                console.warn('TileLogic worker error', e);
                                                try { worker.terminate(); } catch { }
                                                this.worker = null;
                                                this._initIdleFallback();
                                            };

                                            try {
                                                const tilesFlat = this._flattenTiles();
                                                const solidCopy = new Uint8Array(256);
                                                try { solidCopy.set(SOLID); } catch { }
                                                worker.postMessage({
                                                    type: 'init',
                                                    w: this.w,
                                                    h: this.h,
                                                    tiles: tilesFlat.buffer,
                                                    solid: solidCopy.buffer,
                                                    ids: IDS,
                                                    blocks: { AIR: (B && B.AIR !== undefined) ? B.AIR : 0, WATER: (B && B.WATER !== undefined) ? B.WATER : 27 }
                                                }, [tilesFlat.buffer, solidCopy.buffer]);
                                            } catch (e) {
                                                console.warn('TileLogic worker init failed', e);
                                            }
                                        }

                                        _initIdleFallback() {
                                            // Full idle fallback: water + logic, both processed during requestIdleCallback.
                                            const tiles = this._flattenTiles();
                                            const N = tiles.length;

                                            const WATER = (B && B.WATER !== undefined) ? B.WATER : 27;
                                            const AIR = (B && B.AIR !== undefined) ? B.AIR : 0;
                                            const MAX = 8;

                                            const water = new Uint8Array(N);
                                            for (let i = 0; i < N; i++) if (tiles[i] === WATER) water[i] = MAX;

                                            const waterMark = new Uint8Array(N);
                                            const waterQ = [];
                                            const logicMark = new Uint8Array(N);
                                            const logicQ = [];

                                            // Region limiter for main-thread fallback (protect FPS)
                                            const region = { x0: 0, y0: 0, x1: -1, y1: -1, set: false, key: '' };

                                            const inRegionIndex = (i) => {
                                                if (!region.set) return false;
                                                const x = (i / this.h) | 0;
                                                const y = i - x * this.h;
                                                return (x >= region.x0 && x <= region.x1 && y >= region.y0 && y <= region.y1);
                                            };

                                            const idx = (x, y) => x * this.h + y;

                                            const scheduleWater = (i) => {
                                                if (!inRegionIndex(i)) return;
                                                if (waterMark[i]) return;
                                                waterMark[i] = 1;
                                                waterQ.push(i);
                                            };
                                            const scheduleWaterAround = (x, y) => {
                                                if (x < 0 || y < 0 || x >= this.w || y >= this.h) return;
                                                scheduleWater(idx(x, y));
                                                if (x > 0) scheduleWater(idx(x - 1, y));
                                                if (x + 1 < this.w) scheduleWater(idx(x + 1, y));
                                                if (y > 0) scheduleWater(idx(x, y - 1));
                                                if (y + 1 < this.h) scheduleWater(idx(x, y + 1));
                                            };

                                            const scheduleLogic = (i) => {
                                                if (!inRegionIndex(i)) return;
                                                if (logicMark[i]) return;
                                                logicMark[i] = 1;
                                                logicQ.push(i);
                                            };
                                            const scheduleLogicAround = (x, y) => {
                                                if (x < 0 || y < 0 || x >= this.w || y >= this.h) return;
                                                scheduleLogic(idx(x, y));
                                                if (x > 0) scheduleLogic(idx(x - 1, y));
                                                if (x + 1 < this.w) scheduleLogic(idx(x + 1, y));
                                                if (y > 0) scheduleLogic(idx(x, y - 1));
                                                if (y + 1 < this.h) scheduleLogic(idx(x, y + 1));
                                            };

                                            const isWire = (id) => id === IDS.WIRE_OFF || id === IDS.WIRE_ON;
                                            const isSwitch = (id) => id === IDS.SWITCH_OFF || id === IDS.SWITCH_ON;
                                            const isSource = (id) => id === IDS.SWITCH_ON;
                                            const isLamp = (id) => id === IDS.LAMP_OFF || id === IDS.LAMP_ON;
                                            const isConductor = (id) => isWire(id) || isSwitch(id);

                                            const canWaterEnterTile = (id) => (id === AIR || id === WATER);

                                            const setTile = (i, newId, changes) => {
                                                const old = tiles[i];
                                                if (old === newId) return false;
                                                tiles[i] = newId;
                                                changes.push(i, old, newId);
                                                const x = (i / this.h) | 0;
                                                const y = i - x * this.h;
                                                scheduleWaterAround(x, y);
                                                scheduleLogicAround(x, y);
                                                return true;
                                            };

                                            const ensureWaterTile = (i, changes) => {
                                                if (water[i] > 0) {
                                                    if (tiles[i] !== WATER) setTile(i, WATER, changes);
                                                } else {
                                                    if (tiles[i] === WATER) setTile(i, AIR, changes);
                                                }
                                            };

                                            const waterTick = (i, changes) => {
                                                waterMark[i] = 0;
                                                if (!inRegionIndex(i)) return;

                                                let a = water[i] | 0;
                                                if (a <= 0) return;

                                                const tid = tiles[i];
                                                if (tid !== WATER && tid !== AIR) { water[i] = 0; return; }

                                                const x = (i / this.h) | 0;
                                                const y = i - x * this.h;

                                                if (y + 1 < this.h) {
                                                    const d = i + 1;
                                                    const dt = tiles[d];
                                                    if (canWaterEnterTile(dt)) {
                                                        const b = water[d] | 0;
                                                        const space = MAX - b;
                                                        if (space > 0) {
                                                            const mv = a < space ? a : space;
                                                            water[i] = a - mv;
                                                            water[d] = b + mv;
                                                            a = water[i] | 0;

                                                            ensureWaterTile(i, changes);
                                                            ensureWaterTile(d, changes);

                                                            scheduleWater(d);
                                                            scheduleWater(i);
                                                            scheduleWaterAround(x, y);
                                                            scheduleWaterAround(x, y + 1);
                                                        }
                                                    }
                                                }

                                                if (a <= 0) return;

                                                const flowSide = (n) => {
                                                    const nt = tiles[n];
                                                    if (!canWaterEnterTile(nt)) return;
                                                    const nb = water[n] | 0;
                                                    const diff = a - nb;
                                                    if (diff <= 1) return;
                                                    let mv = diff >> 1;
                                                    if (mv < 1) mv = 1;
                                                    const space = MAX - nb;
                                                    if (mv > space) mv = space;
                                                    if (mv <= 0) return;

                                                    water[i] = (water[i] | 0) - mv;
                                                    water[n] = nb + mv;
                                                    a = water[i] | 0;

                                                    ensureWaterTile(i, changes);
                                                    ensureWaterTile(n, changes);

                                                    scheduleWater(n);
                                                    scheduleWater(i);
                                                };

                                                if (x > 0) flowSide(i - this.h);
                                                if (x + 1 < this.w) flowSide(i + this.h);
                                            };

                                            // logic BFS bookkeeping
                                            let vis = new Uint32Array(N);
                                            let stamp = 1;

                                            const lampShouldOn = (iLamp) => {
                                                const x = (iLamp / this.h) | 0;
                                                const y = iLamp - x * this.h;
                                                if (x > 0) { const t = tiles[iLamp - this.h]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
                                                if (x + 1 < this.w) { const t = tiles[iLamp + this.h]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
                                                if (y > 0) { const t = tiles[iLamp - 1]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
                                                if (y + 1 < this.h) { const t = tiles[iLamp + 1]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
                                                return false;
                                            };

                                            const updateLampAt = (iLamp, changes) => {
                                                const t = tiles[iLamp];
                                                if (!isLamp(t)) return;
                                                const want = lampShouldOn(iLamp) ? IDS.LAMP_ON : IDS.LAMP_OFF;
                                                if (t !== want) setTile(iLamp, want, changes);
                                            };

                                            const logicRecomputeFromSeed = (seed, changes) => {
                                                logicMark[seed] = 0;

                                                stamp = (stamp + 1) >>> 0;
                                                if (stamp === 0) { stamp = 1; vis.fill(0); }

                                                const starts = [];
                                                const sid = tiles[seed];
                                                if (isConductor(sid)) starts.push(seed);
                                                else {
                                                    const x = (seed / this.h) | 0;
                                                    const y = seed - x * this.h;
                                                    if (x > 0) { const n = seed - this.h; if (isConductor(tiles[n])) starts.push(n); }
                                                    if (x + 1 < this.w) { const n = seed + this.h; if (isConductor(tiles[n])) starts.push(n); }
                                                    if (y > 0) { const n = seed - 1; if (isConductor(tiles[n])) starts.push(n); }
                                                    if (y + 1 < this.h) { const n = seed + 1; if (isConductor(tiles[n])) starts.push(n); }
                                                    if (isLamp(sid)) updateLampAt(seed, changes);
                                                }
                                                if (!starts.length) return;

                                                const q = [];
                                                const comp = [];
                                                let powered = false;

                                                for (let si = 0; si < starts.length; si++) {
                                                    const s = starts[si];
                                                    if (vis[s] === stamp) continue;
                                                    vis[s] = stamp;
                                                    q.push(s);

                                                    while (q.length) {
                                                        const i = q.pop();
                                                        const t = tiles[i];
                                                        if (!isConductor(t)) continue;

                                                        comp.push(i);
                                                        if (isSource(t)) powered = true;

                                                        const x = (i / this.h) | 0;
                                                        const y = i - x * this.h;

                                                        if (x > 0) { const n = i - this.h; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }
                                                        if (x + 1 < this.w) { const n = i + this.h; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }
                                                        if (y > 0) { const n = i - 1; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }
                                                        if (y + 1 < this.h) { const n = i + 1; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }

                                                        if (comp.length > 12000) break;
                                                    }
                                                    if (comp.length > 12000) break;
                                                }

                                                const wantWire = powered ? IDS.WIRE_ON : IDS.WIRE_OFF;

                                                for (let i = 0; i < comp.length; i++) {
                                                    const p = comp[i];
                                                    const t = tiles[p];
                                                    if (isWire(t) && t !== wantWire) setTile(p, wantWire, changes);
                                                }

                                                for (let i = 0; i < comp.length; i++) {
                                                    const p = comp[i];
                                                    const x = (p / this.h) | 0;
                                                    const y = p - x * this.h;
                                                    if (x > 0) updateLampAt(p - this.h, changes);
                                                    if (x + 1 < this.w) updateLampAt(p + this.h, changes);
                                                    if (y > 0) updateLampAt(p - 1, changes);
                                                    if (y + 1 < this.h) updateLampAt(p + 1, changes);
                                                }
                                            };

                                            const primeRegion = () => {
                                                if (!region.set) return;
                                                for (let x = region.x0; x <= region.x1; x++) {
                                                    const base = x * this.h;
                                                    for (let y = region.y0; y <= region.y1; y++) {
                                                        const i = base + y;
                                                        if (water[i] > 0) scheduleWater(i);
                                                        const t = tiles[i];
                                                        if (t === IDS.SWITCH_ON || isWire(t) || isLamp(t)) scheduleLogic(i);
                                                    }
                                                }
                                            };

                                            // store fallback state
                                            this._idle = {
                                                tiles, water, waterMark, waterQ,
                                                logicMark, logicQ,
                                                region,
                                                idx, scheduleWaterAround, scheduleLogicAround,
                                                setTile, primeRegion,
                                                waterTick, logicRecomputeFromSeed,
                                                perfLevel: 'high',
                                                WATER, AIR
                                            };

                                            const step = (deadline) => {
                                                if (!this._enabled || !this._idle) return;

                                                const st = this._idle;
                                                const changes = [];

                                                const waterBudget = (st.perfLevel === 'low') ? 220 : 520;
                                                const logicBudget = 1;

                                                let ops = 0;
                                                while (ops < waterBudget && st.waterQ.length && (deadline.timeRemaining() > 1 || deadline.didTimeout)) {
                                                    const i = st.waterQ.pop();
                                                    st.waterTick(i, changes);
                                                    ops++;
                                                }

                                                let lops = 0;
                                                while (lops < logicBudget && st.logicQ.length && (deadline.timeRemaining() > 1 || deadline.didTimeout)) {
                                                    const i = st.logicQ.pop();
                                                    st.logicRecomputeFromSeed(i, changes);
                                                    lops++;
                                                }

                                                if (changes.length) {
                                                    this.pending.push({ arr: new Int32Array(changes), pos: 0 });
                                                    this._scheduleApply();
                                                }

                                                ric(step, { timeout: 50 });
                                            };

                                            ric(step, { timeout: 50 });
                                        }

                                        notifyTileWrite(x, y, newId) {
                                            if (!this._enabled) return;

                                            if (this.worker) {
                                                try { this.worker.postMessage({ type: 'tileWrite', x: x | 0, y: y | 0, id: newId | 0 }); } catch { }
                                                return;
                                            }

                                            if (!this._idle) return;
                                            const st = this._idle;

                                            const idx = (x | 0) * this.h + (y | 0);
                                            const old = st.tiles[idx];
                                            st.tiles[idx] = newId | 0;

                                            if (newId === st.WATER) st.water[idx] = 8;
                                            if (old === st.WATER && newId !== st.WATER) st.water[idx] = 0;

                                            st.scheduleWaterAround(x, y);
                                            st.scheduleLogicAround(x, y);
                                        }

                                        onFrame(dt) {
                                            // é˜²å¾¡æ€§å‚æ•°æ£€æŸ¥
                                            if (typeof dt !== 'number' || dt < 0) {
                                                console.warn(`[TileLogicEngine.onFrame] Invalid dt: ${dt}`);
                                                dt = 16.67;
                                            }

                                            if (!this._enabled) return;

                                            // é˜²å¾¡æ€§ï¼šæ£€æŸ¥gameå’Œworld
                                            if (!this.game || !this.game.world) {
                                                console.warn('[TileLogicEngine.onFrame] Game/World not available');
                                                return;
                                            }

                                            const now = performance.now();

                                            if (this.worker) {
                                                if (now - this._lastRegionSent > 250) {
                                                    this._lastRegionSent = now;
                                                    try {
                                                        const px = (this.game.player.x / CFG.TILE_SIZE) | 0;
                                                        const py = (this.game.player.y / CFG.TILE_SIZE) | 0;
                                                        this.worker.postMessage({ type: 'region', cx: px, cy: py, rx: 60, ry: 45 });
                                                    } catch { }
                                                }

                                                const lvl = (this.game._perf && this.game._perf.level) ? this.game._perf.level : 'high';
                                                if (lvl !== this._lastPerfSent) {
                                                    this._lastPerfSent = lvl;
                                                    try { this.worker.postMessage({ type: 'perf', level: lvl }); } catch { }
                                                }
                                                return;
                                            }

                                            // idle fallback: update region & perf
                                            if (this._idle && (now - this._lastRegionSent > 350)) {
                                                this._lastRegionSent = now;
                                                const st = this._idle;

                                                const px = (this.game.player.x / CFG.TILE_SIZE) | 0;
                                                const py = (this.game.player.y / CFG.TILE_SIZE) | 0;
                                                const rx = 60, ry = 45;

                                                const x0 = Math.max(0, px - rx);
                                                const x1 = Math.min(this.w - 1, px + rx);
                                                const y0 = Math.max(0, py - ry);
                                                const y1 = Math.min(this.h - 1, py + ry);

                                                const key = x0 + ',' + y0 + ',' + x1 + ',' + y1;
                                                if (key !== st.region.key) {
                                                    st.region.key = key;
                                                    st.region.x0 = x0; st.region.x1 = x1; st.region.y0 = y0; st.region.y1 = y1; st.region.set = true;
                                                    st.primeRegion();
                                                } else {
                                                    st.region.set = true;
                                                }

                                                const lvl = (this.game._perf && this.game._perf.level) ? this.game._perf.level : 'high';
                                                st.perfLevel = lvl;
                                            }
                                        }

                                        _scheduleApply() {
                                            if (this._applyScheduled) return;
                                            this._applyScheduled = true;
                                            ric((deadline) => this._applyPending(deadline), { timeout: 50 });
                                        }

                                        _applyPending(deadline) {
                                            // é˜²å¾¡æ€§å‚æ•°æ£€æŸ¥
                                            if (!deadline) {
                                                console.warn('[TileLogicEngine._applyPending] No deadline provided');
                                                deadline = { timeRemaining: () => 16, didTimeout: false };
                                            }

                                            this._applyScheduled = false;
                                            if (!this.pending || !this.pending.length) return;

                                            // é˜²å¾¡æ€§ï¼šæ£€æŸ¥gameå’Œworld
                                            if (!this.game || !this.game.world) {
                                                console.warn('[TileLogicEngine._applyPending] Game/World not available');
                                                return;
                                            }

                                            const game = this.game;
                                            const world = this.world;
                                            const renderer = game && game.renderer;

                                            let any = false;
                                            let lightSeeds = [];
                                            const maxLightSeeds = 16;

                                            const maxOps = 1600;
                                            let ops = 0;

                                            while (this.pending.length && (deadline.timeRemaining() > 2 || deadline.didTimeout) && ops < maxOps) {
                                                const cur = this.pending[0];
                                                const arr = cur.arr;

                                                while (cur.pos < arr.length && ops < maxOps) {
                                                    const idx = arr[cur.pos++];
                                                    const expectOld = arr[cur.pos++];
                                                    const newId = arr[cur.pos++];

                                                    const x = (idx / this.h) | 0;
                                                    const y = idx - x * this.h;
                                                    if (x < 0 || y < 0 || x >= this.w || y >= this.h) { ops++; continue; }

                                                    const col = world.tiles[x];
                                                    const oldMain = col[y];
                                                    if (oldMain !== expectOld) { ops++; continue; } // stale -> ignore

                                                    col[y] = newId;
                                                    any = true;

                                                    try { renderer && renderer.invalidateTile && renderer.invalidateTile(x, y); } catch { }

                                                    if (BL) {
                                                        const blOld = BL[expectOld] | 0;
                                                        const blNew = BL[newId] | 0;
                                                        if (blOld !== blNew && lightSeeds.length < maxLightSeeds) lightSeeds.push([x, y]);
                                                    }

                                                    this._minimapDirty = true;

                                                    ops++;
                                                }

                                                if (cur.pos >= arr.length) this.pending.shift();
                                                else break;
                                            }

                                            if (any) {
                                                if (lightSeeds.length && game && game._deferLightUpdate) {
                                                    for (let i = 0; i < lightSeeds.length; i++) {
                                                        const p = lightSeeds[i];
                                                        try { game._deferLightUpdate(p[0], p[1]); } catch { }
                                                    }
                                                }

                                                const now = performance.now();
                                                if (this._minimapDirty && (now - this._lastMinimapFlush > 600)) {
                                                    this._minimapDirty = false;
                                                    this._lastMinimapFlush = now;
                                                    try { game._deferMinimapUpdate && game._deferMinimapUpdate(); } catch { }
                                                }
                                            }

                                            if (this.pending.length) this._scheduleApply();
                                        }

                                        static _workerSource() {
                                            return `/* TileLogic Worker v12 */
(() => {
  let W = 0, H = 0;
  let tiles = null;
  let water = null;
  let solid = null;

  let AIR = 0, WATER = 27;
  let IDS = null;

  const region = { x0: 0, y0: 0, x1: -1, y1: -1, set: false };
  let lastRegionKey = '';
  let perfLevel = 'high';
  const MAX = 8;

  const waterQ = [];
  let waterMark = null;
  const logicQ = [];
  let logicMark = null;
function scheduleLogic(i) {
    if (!logicMark) return;
    if (!inRegionIndex(i)) return;
    if (logicMark[i]) return;
    logicMark[i] = 1;
    logicQ.push(i);
  }

  function scheduleLogicAround(x, y) {
    if (x < 0 || y < 0 || x >= W || y >= H) return;
    scheduleLogic(idx(x, y));
    if (x > 0) scheduleLogic(idx(x - 1, y));
    if (x + 1 < W) scheduleLogic(idx(x + 1, y));
    if (y > 0) scheduleLogic(idx(x, y - 1));
    if (y + 1 < H) scheduleLogic(idx(x, y + 1));
  }

  function setTile(i, newId, changes) {
    const old = tiles[i];
    if (old === newId) return false;
    tiles[i] = newId;
    changes.push(i, old, newId);
    const x = (i / H) | 0;
    const y = i - x * H;
    scheduleWaterAround(x, y);
    scheduleLogicAround(x, y);
    return true;
  }

  function ensureWaterTile(i, changes) {
    if (water[i] > 0) {
      if (tiles[i] !== WATER) setTile(i, WATER, changes);
    } else {
      if (tiles[i] === WATER) setTile(i, AIR, changes);
    }
  }

  function waterTick(i, changes) {
    waterMark[i] = 0;
    if (!inRegionIndex(i)) return;

    let a = water[i] | 0;
    if (a <= 0) return;

    const tid = tiles[i];
    if (tid !== WATER && tid !== AIR) { water[i] = 0; return; }

    const x = (i / H) | 0;
    const y = i - x * H;

    if (y + 1 < H) {
      const d = i + 1;
      const dt = tiles[d];
      if (canWaterEnterTile(dt)) {
        const b = water[d] | 0;
        const space = MAX - b;
        if (space > 0) {
          const mv = a < space ? a : space;
          water[i] = a - mv;
          water[d] = b + mv;
          a = water[i] | 0;

          ensureWaterTile(i, changes);
          ensureWaterTile(d, changes);

          scheduleWater(d);
          scheduleWater(i);
          scheduleWaterAround(x, y);
          scheduleWaterAround(x, y + 1);
        }
      }
    }

    if (a <= 0) return;

    function flowSide(n) {
      const nt = tiles[n];
      if (!canWaterEnterTile(nt)) return;
      const nb = water[n] | 0;
      const diff = a - nb;
      if (diff <= 1) return;
      let mv = diff >> 1;
      if (mv < 1) mv = 1;
      const space = MAX - nb;
      if (mv > space) mv = space;
      if (mv <= 0) return;

      water[i] = (water[i] | 0) - mv;
      water[n] = nb + mv;
      a = water[i] | 0;

      ensureWaterTile(i, changes);
      ensureWaterTile(n, changes);

      scheduleWater(n);
      scheduleWater(i);
    }

    if (x > 0) flowSide(i - H);
    if (x + 1 < W) flowSide(i + H);
  }

  let vis = null;
  let stamp = 1;
  function ensureVis() {
    const N = W * H;
    if (!vis || vis.length !== N) vis = new Uint32Array(N);
  }

  function lampShouldOn(iLamp) {
    const x = (iLamp / H) | 0;
    const y = iLamp - x * H;
    if (x > 0) { const t = tiles[iLamp - H]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
    if (x + 1 < W) { const t = tiles[iLamp + H]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
    if (y > 0) { const t = tiles[iLamp - 1]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
    if (y + 1 < H) { const t = tiles[iLamp + 1]; if (t === IDS.WIRE_ON || t === IDS.SWITCH_ON) return true; }
    return false;
  }

  function updateLampAt(iLamp, changes) {
    const t = tiles[iLamp];
    if (!(t === IDS.LAMP_OFF || t === IDS.LAMP_ON)) return;
    const want = lampShouldOn(iLamp) ? IDS.LAMP_ON : IDS.LAMP_OFF;
    if (t !== want) setTile(iLamp, want, changes);
  }

  function logicRecomputeFromSeed(seed, changes) {
    logicMark[seed] = 0;

    ensureVis();
    stamp = (stamp + 1) >>> 0;
    if (stamp === 0) { stamp = 1; vis.fill(0); }

    const starts = [];
    const sid = tiles[seed];
    if (isConductor(sid)) starts.push(seed);
    else {
      const x = (seed / H) | 0;
      const y = seed - x * H;
      if (x > 0) { const n = seed - H; if (isConductor(tiles[n])) starts.push(n); }
      if (x + 1 < W) { const n = seed + H; if (isConductor(tiles[n])) starts.push(n); }
      if (y > 0) { const n = seed - 1; if (isConductor(tiles[n])) starts.push(n); }
      if (y + 1 < H) { const n = seed + 1; if (isConductor(tiles[n])) starts.push(n); }
      if (isLamp(sid)) updateLampAt(seed, changes);
    }
    if (!starts.length) return;

    const q = [];
    const comp = [];
    let powered = false;

    for (let si = 0; si < starts.length; si++) {
      const s = starts[si];
      if (vis[s] === stamp) continue;
      vis[s] = stamp;
      q.push(s);

      while (q.length) {
        const i = q.pop();
        const t = tiles[i];
        if (!isConductor(t)) continue;

        comp.push(i);
        if (isSource(t)) powered = true;

        const x = (i / H) | 0;
        const y = i - x * H;

        if (x > 0) { const n = i - H; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }
        if (x + 1 < W) { const n = i + H; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }
        if (y > 0) { const n = i - 1; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }
        if (y + 1 < H) { const n = i + 1; if (vis[n] !== stamp && isConductor(tiles[n])) { vis[n] = stamp; q.push(n); } }

        if (comp.length > 12000) break;
      }
      if (comp.length > 12000) break;
    }

    const wantWire = powered ? IDS.WIRE_ON : IDS.WIRE_OFF;
    for (let i = 0; i < comp.length; i++) {
      const p = comp[i];
      const t = tiles[p];
      if (isWire(t) && t !== wantWire) setTile(p, wantWire, changes);
    }

    for (let i = 0; i < comp.length; i++) {
      const p = comp[i];
      const x = (p / H) | 0;
      const y = p - x * H;
      if (x > 0) updateLampAt(p - H, changes);
      if (x + 1 < W) updateLampAt(p + H, changes);
      if (y > 0) updateLampAt(p - 1, changes);
      if (y + 1 < H) updateLampAt(p + 1, changes);
    }
  }

  function primeRegionWork() {
    if (!region.set) return;
    for (let x = region.x0; x <= region.x1; x++) {
      const base = x * H;
      for (let y = region.y0; y <= region.y1; y++) {
        const i = base + y;
        if (water[i] > 0) scheduleWater(i);
        const t = tiles[i];
        if (t === IDS.SWITCH_ON || isWire(t) || isLamp(t)) scheduleLogic(i);
      }
    }
  }

  function step() {
    const changes = [];

    const waterBudget = (perfLevel === 'low') ? 350 : 900;
    for (let ops = 0; ops < waterBudget && waterQ.length; ops++) {
      waterTick(waterQ.pop(), changes);
    }

    const logicBudget = 1;
    for (let ops = 0; ops < logicBudget && logicQ.length; ops++) {
      logicRecomputeFromSeed(logicQ.pop(), changes);
    }

    if (changes.length) {
      const buf = new Int32Array(changes);
      postMessage({ type: 'changes', buf: buf.buffer }, [buf.buffer]);
    }

    const tickMs = (perfLevel === 'low') ? 55 : 35;
    setTimeout(step, tickMs);
  }

  onmessage = (e) => {
    const m = e.data;
    if (!m || !m.type) return;

    switch (m.type) {
      case 'init': {
        W = m.w | 0;
        H = m.h | 0;
        IDS = m.ids;
        AIR = (m.blocks && (m.blocks.AIR | 0) >= 0) ? (m.blocks.AIR | 0) : 0;
        WATER = (m.blocks && (m.blocks.WATER | 0) >= 0) ? (m.blocks.WATER | 0) : 27;

        tiles = new Uint8Array(m.tiles);
        solid = new Uint8Array(m.solid);

        const N = W * H;
        water = new Uint8Array(N);
        waterMark = new Uint8Array(N);
        logicMark = new Uint8Array(N);
        ensureVis();

        for (let i = 0; i < N; i++) if (tiles[i] === WATER) water[i] = MAX;

        step();
        break;
      }

      case 'tileWrite': {
        if (!tiles) return;
        const x = m.x | 0;
        const y = m.y | 0;
        if (x < 0 || y < 0 || x >= W || y >= H) return;

        const i = idx(x, y);
        const newId = m.id | 0;
        const oldId = tiles[i];
        tiles[i] = newId;

        if (newId === WATER) {
          water[i] = MAX;
          scheduleWaterAround(x, y);
        } else if (oldId === WATER && newId !== WATER) {
          water[i] = 0;
          scheduleWaterAround(x, y);
        }

        scheduleLogicAround(x, y);
        break;
      }

      case 'region': {
        const cx = m.cx | 0, cy = m.cy | 0;
        const rx = m.rx | 0, ry = m.ry | 0;

        const x0 = Math.max(0, cx - rx);
        const x1 = Math.min(W - 1, cx + rx);
        const y0 = Math.max(0, cy - ry);
        const y1 = Math.min(H - 1, cy + ry);

        const key = x0 + ',' + y0 + ',' + x1 + ',' + y1;
        if (key !== lastRegionKey) {
          lastRegionKey = key;
          region.x0 = x0; region.x1 = x1; region.y0 = y0; region.y1 = y1; region.set = true;
          primeRegionWork();
        } else {
          region.set = true;
        }
        break;
      }

      case 'perf': {
        perfLevel = m.level || 'high';
        break;
      }
      default: {
        console.warn('[Worker] Unknown message type: ' + m.type);
        break;
      }
    }
  };
})();`;
                                        }
                                    }

// Use the v9 fluids worker source as the default
if (typeof TileLogicEngine !== "undefined" && typeof buildTileLogicWorkerSourceV9 === "function") {
    TileLogicEngine._workerSource = buildTileLogicWorkerSourceV9;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 16: Weather System & Effects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                                                class WeatherCanvasFX {
                                                    constructor(canvas) {
                                                        this.canvas = canvas;
                                                        this.ctx = canvas ? canvas.getContext('2d', { alpha: true }) : null;

                                                        this._wPx = 0;
                                                        this._hPx = 0;
                                                        this._wCss = 0;
                                                        this._hCss = 0;
                                                        this._dpr = 1;

                                                        this._lastNow = 0;
                                                        this._hadFx = false;

                                                        // deterministic-ish RNG (xorshift32) to reduce Math.random usage during generation
                                                        this._seed = 0x12345678;

                                                        // Rain / snow pattern buffers (offscreen)
                                                        this._rain = { tile: null, ctx: null, pattern: null, size: 0, ox: 0, oy: 0 };
                                                        this._snow = { tile: null, ctx: null, pattern: null, size: 0, ox: 0, oy: 0 };

                                                        // Lightning flash gradient cache (depends on resolution only)
                                                        this._flash = { w: 0, h: 0, grad: null };

                                                        // Lightning bolt (reused object + typed array)
                                                        this._bolt = { pts: null, n: 0, life: 0, maxLife: 0 };
                                                        this._prevLightning = 0;
                                                    }

                                                    _rand01() {
                                                        // xorshift32
                                                        let x = this._seed | 0;
                                                        x ^= (x << 13);
                                                        x ^= (x >>> 17);
                                                        x ^= (x << 5);
                                                        this._seed = x | 0;
                                                        return ((x >>> 0) / 4294967296);
                                                    }

                                                    _makeOffscreenCanvas(w, h) {
                                                        try {
                                                            if (typeof OffscreenCanvas !== 'undefined') return new OffscreenCanvas(w, h);
                                                        } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                                                        const c = document.createElement('canvas');
                                                        c.width = w; c.height = h;
                                                        return c;
                                                    }

                                                    resizeLike(renderer) {
                                                        if (!renderer || !renderer.canvas || !this.canvas || !this.ctx) return;
                                                        const wPx = renderer.canvas.width | 0;
                                                        const hPx = renderer.canvas.height | 0;

                                                        // renderer.w/h are CSS px viewport units used by the game
                                                        const wCss = (renderer.w | 0) || Math.round(window.innerWidth || 0);
                                                        const hCss = (renderer.h | 0) || Math.round(window.innerHeight || 0);

                                                        const dpr = Number(renderer.dpr) || (window.devicePixelRatio || 1);

                                                        const sizeChanged = (this.canvas.width !== wPx) || (this.canvas.height !== hPx);

                                                        if (sizeChanged) {
                                                            this.canvas.width = wPx;
                                                            this.canvas.height = hPx;
                                                            this.canvas.style.width = wCss + 'px';
                                                            this.canvas.style.height = hCss + 'px';

                                                            this._wPx = wPx; this._hPx = hPx;
                                                            this._wCss = wCss; this._hCss = hCss;
                                                            this._dpr = dpr;

                                                            // invalidate caches on resize
                                                            this._rain.pattern = null;
                                                            this._rain.tile = null;
                                                            this._snow.pattern = null;
                                                            this._snow.tile = null;
                                                            this._flash.grad = null;
                                                            this._flash.w = 0; this._flash.h = 0;
                                                        } else {
                                                            this._wPx = wPx; this._hPx = hPx;
                                                            this._wCss = wCss; this._hCss = hCss;
                                                            this._dpr = dpr;
                                                        }

                                                        // Always render in pixel space (identity transform) for predictable pattern scrolling
                                                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                                                        // Keep smoothing on for nicer rain streaks; it mainly affects drawImage scaling.
                                                        try { this.ctx.imageSmoothingEnabled = true; } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                                                    }

                                                    _ensureRainPattern() {
                                                        const ctxOut = this.ctx;
                                                        if (!ctxOut) return;

                                                        // Choose tile size by DPR for fewer repeats
                                                        const tile = (this._dpr > 1.25) ? 512 : 256;
                                                        if (this._rain.pattern && this._rain.size === tile) return;

                                                        const c = this._makeOffscreenCanvas(tile, tile);
                                                        const g = c.getContext('2d', { alpha: true });
                                                        if (!g) return;

                                                        // draw rain streaks onto tile (one-time cost)
                                                        g.setTransform(1, 0, 0, 1, 0, 0);
                                                        g.clearRect(0, 0, tile, tile);

                                                        g.lineCap = 'round';
                                                        g.lineJoin = 'round';

                                                        const drops = Math.round((tile * tile) / 2600); // density knob (higher = denser)
                                                        const angle = 12 * Math.PI / 180;
                                                        const sx = Math.sin(angle);
                                                        const cy = Math.cos(angle);

                                                        // two passes: thin + thick for variation
                                                        for (let pass = 0; pass < 2; pass++) {
                                                            g.lineWidth = pass === 0 ? 1 : 2;
                                                            g.strokeStyle = pass === 0 ? 'rgba(180,220,255,0.55)' : 'rgba(180,220,255,0.35)';

                                                            const n = pass === 0 ? drops : Math.round(drops * 0.35);
                                                            for (let i = 0; i < n; i++) {
                                                                const x = this._rand01() * tile;
                                                                const y = this._rand01() * tile;

                                                                const len = (8 + this._rand01() * 22) * (pass === 0 ? 1 : 1.2);
                                                                const dx = sx * len;
                                                                const dy = cy * len;

                                                                const a = pass === 0
                                                                    ? (0.10 + this._rand01() * 0.22)
                                                                    : (0.06 + this._rand01() * 0.16);

                                                                g.globalAlpha = a;
                                                                g.beginPath();
                                                                g.moveTo(x, y);
                                                                g.lineTo(x + dx, y + dy);
                                                                g.stroke();
                                                            }
                                                        }

                                                        g.globalAlpha = 1;

                                                        // pattern is tied to output ctx
                                                        const p = ctxOut.createPattern(c, 'repeat');
                                                        if (!p) return;

                                                        this._rain.tile = c;
                                                        this._rain.ctx = g;
                                                        this._rain.pattern = p;
                                                        this._rain.size = tile;
                                                        this._rain.ox = 0;
                                                        this._rain.oy = 0;
                                                    }

                                                    _ensureSnowPattern() {
                                                        const ctxOut = this.ctx;
                                                        if (!ctxOut) return;

                                                        const tile = (this._dpr > 1.25) ? 384 : 256;
                                                        if (this._snow.pattern && this._snow.size === tile) return;

                                                        const c = this._makeOffscreenCanvas(tile, tile);
                                                        const g = c.getContext('2d', { alpha: true });
                                                        if (!g) return;

                                                        g.setTransform(1, 0, 0, 1, 0, 0);
                                                        g.clearRect(0, 0, tile, tile);

                                                        const flakes = Math.round((tile * tile) / 5200);
                                                        g.fillStyle = 'rgba(255,255,255,0.9)';
                                                        for (let i = 0; i < flakes; i++) {
                                                            const x = this._rand01() * tile;
                                                            const y = this._rand01() * tile;
                                                            const r = 0.8 + this._rand01() * 1.8;
                                                            const a = 0.10 + this._rand01() * 0.35;

                                                            g.globalAlpha = a;
                                                            g.beginPath();
                                                            g.arc(x, y, r, 0, Math.PI * 2);
                                                            g.fill();
                                                        }
                                                        g.globalAlpha = 1;

                                                        const p = ctxOut.createPattern(c, 'repeat');
                                                        if (!p) return;

                                                        this._snow.tile = c;
                                                        this._snow.ctx = g;
                                                        this._snow.pattern = p;
                                                        this._snow.size = tile;
                                                        this._snow.ox = 0;
                                                        this._snow.oy = 0;
                                                    }

                                                    drawRain(intensity, dtMs, isThunder) {
                                                        if (!this.ctx) return;
                                                        this._ensureRainPattern();
                                                        if (!this._rain.pattern) return;

                                                        const ctx = this.ctx;
                                                        const w = this._wPx, h = this._hPx;
                                                        const tile = this._rain.size | 0;

                                                        // Speed in px/s, scaled by DPR for consistent look
                                                        const base = (isThunder ? 1400 : 1100) * this._dpr;
                                                        const speed = base * (0.55 + 0.85 * Math.min(1, Math.max(0, intensity)));

                                                        const dt = (dtMs || 0) / 1000;
                                                        // scroll diagonally to match streak angle
                                                        this._rain.oy = (this._rain.oy + speed * dt) % tile;
                                                        this._rain.ox = (this._rain.ox + speed * 0.18 * dt) % tile;

                                                        const ox = this._rain.ox;
                                                        const oy = this._rain.oy;

                                                        // Density & alpha: draw one or two layers (still just 1â€“2 fillRect calls)
                                                        const aBase = (0.10 + 0.28 * intensity) * (isThunder ? 1.10 : 1.0);

                                                        ctx.globalCompositeOperation = 'source-over';
                                                        ctx.fillStyle = this._rain.pattern;

                                                        // Far layer (subtle)
                                                        ctx.globalAlpha = aBase * 0.55;
                                                        ctx.setTransform(1, 0, 0, 1, -ox * 0.65, -oy * 0.65);
                                                        ctx.fillRect(0, 0, w + tile, h + tile);

                                                        // Near layer
                                                        ctx.globalAlpha = aBase;
                                                        ctx.setTransform(1, 0, 0, 1, -ox, -oy);
                                                        ctx.fillRect(0, 0, w + tile, h + tile);

                                                        // Reset
                                                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                                                        ctx.globalAlpha = 1;
                                                    }

                                                    drawSnow(intensity, dtMs) {
                                                        if (!this.ctx) return;
                                                        this._ensureSnowPattern();
                                                        if (!this._snow.pattern) return;

                                                        const ctx = this.ctx;
                                                        const w = this._wPx, h = this._hPx;
                                                        const tile = this._snow.size | 0;

                                                        const dt = (dtMs || 0) / 1000;

                                                        // Slow fall + gentle drift
                                                        const fall = (180 + 240 * intensity) * this._dpr;
                                                        const drift = (40 + 80 * intensity) * this._dpr;

                                                        this._snow.oy = (this._snow.oy + fall * dt) % tile;
                                                        this._snow.ox = (this._snow.ox + drift * dt) % tile;

                                                        const ox = this._snow.ox;
                                                        const oy = this._snow.oy;

                                                        const aBase = 0.08 + 0.22 * intensity;

                                                        ctx.globalCompositeOperation = 'source-over';
                                                        ctx.fillStyle = this._snow.pattern;

                                                        // Far layer (less alpha, slower)
                                                        ctx.globalAlpha = aBase * 0.50;
                                                        ctx.setTransform(1, 0, 0, 1, -ox * 0.55, -oy * 0.55);
                                                        ctx.fillRect(0, 0, w + tile, h + tile);

                                                        // Near layer
                                                        ctx.globalAlpha = aBase;
                                                        ctx.setTransform(1, 0, 0, 1, -ox, -oy);
                                                        ctx.fillRect(0, 0, w + tile, h + tile);

                                                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                                                        ctx.globalAlpha = 1;
                                                    }

                                                    _ensureFlashGradient() {
                                                        const ctx = this.ctx;
                                                        if (!ctx) return;

                                                        const w = this._wPx | 0;
                                                        const h = this._hPx | 0;

                                                        if (this._flash.grad && this._flash.w === w && this._flash.h === h) return;

                                                        const cx = w * 0.5;
                                                        const cy = h * 0.45;
                                                        const r0 = Math.min(w, h) * 0.06;
                                                        const r1 = Math.max(w, h) * 0.95;

                                                        const g = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);
                                                        g.addColorStop(0, 'rgba(255,255,255,1)');
                                                        g.addColorStop(1, 'rgba(255,255,255,0)');

                                                        this._flash.grad = g;
                                                        this._flash.w = w;
                                                        this._flash.h = h;
                                                    }

                                                    _spawnBolt() {
                                                        const w = this._wPx | 0;
                                                        const h = this._hPx | 0;
                                                        if (w <= 0 || h <= 0) return;

                                                        const segs = 18;
                                                        if (!this._bolt.pts || this._bolt.pts.length !== segs * 2) {
                                                            this._bolt.pts = new Float32Array(segs * 2);
                                                        }

                                                        let x = w * (0.22 + this._rand01() * 0.56);
                                                        let y = -h * 0.05;
                                                        const stepY = (h * 1.08) / (segs - 1);
                                                        let amp = w * 0.10;

                                                        const pts = this._bolt.pts;
                                                        for (let i = 0; i < segs; i++) {
                                                            pts[i * 2] = x;
                                                            pts[i * 2 + 1] = y;

                                                            y += stepY;
                                                            x += (this._rand01() - 0.5) * amp;
                                                            amp *= 0.82;
                                                        }

                                                        this._bolt.n = segs;
                                                        this._bolt.maxLife = 120 + (this._rand01() * 80); // ms
                                                        this._bolt.life = this._bolt.maxLife;
                                                    }

                                                    drawLightning(lightning, dtMs) {
                                                        if (!this.ctx) return;
                                                        const ctx = this.ctx;
                                                        const w = this._wPx, h = this._hPx;

                                                        const f = Math.min(1, Math.max(0, Number(lightning) || 0));
                                                        if (f <= 0.001) return;

                                                        // Rising edge: spawn a visible bolt sometimes
                                                        if (f > 0.75 && this._prevLightning <= 0.12) {
                                                            this._spawnBolt();
                                                        }

                                                        // 1) Flash overlay (cheap): 2 fillRect, cached gradient, no string allocations per frame
                                                        this._ensureFlashGradient();

                                                        ctx.globalCompositeOperation = 'screen';

                                                        // Full-screen cool flash
                                                        ctx.globalAlpha = 0.10 + 0.34 * f;
                                                        ctx.fillStyle = 'rgb(210,230,255)';
                                                        ctx.fillRect(0, 0, w, h);

                                                        // Radial highlight
                                                        if (this._flash.grad) {
                                                            ctx.globalAlpha = 0.18 * f;
                                                            ctx.fillStyle = this._flash.grad;
                                                            ctx.fillRect(0, 0, w, h);
                                                        }

                                                        // 2) Bolt (optional, short-lived)
                                                        if (this._bolt && this._bolt.life > 0 && this._bolt.pts && this._bolt.n >= 2) {
                                                            const dt = Math.max(0, Number(dtMs) || 0);
                                                            this._bolt.life = Math.max(0, this._bolt.life - dt);

                                                            const life01 = this._bolt.maxLife > 0 ? (this._bolt.life / this._bolt.maxLife) : 0;
                                                            if (life01 > 0.001) {
                                                                const pts = this._bolt.pts;
                                                                const n = this._bolt.n;

                                                                ctx.lineCap = 'round';
                                                                ctx.lineJoin = 'round';

                                                                ctx.beginPath();
                                                                ctx.moveTo(pts[0], pts[1]);
                                                                for (let i = 1; i < n; i++) {
                                                                    const j = i * 2;
                                                                    ctx.lineTo(pts[j], pts[j + 1]);
                                                                }

                                                                const s = (this._dpr || 1);

                                                                // Outer glow-ish stroke (no shadowBlur to keep it cheap)
                                                                ctx.globalAlpha = 0.10 * f * life01;
                                                                ctx.strokeStyle = 'rgb(140,190,255)';
                                                                ctx.lineWidth = 5.5 * s;
                                                                ctx.stroke();

                                                                // Core stroke
                                                                ctx.globalAlpha = 0.70 * f * life01;
                                                                ctx.strokeStyle = 'rgb(255,255,255)';
                                                                ctx.lineWidth = 1.8 * s;
                                                                ctx.stroke();
                                                            }
                                                        }

                                                        // reset minimal states
                                                        ctx.globalAlpha = 1;
                                                        ctx.globalCompositeOperation = 'source-over';
                                                    }

                                                    render(weather, renderer) {
                                                        if (!this.ctx || !this.canvas) return;

                                                        // Respect reduced-motion: hide & clear once
                                                        const reduced = !!(document.documentElement && document.documentElement.classList.contains('reduced-motion'));
                                                        if (reduced) {
                                                            if (this._hadFx) {
                                                                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                                                                this.ctx.clearRect(0, 0, this._wPx || this.canvas.width, this._hPx || this.canvas.height);
                                                                this._hadFx = false;
                                                            }
                                                            return;
                                                        }

                                                        this.resizeLike(renderer);

                                                        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                                                        let dtMs = now - (this._lastNow || now);
                                                        if (!Number.isFinite(dtMs)) dtMs = 0;
                                                        if (dtMs < 0) dtMs = 0;
                                                        if (dtMs > 200) dtMs = 200;
                                                        this._lastNow = now;

                                                        const w = weather || {};
                                                        const type = (w.type || 'clear').toString();
                                                        const intensity = Number(w.intensity) || 0;
                                                        const lightning = Number(w.lightning) || 0;

                                                        // If nothing to draw, clear once then stop touching the canvas (saves fill-rate)
                                                        if (intensity <= 0.001 && lightning <= 0.001) {
                                                            if (this._hadFx) {
                                                                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                                                                this.ctx.clearRect(0, 0, this._wPx, this._hPx);
                                                                this._hadFx = false;
                                                            }
                                                            this._prevLightning = lightning;
                                                            return;
                                                        }

                                                        this._hadFx = true;

                                                        // Clear overlay each frame when active (transparent canvas)
                                                        const ctx = this.ctx;
                                                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                                                        ctx.clearRect(0, 0, this._wPx, this._hPx);

                                                        if ((type === 'rain' || type === 'thunder') && intensity > 0.01) {
                                                            this.drawRain(intensity, dtMs, type === 'thunder');
                                                        } else if (type === 'snow' && intensity > 0.01) {
                                                            this.drawSnow(intensity, dtMs);
                                                        }

                                                        if (lightning > 0.001) {
                                                            this.drawLightning(lightning, dtMs);
                                                        } else if (this._bolt && this._bolt.life > 0) {
                                                            // Let bolt fade out naturally even if lightning param drops fast
                                                            this.drawLightning(Math.max(0, this._prevLightning * 0.8), dtMs);
                                                        }

                                                        this._prevLightning = lightning;
                                                    }
                                                }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 17: WorldWorkerClient
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                                                class WorldWorkerClient {
                                                    constructor() {
                                                        // é˜²å¾¡æ€§åˆå§‹åŒ–
                                                        this.worker = null;
                                                        this._initSent = false;
                                                        this._pendingGen = null;
                                                        this._reqId = 1;
                                                        this._state = 'idle';
                                                        this._stateLock = Promise.resolve();
                                                        this._seq = 0;
                                                        this._pending = new Map();
                                                        this._processedSeqs = new Set();

                                                        let __tuWwRender = true;
                                                        try { __tuWwRender = (typeof localStorage === 'undefined' || localStorage.getItem('tuWorkerRender') !== '0'); } catch (_) { __tuWwRender = true; }
                                                        this._renderEnabled = !!SUPPORT_RENDER_WORKER && __tuWwRender;
                                                        this._worldReady = false;

                                                        this._frameInFlight = false;
                                                        this._frameId = 1;
                                                        this._initializing = false;
                                                        this._lastBitmap = null;
                                                        this._lastFrameSentAt = 0;
                                                        this._frameTimeouts = 0;

                                                        this._lightSynced = false;

                                                        this.perf = {
                                                            genMs: null
                                                        };
                                                    }

                                                    get renderEnabled() { return this._renderEnabled; }
                                                    get worldReady() { return this._worldReady; }
                                                    get lightSynced() { return this._lightSynced; }

                                                    _ensureWorker() {
                                                        if (this.worker) return;

                                                        const parts = WorldWorkerClient._buildWorkerSourceParts();
                                                        const blob = new Blob(parts, { type: 'application/javascript' });
                                                        const url = URL.createObjectURL(blob);

                                                        try {
                                                            this.worker = new Worker(url);
                                                        } catch (e) {
                                                            console.error('[WorldWorkerClient] Failed to create worker:', e);
                                                            this._initializing = false;
                                                            throw e;
                                                        }
                                                        URL.revokeObjectURL(url);

                                                        this.worker.onmessage = (e) => this._onMessage(e.data);
                                                        this.worker.onerror = (e) => {
                                                            console.error('[WorldWorker] error event', e);
                                                            if (this._pendingGen) {
                                                                const rej = this._pendingGen.reject;
                                                                this._pendingGen = null;
                                                                try { rej(new Error((e && e.message) ? e.message : 'Worker error')); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                                                            } try { this._frameInFlight = false; this._renderEnabled = false; this._worldReady = false; this._lightSynced = false; if (this._lastBitmap && this._lastBitmap.close) { try { this._lastBitmap.close(); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); } } this._lastBitmap = null; const _w = this.worker; if (_w && _w.terminate) { try { _w.terminate(); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); } } this.worker = null; this._initSent = false; } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                                                        };
                                                    }

                                                    _sendInitOnce() {
                                                        if (this._initSent) return;
                                                        this._initSent = true;

                                                        const structuresEl = document.getElementById('tu-structures-json');
                                                        const structuresJSON = structuresEl ? structuresEl.textContent : '[]';

                                                        // Copy typed arrays so we can transfer their buffers without detaching originals.
                                                        let solidBuf = null;
                                                        let lightBuf = null;
                                                        let sunDecayBuf = null;

                                                        try {
                                                            if (typeof BLOCK_SOLID !== 'undefined' && BLOCK_SOLID) {
                                                                const c = new Uint8Array(BLOCK_SOLID);
                                                                solidBuf = c.buffer;
                                                            }
                                                        } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                                                        try {
                                                            if (typeof BLOCK_LIGHT !== 'undefined' && BLOCK_LIGHT) {
                                                                const c = new Uint8Array(BLOCK_LIGHT);
                                                                lightBuf = c.buffer;
                                                            }
                                                        } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                                                        try {
                                                            if (typeof SUN_DECAY !== 'undefined' && SUN_DECAY) {
                                                                const c = new Uint8Array(SUN_DECAY);
                                                                sunDecayBuf = c.buffer;
                                                            }
                                                        } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                                                        const transfer = [];
                                                        if (solidBuf) transfer.push(solidBuf);
                                                        if (lightBuf) transfer.push(lightBuf);
                                                        if (sunDecayBuf) transfer.push(sunDecayBuf);

                                                        this.worker.postMessage({
                                                            type: 'init',
                                                            CONFIG,
                                                            BLOCK,
                                                            BLOCK_DATA,
                                                            structuresJSON,
                                                            solid: solidBuf,
                                                            light: lightBuf,
                                                            sunDecay: sunDecayBuf,
                                                            renderEnabled: this._renderEnabled
                                                        }, transfer);
                                                    }

                                                    async generate(w, h, seed, progressCb) {
                                                        // é˜²å¾¡æ€§å‚æ•°éªŒè¯
                                                        if (!SUPPORT_GEN_WORKER) {
                                                            throw new Error('Worker not supported');
                                                        }

                                                        // éªŒè¯ä¸–ç•Œå°ºå¯¸
                                                        if (!Number.isInteger(w) || w <= 0 || w > 10000) {
                                                            throw new Error(`Invalid world width: ${w}`);
                                                        }
                                                        if (!Number.isInteger(h) || h <= 0 || h > 10000) {
                                                            throw new Error(`Invalid world height: ${h}`);
                                                        }

                                                        // éªŒè¯ç§å­
                                                        if (seed === undefined || seed === null) {
                                                            seed = Date.now();
                                                        }

                                                        this._ensureWorker();
                                                        this._sendInitOnce();

                                                        this._worldReady = false;
                                                        this._lightSynced = false;

                                                        return await new Promise((resolve, reject) => {
                                                            const id = this._reqId++;
                                                            this._pendingGen = {
                                                                id,
                                                                resolve,
                                                                reject,
                                                                progressCb: (typeof progressCb === 'function') ? progressCb : null,
                                                                t0: _safeNow()
                                                            };
                                                            this.worker.postMessage({
                                                                type: 'generate',
                                                                id,
                                                                w: w | 0,
                                                                h: h | 0,
                                                                seed: seed,
                                                                keepCopy: !!this._renderEnabled
                                                            });
                                                        });
                                                    }

                                                    _onMessage(msg) {
                                                        // é˜²å¾¡æ€§ï¼šéªŒè¯æ¶ˆæ¯æ ¼å¼
                                                        if (!msg || typeof msg !== 'object') {
                                                            console.warn('[WorldWorkerClient] Invalid message format');
                                                            return;
                                                        }
                                                        if (!msg.type) {
                                                            console.warn('[WorldWorkerClient] Message missing type');
                                                            return;
                                                        }

                                                        // åºåˆ—å·éªŒè¯ï¼ˆé˜²é‡æ”¾ï¼‰
                                                        if (msg._seq !== undefined) {
                                                            if (this._processedSeqs.has(msg._seq)) {
                                                                console.warn(`[WorldWorkerClient] Duplicate message seq: ${msg._seq}`);
                                                                return;
                                                            }
                                                            this._processedSeqs.add(msg._seq);
                                                            if (this._processedSeqs.size > 4096) {
                                                                this._processedSeqs.clear();
                                                                this._processedSeqs.add(msg._seq);
                                                            }
                                                        }

                                                        if (msg.type === 'progress') {
                                                            if (this._pendingGen && msg.id === this._pendingGen.id && this._pendingGen.progressCb) {
                                                                try { this._pendingGen.progressCb(msg.status, msg.percent); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                                                            }
                                                            return;
                                                        }

                                                        if (msg.type === 'done') {
                                                            if (!this._pendingGen || msg.id !== this._pendingGen.id) return;

                                                            const { resolve, t0 } = this._pendingGen;
                                                            this._pendingGen = null;

                                                            const w = msg.w | 0;
                                                            const h = msg.h | 0;

                                                            const tilesBuf = msg.tiles;
                                                            const wallsBuf = msg.walls;
                                                            const lightBuf = msg.light;

                                                            const world = { w, h, tiles: new Array(w), walls: new Array(w), light: new Array(w) };
                                                            for (let x = 0; x < w; x++) {
                                                                world.tiles[x] = new Uint8Array(tilesBuf, x * h, h);
                                                                world.walls[x] = new Uint8Array(wallsBuf, x * h, h);
                                                                world.light[x] = new Uint8Array(lightBuf, x * h, h);
                                                            }

                                                            this._worldReady = true;

                                                            const genMs = (typeof msg.genMs === 'number') ? msg.genMs : (_safeNow() - t0);
                                                            this.perf.genMs = genMs;
                                                            try {
                                                                console.info(`[WorldWorker] generated ${w}x${h} in ${genMs.toFixed(1)}ms`);
                                                            } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                                                            // Expose perf for manual benchmarking in devtools.
                                                            window.__TU_PERF__ = window.__TU_PERF__ || {};
                                                            window.__TU_PERF__.worldGenMs = genMs;

                                                            resolve(world);
                                                            return;
                                                        }

                                                        if (msg.type === 'error') {
                                                            console.error('[WorldWorker] message error', msg);
                                                            if (this._pendingGen && msg.id === this._pendingGen.id) {
                                                                const rej = this._pendingGen.reject;
                                                                this._pendingGen = null;
                                                                try { rej(new Error(msg.message || 'Worker error')); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                                                            }
                                                            try { this._frameInFlight = false; this._renderEnabled = false; this._worldReady = false; this._lightSynced = false; if (this._lastBitmap && this._lastBitmap.close) { try { this._lastBitmap.close(); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); } } this._lastBitmap = null; const _w = this.worker; if (_w && _w.terminate) { try { _w.terminate(); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); } } this.worker = null; this._initSent = false; } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); } return;
                                                        }

                                                        if (msg.type === 'frame') {
                                                            // Bitmap world layer for main thread to draw.
                                                            if (this._lastBitmap && this._lastBitmap.close) {
                                                                try { this._lastBitmap.close(); } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                                                            }
                                                            this._lastBitmap = msg.bitmap || null;
                                                            this._frameInFlight = false;
                                                            this._lastFrameSentAt = 0;
                                                            this._frameTimeouts = 0;
                                                            return;
                                                        }
                                                    }

                                                    requestFrame(cam, time, renderer) {
                                                        // é˜²å¾¡æ€§çŠ¶æ€æ£€æŸ¥
                                                        if (!this._renderEnabled || !this._worldReady || !this.worker) return;

                                                        // éªŒè¯ç›¸æœºå¯¹è±¡
                                                        if (!cam || typeof cam.x !== 'number' || typeof cam.y !== 'number') {
                                                            console.warn('[WorldWorkerClient] Invalid camera object');
                                                            return;
                                                        }

                                                        // éªŒè¯renderer
                                                        if (!renderer || typeof renderer.w !== 'number' || typeof renderer.h !== 'number') {
                                                            console.warn('[WorldWorkerClient] Invalid renderer object');
                                                            return;
                                                        }

                                                        const now = (performance && performance.now) ? performance.now() : Date.now();

                                                        // Watchdog: prevent permanent stall if worker never returns a frame.
                                                        if (this._frameInFlight) {
                                                            if (this._lastFrameSentAt && (now - this._lastFrameSentAt) > 1500) {
                                                                this._frameTimeouts = (this._frameTimeouts | 0) + 1;
                                                                console.warn('[WorldWorkerClient] Frame timeout, resetting inFlight (count=' + this._frameTimeouts + ')');

                                                                this._frameInFlight = false;

                                                                // Too many consecutive timeouts -> disable worker rendering to fall back.
                                                                if (this._frameTimeouts >= 3) {
                                                                    console.warn('[WorldWorkerClient] Too many frame timeouts, disabling worker rendering');
                                                                    this._renderEnabled = false;
                                                                    this._frameTimeouts = 0;
                                                                    return;
                                                                }
                                                            }
                                                            return;
                                                        }

                                                        this._frameInFlight = true;
                                                        this._lastFrameSentAt = now;
                                                        const id = this._frameId++;

                                                        // Use renderer's CSS units & DPR to match its coordinate system.
                                                        const wCss = renderer && renderer.w ? renderer.w : 0;
                                                        const hCss = renderer && renderer.h ? renderer.h : 0;
                                                        const dpr = renderer && renderer.dpr ? renderer.dpr : 1;

                                                        try {
                                                            this.worker.postMessage({
                                                                type: 'render',
                                                                id,
                                                                camX: cam.x,
                                                                camY: cam.y,
                                                                time: time,
                                                                wCss: wCss,
                                                                hCss: hCss,
                                                                dpr: dpr
                                                            });
                                                        } catch (e) {
                                                            // If postMessage fails (e.g., terminated worker), reset flags to avoid perma-stall
                                                            this._frameInFlight = false;
                                                            this._lastFrameSentAt = 0;
                                                            this._frameTimeouts = 0;
                                                            this._renderEnabled = false; // fall back to main-thread renderer
                                                            window.TU_Defensive && window.TU_Defensive.ErrorReporter && window.TU_Defensive.ErrorReporter.report(e, { source: 'WorldWorkerClient.postMessage' });
                                                        }
                                                    }

                                                    consumeBitmap() {
                                                        const bm = this._lastBitmap;
                                                        this._lastBitmap = null;
                                                        return bm;
                                                    }

                                                    notifyTile(x, y, id) {
                                                        if (!this._renderEnabled || !this.worker) return;
                                                        this.worker.postMessage({ type: 'tile', x: x | 0, y: y | 0, id: id | 0 });
                                                    }

                                                    applyDiffMap(diffMap) {
                                                        if (!this._renderEnabled || !this.worker || !diffMap || !diffMap.size) return;

                                                        const n = diffMap.size;
                                                        const triples = new Int32Array(n * 3);
                                                        let i = 0;

                                                        for (const [key, val] of diffMap.entries()) {
                                                            const comma = key.indexOf(',');
                                                            if (comma < 0) continue;
                                                            triples[i++] = (key.slice(0, comma) | 0);
                                                            triples[i++] = (key.slice(comma + 1) | 0);
                                                            triples[i++] = (val | 0);
                                                        }

                                                        // If some entries were skipped due to malformed keys, slice to real size.
                                                        const buf = (i === triples.length) ? triples.buffer : triples.slice(0, i).buffer;
                                                        this.worker.postMessage({ type: 'tileBatch', buf }, [buf]);
                                                    }

                                                    syncLightFull(world) {
                                                        if (!this._renderEnabled || !this.worker || !world || !world.light) return;

                                                        const w = world.w | 0;
                                                        const h = world.h | 0;

                                                        const flat = new Uint8Array(w * h);
                                                        for (let x = 0; x < w; x++) {
                                                            flat.set(world.light[x], x * h);
                                                        }

                                                        const buf = flat.buffer;
                                                        this.worker.postMessage({ type: 'lightFull', w, h, buf }, [buf]);
                                                        this._lightSynced = true;
                                                    }

                                                    syncLightRegion(world, cx, cy, r) {
                                                        if (!this._renderEnabled || !this.worker || !world || !world.light) return;
                                                        if (!this._lightSynced) return; // suppress spam during load; full sync happens after init

                                                        const w = world.w | 0;
                                                        const h = world.h | 0;
                                                        const rr = (r == null) ? 14 : (r | 0);

                                                        const x0 = Math.max(0, (cx | 0) - rr);
                                                        const x1 = Math.min(w - 1, (cx | 0) + rr);
                                                        const y0 = Math.max(0, (cy | 0) - rr);
                                                        const y1 = Math.min(h - 1, (cy | 0) + rr);

                                                        const rw = (x1 - x0 + 1) | 0;
                                                        const rh = (y1 - y0 + 1) | 0;
                                                        if (rw <= 0 || rh <= 0) return;

                                                        const flat = new Uint8Array(rw * rh);
                                                        for (let x = x0; x <= x1; x++) {
                                                            const col = world.light[x];
                                                            const off = (x - x0) * rh;
                                                            for (let y = y0; y <= y1; y++) {
                                                                flat[off + (y - y0)] = col[y] | 0;
                                                            }
                                                        }

                                                        const buf = flat.buffer;
                                                        this.worker.postMessage({ type: 'lightRegion', x0, y0, w: rw, h: rh, buf }, [buf]);
                                                    }

                                                    static _buildWorkerSourceParts() {
                                                        if (WorldWorkerClient.__cachedWorkerParts) return WorldWorkerClient.__cachedWorkerParts;

                                                        // Capture current (possibly patched) generator code.
                                                        const NG = (typeof NoiseGenerator !== 'undefined') ? NoiseGenerator : null;
                                                        const WG = (typeof WorldGenerator !== 'undefined') ? WorldGenerator : null;

                                                        const parts = [];
                                                        const PRE = `'use strict';\n` +
                                                            `const window = self;\n` +
                                                            `let CONFIG=null, BLOCK=null, BLOCK_DATA=null;\n` +
                                                            `let BLOCK_SOLID=null, BLOCK_LIGHT=null, SUN_DECAY=null;\n` +
                                                            `let __STRUCT_JSON='[]';\n` +
                                                            `let __AIR=0;\n` +
                                                            `const Utils = { clamp: (v,a,b) => Math.max(a, Math.min(b, v)) };\n`;
                                                        parts.push(PRE);

                                                        // Minimal TU.Structures for patched structure welding.
                                                        parts.push("self.TU = self.TU || {};\n");
                                                        parts.push("self.TU.Structures = (function(){\n");
                                                        parts.push("  let _loaded = false;\n");
                                                        parts.push("  let _list = [];\n");
                                                        parts.push("  function _normDepth(d){\n");
                                                        parts.push("    if (Array.isArray(d) && d.length>=2) return [+(d[0]||0), +(d[1]||1)];\n");
                                                        parts.push("    return [0,1];\n");
                                                        parts.push("  }\n");
                                                        parts.push("  function _toId(name){\n");
                                                        parts.push("    if (!name) return 0;\n");
                                                        parts.push("    const v = BLOCK && (BLOCK[name] != null) ? BLOCK[name] : 0;\n");
                                                        parts.push("    return v|0;\n");
                                                        parts.push("  }\n");
                                                        parts.push("  function _normalize(raw){\n");
                                                        parts.push("    if (!raw || !Array.isArray(raw.pattern)) return null;\n");
                                                        parts.push("    const grid = raw.pattern.slice();\n");
                                                        parts.push("    const h = grid.length|0;\n");
                                                        parts.push("    let w = 0;\n");
                                                        parts.push("    for (let i=0;i<grid.length;i++){ const row=grid[i]||''; if (row.length>w) w=row.length; }\n");
                                                        parts.push("    const legend = {};\n");
                                                        parts.push("    if (raw.legend){\n");
                                                        parts.push("      for (const ch in raw.legend){\n");
                                                        parts.push("        const r = raw.legend[ch] || {};\n");
                                                        parts.push("        legend[ch] = {\n");
                                                        parts.push("          tile: _toId(r.tile),\n");
                                                        parts.push("          wall: _toId(r.wall),\n");
                                                        parts.push("          replace: r.replace || 'any',\n");
                                                        parts.push("          chance: (r.chance==null?1:+r.chance)\n");
                                                        parts.push("        };\n");
                                                        parts.push("      }\n");
                                                        parts.push("    }\n");
                                                        parts.push("    return {\n");
                                                        parts.push("      id: raw.id || '',\n");
                                                        parts.push("      tags: Array.isArray(raw.tags) ? raw.tags.slice() : [],\n");
                                                        parts.push("      weight: +raw.weight || 1,\n");
                                                        parts.push("      depth: _normDepth(raw.depth),\n");
                                                        parts.push("      anchor: Array.isArray(raw.anchor) ? [raw.anchor[0]|0, raw.anchor[1]|0] : [0,0],\n");
                                                        parts.push("      placement: raw.placement || {},\n");
                                                        parts.push("      grid,\n");
                                                        parts.push("      w,\n");
                                                        parts.push("      h,\n");
                                                        parts.push("      legend,\n");
                                                        parts.push("      connectors: Array.isArray(raw.connectors) ? raw.connectors.map(c=>({x:c.x|0,y:c.y|0,dir:c.dir||'down'})) : []\n");
                                                        parts.push("    };\n");
                                                        parts.push("  }\n");
                                                        parts.push("  function ensureLoaded(){\n");
                                                        parts.push("    if (_loaded) return;\n");
                                                        parts.push("    _loaded = true;\n");
                                                        parts.push("    let raw = [];\n");
                                                        parts.push("    try { raw = JSON.parse(__STRUCT_JSON || '[]'); } catch (_) { raw = []; }\n");
                                                        parts.push("    _list = raw.map(_normalize).filter(Boolean);\n");
                                                        parts.push("  }\n");
                                                        parts.push("  function count(){ ensureLoaded(); return _list.length; }\n");
                                                        parts.push("  function pick(depthN, tags){\n");
                                                        parts.push("    ensureLoaded();\n");
                                                        parts.push("    const tagArr = Array.isArray(tags) ? tags : (tags ? [tags] : []);\n");
                                                        parts.push("    const candidates = [];\n");
                                                        parts.push("    for (let i=0;i<_list.length;i++){\n");
                                                        parts.push("      const d = _list[i];\n");
                                                        parts.push("      if (depthN < d.depth[0] || depthN > d.depth[1]) continue;\n");
                                                        parts.push("      if (tagArr.length){\n");
                                                        parts.push("        let ok=false;\n");
                                                        parts.push("        for (let k=0;k<tagArr.length;k++){ if (d.tags && d.tags.indexOf(tagArr[k])>=0){ ok=true; break; } }\n");
                                                        parts.push("        if (!ok) continue;\n");
                                                        parts.push("      }\n");
                                                        parts.push("      candidates.push(d);\n");
                                                        parts.push("    }\n");
                                                        parts.push("    const pool = candidates.length ? candidates : _list;\n");
                                                        parts.push("    if (!pool.length) return null;\n");
                                                        parts.push("    let sum = 0;\n");
                                                        parts.push("    for (let i=0;i<pool.length;i++) sum += pool[i].weight || 1;\n");
                                                        parts.push("    let r = Math.random() * sum;\n");
                                                        parts.push("    for (let i=0;i<pool.length;i++){ r -= pool[i].weight || 1; if (r<=0) return pool[i]; }\n");
                                                        parts.push("    return pool[pool.length-1];\n");
                                                        parts.push("  }\n");
                                                        parts.push("  return { ensureLoaded, count, pick };\n");
                                                        parts.push("})();\n");

                                                        // Include generator classes.
                                                        if (NG) parts.push(NG.toString(), "\n");
                                                        if (WG) parts.push(WG.toString(), "\n");

                                                        // Re-apply any prototype patches that were applied on the main thread (biomes/structures/etc).
                                                        const patchNames = [
                                                            '_weldStructuresFromLibrary',
                                                            '_carveConnectorTunnel',
                                                            '_biome',
                                                            '_getSurfaceBlock',
                                                            '_getSubSurfaceBlock',

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 18: Game Class (all patches merged)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class Game {
            constructor() {
                this.canvas = document.getElementById('game');
                this.renderer = new Renderer(this.canvas);
                this.particles = new ParticleSystem();
                this.ambientParticles = new AmbientParticles();
                this.droppedItems = new DroppedItemManager(); // æ‰è½ç‰©ç®¡ç†å™¨

                // RAF ä¸»å¾ªç¯ï¼šå¤ç”¨å›è°ƒï¼Œé¿å…æ¯å¸§é—­åŒ…åˆ†é…ï¼›åˆ‡åå°å¯è‡ªåŠ¨åœå¸§çœç”µ
                this._rafCb = this.loop.bind(this);
                this._rafRunning = false;
                this._rafStoppedForHidden = false;

                // è‡ªé€‚åº”æ€§èƒ½ï¼šä½å¸§ç‡è‡ªåŠ¨é™çº§ï¼ˆä¸æ”¹ç©æ³•ï¼Œåªæ”¹ç‰¹æ•ˆ/è¾‰å…‰ï¼‰
                this._perf = {
                    level: 'high', // 'high' | 'low'
                    fps: 60,
                    t0: 0,
                    frames: 0,
                    lowForMs: 0,
                    highForMs: 0
                };

                this.world = null;
                this.player = null;
                this.camera = { x: 0, y: 0 };

                // Camera shake (subtle, for landing feedback)
                this._shakeMs = 0;
                this._shakeTotalMs = 0;
                this._shakeAmp = 0;
                this._shakeX = 0;
                this._shakeY = 0;

                this.input = { left: false, right: false, jump: false, sprint: false, mouseX: 0, mouseY: 0, mouseLeft: false, mouseRight: false };
                this.isMobile = Utils.isMobile();

                // UX+ï¼šåŠ è½½è®¾ç½®å¹¶ç«‹å³åº”ç”¨åˆ°æ–‡æ¡£ï¼ˆå½±å“æ‘‡æ†/æŒ‰é’®å°ºå¯¸ã€å°åœ°å›¾æ˜¾ç¤ºã€å‡å°‘åŠ¨æ€ç­‰ï¼‰
                this.settings = GameSettings.applyToDocument(GameSettings.load());

                // UI Flushï¼šé›†ä¸­ DOM å†™å…¥ï¼ˆé¿å…æ¯å¸§/æ¯å­æ­¥ç›´æ¥å†™ DOMï¼‰
                try {
                    this.uiFlush = UFS ? new UFS() : null;
                } catch (_) { this.uiFlush = null; }

                // Quality/Performance Managerï¼šç»Ÿä¸€ä¸‹å‘ dprCap/ç²’å­ä¸Šé™/å…‰ç…§&å°åœ°å›¾åˆ·æ–°é¢‘ç‡/æ¸²æŸ“ç‰¹æ•ˆå¼€å…³
                try {
                    this.quality = QM ? new QM(this) : null;
                } catch (_) { this.quality = null; }

                this.fpsEl = document.getElementById('fps');
                this.audio = new AudioManager(this.settings);
                this.audio.arm();
                this.saveSystem = new SaveSystem(this);
                this.paused = false;
                this._inputBlocked = false;
                this.seed = null;
                this._lastManualSaveAt = 0;
                // ç³»ç»Ÿåˆ†å±‚ï¼šé›†ä¸­ç®¡ç†å„å­ç³»ç»Ÿï¼Œé™ä½ Game çš„â€œä¸Šå¸å¯¹è±¡â€ä½“ç§¯
                this.services = Object.freeze({
                    input: new InputManager(this),
                    inventory: new InventorySystem(this),
                });

                this.timeOfDay = 0.35;
                this.lastTime = 0;
                this.frameCount = 0;
                this.fps = 60;
                this.lastFpsUpdate = 0;

                // ä¼ å¥‡å²è¯—çº§æ‰‹æ„Ÿä¼˜åŒ–ï¼šå›ºå®šæ—¶é—´æ­¥é•¿ + æ’å€¼æ¸²æŸ“ï¼ˆæ›´ç¨³ã€æ›´è·Ÿæ‰‹ã€æ›´ä¸é£˜ï¼‰
                this._fixedStep = 1000 / 60;      // 16.6667ms
                this._accumulator = 0;
                this._maxSubSteps = 5;            // é˜²æ­¢æç«¯å¸§å¡å¯¼è‡´â€œç‰©ç†èºæ—‹â€
                this._camPrevX = 0;
                this._camPrevY = 0;
                this._renderCamera = { x: 0, y: 0 };
                this._lookAheadX = 0;

                this.ui = null;
                this.minimap = null;
                this.touchController = null;

                this.miningProgress = 0;
                this.miningTarget = null;

                // å…‰ç…§æ‰©æ•£ï¼šå¤ç”¨é˜Ÿåˆ—ä¸ visited æ ‡è®°ï¼Œé¿å… Set+shift å¸¦æ¥çš„å¡é¡¿
                this._lightVisited = null;
                this._lightVisitMark = 1;
                this._lightQx = [];
                this._lightQy = [];
                this._lightQl = [];
                this._lightSrcX = [];
                this._lightSrcY = [];
                this._lightSrcL = [];
                this._latestTouchInput = null;

                // è¿ç»­æ”¾ç½®ä¿æŠ¤ï¼šå›ºå®šæ—¶é—´æ­¥é•¿ä¸‹ï¼Œç§»åŠ¨ç«¯é•¿æŒ‰å¯èƒ½åœ¨åŒä¸€å¸§å†…è§¦å‘å¤šæ¬¡æ”¾ç½®ï¼Œå¯¼è‡´å¡é¡¿/å¡æ­»
                // æ–¹æ¡ˆï¼šæ”¾ç½®åŠ¨ä½œèŠ‚æµ + å°†æ˜‚è´µçš„å…‰ç…§/å°åœ°å›¾/UI æ›´æ–°åˆå¹¶ä¸ºâ€œæ¯å¸§æœ€å¤šä¸€æ¬¡â€
                this._nextPlaceAt = 0;
                this._placeIntervalMs = (this.settings && this.settings.placeIntervalMs) ? this.settings.placeIntervalMs : 80; // é»˜è®¤çº¦ 12.5 æ¬¡/ç§’
                this._deferred = { light: [], hotbar: false, minimap: false };

                // Quality/Performance Manager ä¸‹å‘ï¼šæ˜‚è´µç³»ç»Ÿçš„åˆ·æ–°é¢‘ç‡
                this._lightIntervalMs = 0;        // å…‰ç…§åˆ·æ–°èŠ‚æµï¼ˆ0=ä¸èŠ‚æµï¼‰
                this._lastLightUpdateAt = 0;

                // åˆ‡æ¢æ ‡ç­¾é¡µ/é”å±ï¼šé‡ç½®è®¡æ—¶å™¨ï¼Œé¿å…å›åˆ°é¡µé¢æ—¶â€œç¬ç§»/æ‰å¸§æŠ–åŠ¨â€
                this._wasHidden = false;
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this._wasHidden = true;
                        this._stopRafForHidden();
                        if (this.quality && typeof this.quality.onVisibilityChange === 'function') this.quality.onVisibilityChange(true);
                    } else {
                        if (this.quality && typeof this.quality.onVisibilityChange === 'function') this.quality.onVisibilityChange(false);
                        // å›åˆ°å‰å°ï¼šé‡ç½®è®¡æ—¶å™¨ï¼Œé¿å…è¶…å¤§ dtï¼›å¦‚ä¹‹å‰åœå¸§åˆ™æ¢å¤
                        this.lastTime = performance.now();
                        this._accumulator = 0;
                        this._wasHidden = false;
                        this._resumeRafIfNeeded();
                    }
                }, { passive: true });

                this._bindEvents();
            }

            addCameraShake(amp = 1.5, ms = 100) {
                // Respect reduced motion; also keep it subtle
                try {
                    if (this.settings && this.settings.reducedMotion) return;
                } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                const a = Math.max(0, +amp || 0);
                const d = Math.max(0, +ms || 0);
                if (d <= 0 || a <= 0) return;

                // Stack by taking the stronger/longer
                this._shakeAmp = Math.max(this._shakeAmp || 0, a);
                this._shakeMs = Math.max(this._shakeMs || 0, d);
                this._shakeTotalMs = Math.max(this._shakeTotalMs || 0, this._shakeMs);
            }

            _tickCameraShake(dtClamped) {
                if (!this._shakeMs || this._shakeMs <= 0) {
                    this._shakeMs = 0;
                    this._shakeTotalMs = 0;
                    this._shakeAmp = 0;
                    this._shakeX = 0;
                    this._shakeY = 0;
                    return;
                }

                this._shakeMs = Math.max(0, this._shakeMs - dtClamped);
                const total = Math.max(1, this._shakeTotalMs || 1);
                const t = this._shakeMs / total; // 1 -> 0
                const strength = (this._shakeAmp || 0) * t;

                // Light, slightly vertical-biased shake
                this._shakeX = (Math.random() * 2 - 1) * strength;
                this._shakeY = (Math.random() * 2 - 1) * strength * 0.65;
            }

            async init() {
                const loadProgress = DOM.byId(UI_IDS.loadProgress);
                const loadStatus = DOM.byId(UI_IDS.loadStatus);

                // UX+ï¼šå­˜æ¡£é€‰æ‹©ï¼ˆè‹¥å­˜åœ¨åˆ™å…è®¸ç»§ç»­ï¼‰
                const start = await SaveSystem.promptStartIfNeeded();
                const save = (start && start.mode === 'continue') ? start.save : null;
                if (start && start.mode === 'new') {
                    // æ–°ä¸–ç•Œä¼šè¦†ç›–æ—§è¿›åº¦
                    SaveSystem.clear();
                }

                const seed = (save && Number.isFinite(save.seed)) ? save.seed : Date.now();
                this.seed = seed;
                this.saveSystem.seed = seed;

                const gen = new WorldGenerator(CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT, seed);
                const data = await gen.generate((s, p) => {
                    loadStatus.textContent = s;
                    loadProgress.style.width = p + '%';
                });

                this.world = data;

                // å¦‚æœæœ‰å­˜æ¡£ï¼šåº”ç”¨ä¸–ç•Œå·®å¼‚ä¸ç©å®¶çŠ¶æ€
                if (save) {
                    this.saveSystem.importLoaded(save);
                    this.saveSystem.applyToWorld(this.world, save);
                    // è½»é‡åˆ·æ–°å…‰ç…§/å°åœ°å›¾ï¼ˆé¿å…å…¨é‡é‡ç®—ï¼‰
                    try {
                        let c = 0;
                        for (const k of (save._diffMap ? save._diffMap.keys() : [])) {
                            const [x, y] = k.split(',').map(n => parseInt(n, 10));
                            if (Number.isFinite(x) && Number.isFinite(y)) this._updateLight(x, y);
                            if (++c > 4000) break; // é˜²æ­¢æç«¯æƒ…å†µä¸‹å¡é¡¿
                        }
                        this.minimap && this.minimap.invalidate();
                    } catch { }

                    if (typeof save.timeOfDay === 'number' && isFinite(save.timeOfDay)) {
                        this.timeOfDay = save.timeOfDay;
                    }
                    Toast.show('ğŸ—‚ å·²è¯»å–å­˜æ¡£', 1400);
                }

                const spawnX = Math.floor(CONFIG.WORLD_WIDTH / 2);
                let spawnY = 0;
                for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                    if (this.world.tiles[spawnX][y] !== BLOCK.AIR) { spawnY = y - 3; break; }
                }

                this.player = new Player(spawnX * CONFIG.TILE_SIZE, spawnY * CONFIG.TILE_SIZE);
                this.ui = new UIManager(this.player, this.renderer.textures, this.uiFlush);
                this.crafting = new CraftingSystem(this);
                this.inventoryUI = new InventoryUI(this);
                this.minimap = new Minimap(this.world);
                if (this.quality && typeof this.quality.onSettingsChanged === 'function') this.quality.onSettingsChanged();

                // å­˜æ¡£ï¼šæ¢å¤ç©å®¶å±æ€§ä¸èƒŒåŒ…
                if (save) {
                    this.saveSystem.applyToPlayer(this.player, this.ui, save);
                }

                // è®¾å¤‡æç¤ºæ–‡æ¡ˆ
                applyInfoHintText(this.isMobile);

                // ç»‘å®š UX+ æŒ‰é’®ï¼ˆæš‚åœ/è®¾ç½®/ä¿å­˜ç­‰ï¼‰
                wireUXUI(this);

                if (this.isMobile) {
                    this.touchController = new TouchController(this);
                }

                // èµ„æºé¢„çƒ­ï¼šå¼ºåˆ¶ç”Ÿæˆå¸¸ç”¨çº¹ç†/è¾‰å…‰ï¼Œé¿å…å¼€å±€ç¬é—´å¡é¡¿æˆ–é—ªçƒ
                try {
                    const warmTex = this.renderer && this.renderer.textures;
                    if (warmTex && warmTex.get) {
                        const ids = Object.keys(BLOCK_DATA).map(Number).filter(n => Number.isFinite(n));
                        const total = ids.length || 1;

                        for (let i = 0; i < ids.length; i++) {
                            const id = ids[i];
                            warmTex.get(id);
                            if (this.renderer.enableGlow && warmTex.getGlow && BLOCK_LIGHT[id] > 5) warmTex.getGlow(id);

                            // è®©å‡ºä¸»çº¿ç¨‹ï¼šé¿å…å¡æ­» loading åŠ¨ç”»
                            if ((i % 18) === 0) {
                                const p = Math.round((i / total) * 100);
                                loadProgress.style.width = p + '%';
                                loadStatus.textContent = 'ğŸ¨ é¢„çƒ­çº¹ç† ' + p + '%';
                                await new Promise(r => setTimeout(r, 0));
                            }
                        }

                        loadProgress.style.width = '100%';
                        loadStatus.textContent = 'âœ… çº¹ç†å°±ç»ª';
                    }

                    // å¼ºåˆ¶åˆå§‹åŒ–ç©å®¶ç¼“å­˜ï¼ˆé¿å…é¦–å¸§é—ªçƒï¼‰
                    if (Player && Player._initSpriteCache) Player._initSpriteCache();
                } catch (e) {
                    console.warn('prewarm failed', e);
                }

                // æ·¡å‡ºåŠ è½½ç•Œé¢
                const loading = DOM.byId(UI_IDS.loading);
                loading.style.transition = 'opacity 0.5s';
                loading.style.opacity = '0';
                setTimeout(() => loading.style.display = 'none', 500);

                this._startRaf();
            }

            _bindEvents() {
                // åˆ†å±‚ï¼šè¾“å…¥ç»‘å®šå§”æ‰˜ç»™ InputManagerï¼ˆè¡Œä¸ºä¸å˜ï¼‰
                this.services.input.bind();
            }

            _setQuality(level) {
                if (this._perf.level === level) return;
                this._perf.level = level;

                // ä½æ¡£æ—¶åŒæ­¥ç»™ CSSï¼ˆUI ä¹Ÿå¯é™çº§ç‰¹æ•ˆï¼‰ï¼šä¸ QualityManager.apply çš„ tu-low-power äº’è¡¥
                try {
                    if (typeof document !== 'undefined' && document.documentElement) {
                        document.documentElement.classList.toggle('tu-quality-low', level === 'low');
                    }
                } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }
                // ç²’å­æ•°é‡ï¼šä½æ¡£å‡å°‘ä¸Šé™ï¼Œæ˜¾è‘—é™ä½ GC ä¸ draw calls
                if (this.particles) this.particles.max = (level === 'low') ? 220 : 400;

                // å‘å…‰æ–¹å—é˜´å½±è¾‰å…‰ï¼šä½æ¡£å…³é—­ shadowBlurï¼ˆé€šå¸¸æ˜¯æœ€åƒæ€§èƒ½çš„ 2D ç‰¹æ•ˆä¹‹ä¸€ï¼‰
                if (this.renderer) this.renderer.enableGlow = (level !== 'low');

                // åŠ¨æ€åˆ†è¾¨ç‡ï¼šä½æ¡£ç•¥é™æ¸²æŸ“åˆ†è¾¨ç‡ï¼Œèƒ½æ˜¾è‘—æå‡å¸§ç‡ä¸”è§†è§‰å‡ ä¹æ— æŸ
                if (this.renderer && this.renderer.setResolutionScale) {
                    this.renderer.lowPower = (level === 'low');
                    this.renderer.setResolutionScale(level === 'low' ? 0.85 : 1);
                }

                // å¤œé—´è¤ç«è™«ï¼šä½æ¡£é™ä½æ•°é‡ï¼ˆä¸å½»åº•å…³é—­ï¼Œä¿ç•™æ°›å›´ï¼‰
                if (this.ambientParticles && this.ambientParticles.container) {
                    this.ambientParticles.container.style.opacity = (level === 'low') ? '0.7' : '1';
                }

                // åé¦ˆæç¤ºï¼ˆä¸æ‰“æ‰°ï¼Œ1 ç§’æ¶ˆå¤±ï¼‰
                try { Toast.show(level === 'low' ? 'âš¡ å·²è‡ªåŠ¨é™ä½ç‰¹æ•ˆä»¥ä¿æŒæµç•…' : 'âœ¨ å·²æ¢å¤é«˜ç‰¹æ•ˆ', 1000); } catch { }
            }

            _haptic(ms) {
                if (!this.isMobile) return;
                if (!this.settings || this.settings.vibration === false) return;
                try { if (navigator.vibrate) navigator.vibrate(ms); } catch { }
            }

            _perfTick(dtClamped) {
                // æ¯å¸§ç»Ÿè®¡ï¼Œ0.5 ç§’åˆ·æ–°ä¸€æ¬¡ fps
                const p = this._perf;
                p.frames++;

                const now = this.lastTime; // loop å†…å·²æ›´æ–° lastTime
                if (!p.t0) p.t0 = now;

                const span = now - p.t0;
                if (span < 500) return;

                const fps = (p.frames * 1000) / span;
                p.fps = fps;
                p.frames = 0;
                p.t0 = now;

                // è¿ç»­ä½äºé˜ˆå€¼ 2 ç§’ï¼šé™çº§ï¼›è¿ç»­é«˜äºé˜ˆå€¼ 3 ç§’ï¼šæ¢å¤
                if (fps < 45) {
                    p.lowForMs += span;
                    p.highForMs = 0;
                } else if (fps > 56) {
                    p.highForMs += span;
                    p.lowForMs = 0;
                } else {
                    // ä¸­é—´åŒºé—´ï¼šä¸ç´¯è®¡
                    p.lowForMs = Math.max(0, p.lowForMs - span * 0.5);
                    p.highForMs = Math.max(0, p.highForMs - span * 0.5);
                }

                const autoQ = (!this.settings) || (this.settings.autoQuality !== false);
                // åŠ¨æ€åˆ†è¾¨ç‡å¾®è°ƒï¼ˆAutoQuality ä¸‹å¯ç”¨ï¼‰ï¼šç”¨â€œæ›´å¹³æ»‘â€çš„æ–¹å¼ç¨³ä½å¸§ç‡ï¼Œé¿å…ä¸€åˆ€åˆ‡æŠ–åŠ¨
                // æ³¨æ„ï¼šåªåœ¨ 0.5s çš„ç»Ÿè®¡çª—å£å†…è°ƒæ•´ä¸€æ¬¡ï¼Œä¸ä¼šé€ æˆé¢‘ç¹ resize
                if (autoQ && this.renderer && this.renderer.setResolutionScale) {
                    const f = fps;
                    let target = 1;
                    if (f < 35) target = 0.72;
                    else if (f < 45) target = 0.72 + (f - 35) * (0.13 / 10); // 0.72 -> 0.85
                    else if (f < 58) target = 0.85 + (f - 45) * (0.15 / 13); // 0.85 -> 1.00
                    else target = 1;

                    // å·²å¤„äº low æ¡£æ—¶ï¼Œç•¥é™ä½ä¸Šé™ä»¥è¿›ä¸€æ­¥çœç”µï¼ˆä¸å½±å“ç©æ³•ï¼‰
                    if (p.level === 'low') target = Math.min(target, 0.90);

                    const cur = (typeof this.renderer.resolutionScale === 'number') ? this.renderer.resolutionScale : 1;
                    const next = cur + (target - cur) * 0.35;
                    this.renderer.setResolutionScale(next);
                }

                if (autoQ) {
                    if (p.level === 'high' && p.lowForMs >= 2000) this._setQuality('low');
                    if (p.level === 'low' && p.highForMs >= 3000) this._setQuality('high');
                } else {
                    // æ‰‹åŠ¨æ¨¡å¼ï¼šä¸åšè‡ªåŠ¨åˆ‡æ¢ï¼Œé¿å…æ¥å›æŠ–åŠ¨
                    p.lowForMs = 0;
                    p.highForMs = 0;
                }
            }

            _startRaf() {
                if (this._rafRunning) return;
                this._rafRunning = true;
                if (this._rafRunning) requestAnimationFrame(this._rafCb);
            }

            _stopRafForHidden() {
                this._rafRunning = false;
                this._rafStoppedForHidden = true;
            }

            _resumeRafIfNeeded() {
                if (this._rafRunning) return;
                if (!this._rafStoppedForHidden) return;
                if (document.hidden) return;
                this._rafStoppedForHidden = false;
                // é¿å…åˆ‡å›å‰å°äº§ç”Ÿè¶…å¤§ dt
                this.lastTime = 0;
                this._accumulator = 0;
                this._startRaf();
            }

            loop(timestamp) {
                // å…è®¸å¤–éƒ¨æ˜¾å¼åœå¸§ï¼ˆä¾‹å¦‚é”™è¯¯å…œåº•å±‚/æ‰‹åŠ¨æš‚åœæ¸²æŸ“ï¼‰
                if (!this._rafRunning) return;

                // åˆ‡åå°ï¼šåœå¸§çœç”µï¼ˆä¸å†ç»§ç»­æ’é˜Ÿ RAFï¼‰
                if (document.hidden) {
                    this._stopRafForHidden();
                    return;
                }

                // å›ºå®šæ—¶é—´æ­¥é•¿ï¼šç‰©ç†/æ‰‹æ„Ÿä¸å†éš FPS æµ®åŠ¨ï¼›æ¸²æŸ“ç”¨æ’å€¼ä¿è¯é¡ºæ»‘
                if (!this.lastTime) this.lastTime = timestamp;

                let dtRaw = timestamp - this.lastTime;
                if (dtRaw < 0) dtRaw = 0;
                // é˜²æ­¢åˆ‡å›æ ‡ç­¾é¡µ/å¡é¡¿é€ æˆâ€œç‰©ç†èºæ—‹â€
                if (dtRaw > 250) dtRaw = 250;
                this.lastTime = timestamp;

                this.frameCount++;
                if (timestamp - this.lastFpsUpdate > 500) {
                    const span = (timestamp - this.lastFpsUpdate) || 1;
                    this.fps = Math.round(this.frameCount * 1000 / span);
                    this.frameCount = 0;
                    this.lastFpsUpdate = timestamp;
                    if (this.fpsEl && this.settings && this.settings.showFps) {
                        const el = this.fpsEl;
                        const v = this.fps + ' FPS';
                        if (this.uiFlush && typeof this.uiFlush.enqueue === 'function') {
                            this.uiFlush.enqueue('hud:fps', () => { if (el) el.textContent = v; });
                        } else {
                            el.textContent = v;
                        }
                    }
                    if (this.quality) this.quality.onFpsSample(this.fps, span);
                }

                const step = this._fixedStep || 16.6667;
                this._accumulator = (this._accumulator || 0) + dtRaw;

                let subSteps = 0;
                if (!this.paused) {
                    while (this._accumulator >= step && subSteps < (this._maxSubSteps || 5)) {
                        this._camPrevX = this.camera.x;
                        this._camPrevY = this.camera.y;
                        this.update(step);
                        this._accumulator -= step;
                        subSteps++;
                    }
                    if (subSteps === 0) { // æ²¡æœ‰æ¨è¿›é€»è¾‘å¸§æ—¶ï¼Œæ’å€¼åŸºå‡†=å½“å‰ç›¸æœº
                        this._camPrevX = this.camera.x;
                        this._camPrevY = this.camera.y;
                    }
                    // ä»æœªè¿½ä¸Šï¼šä¸¢å¼ƒä½™é‡ï¼Œé¿å…è¶Šç§¯è¶Šå¤š
                    if (subSteps === (this._maxSubSteps || 5)) this._accumulator = 0;
                } else {
                    // æš‚åœæ—¶ä¿æŒæ¸²æŸ“ï¼ˆç”»é¢ä¸é»‘å±ï¼‰ï¼Œä½†ä¸æ¨è¿›ç‰©ç†/æ—¶é—´
                    this._accumulator = 0;
                    if (this.ui) { this.ui.updateStats(); this.ui.updateTime(this.timeOfDay); }
                    this._camPrevX = this.camera.x;
                    this._camPrevY = this.camera.y;
                }

                // åˆå¹¶å¤„ç†äº¤äº’å¼•èµ·çš„æ˜‚è´µæ›´æ–°ï¼ˆå…‰ç…§/å°åœ°å›¾/å¿«æ·æ ï¼‰ï¼Œæ¯å¸§æœ€å¤šä¸€æ¬¡
                this._flushDeferredWork();

                // æ’å€¼ç›¸æœºï¼ˆé¿å…ä½å¸§/æŠ–åŠ¨æ—¶ç”»é¢â€œè·³æ ¼â€ï¼‰
                const alpha = step > 0 ? (this._accumulator / step) : 0;
                const rc = this._renderCamera || (this._renderCamera = { x: this.camera.x, y: this.camera.y });
                rc.x = this._camPrevX + (this.camera.x - this._camPrevX) * alpha;
                rc.y = this._camPrevY + (this.camera.y - this._camPrevY) * alpha;

                // Apply subtle camera shake (render-time interpolation + shake offset)
                if (this._shakeMs > 0) {
                    rc.x += this._shakeX || 0;
                    rc.y += this._shakeY || 0;
                }

                this.render();

                // UI flush é˜¶æ®µï¼šç»Ÿä¸€å†™å…¥ HUD/Overlay DOM
                if (this.uiFlush) this.uiFlush.flush();

                if (this._rafRunning) requestAnimationFrame(this._rafCb);
            }

            update(dt) {
                const dtClamped = Math.min(dt, 50);
                const dtScale = dtClamped / 16.6667;

                // camera shake (updated in fixed-step)
                this._tickCameraShake(dtClamped);

                // Keyboard: compute hold-to-sprint in fixed-step (stable, no jitter)
                const _im = (this.services && this.services.input) ? this.services.input : null;
                if (_im && typeof _im.tick === 'function') _im.tick(dtClamped);

                let input = this.input;

                // ç§»åŠ¨ç«¯ï¼šTouchController.getInput() å·²æ”¹ä¸ºå¤ç”¨å¯¹è±¡ï¼Œè¿™é‡Œå†å¤ç”¨ mergedInputï¼Œé¿å…æ¯å¸§åˆ†é…æ–°å¯¹è±¡
                if (this.isMobile && this.touchController) {
                    const ti = this.touchController.getInput();
                    this._latestTouchInput = ti;

                    const mi = this._mergedInput || (this._mergedInput = {
                        left: false, right: false, jump: false, sprint: false,
                        mouseX: 0, mouseY: 0, mouseLeft: false, mouseRight: false
                    });

                    mi.left = ti.left;
                    mi.right = ti.right;
                    mi.jump = ti.jump;
                    mi.sprint = ti.sprint;
                    mi.mouseLeft = ti.mine;
                    mi.mouseRight = ti.place;

                    if (ti.hasTarget) {
                        mi.mouseX = ti.targetX;
                        mi.mouseY = ti.targetY;
                    } else {
                        // æ— ç›®æ ‡æ—¶ï¼šé»˜è®¤ç„å‡†ç©å®¶ï¼ˆè½¬æ¢ä¸ºå±å¹•åæ ‡ï¼‰
                        mi.mouseX = this.player.cx() - this.camera.x;
                        mi.mouseY = this.player.cy() - this.camera.y;
                    }

                    input = mi;
                } else {
                    this._latestTouchInput = null;

                    // Desktop: merge shift-sprint + hold-to-sprint (A/D hold) into a stable input object
                    const ki = this._kbInput || (this._kbInput = {
                        left: false, right: false, jump: false, sprint: false,
                        mouseX: 0, mouseY: 0, mouseLeft: false, mouseRight: false
                    });

                    ki.left = this.input.left;
                    ki.right = this.input.right;
                    ki.jump = this.input.jump;
                    ki.mouseX = this.input.mouseX;
                    ki.mouseY = this.input.mouseY;
                    ki.mouseLeft = this.input.mouseLeft;
                    ki.mouseRight = this.input.mouseRight;

                    ki.sprint = !!(this.input.sprint || (_im && _im._holdSprint));

                    input = ki;
                }

                this.player.update(input, this.world, dtClamped);

                // Sprint speed feel: drive a subtle motion-blur intensity for PostFX
                try {
                    const r = this.renderer;
                    if (r) {
                        const base = CONFIG.PLAYER_SPEED;
                        const max = CONFIG.PLAYER_SPEED * CONFIG.SPRINT_MULT;
                        const vx = Math.abs(this.player.vx || 0);

                        let target = 0;
                        if (this.player && this.player._sprintActive) {
                            const denom = Math.max(0.001, (max - base * 0.8));
                            target = Utils.clamp((vx - base * 0.8) / denom, 0, 1);

                            // Extra punch right after sprint starts
                            if (this.player && this.player._sprintVfxMs > 0) target = Math.max(target, 0.85);
                        }

                        const cur = (typeof r._speedBlurAmt === 'number') ? r._speedBlurAmt : 0;
                        const smooth = 1 - Math.pow(1 - 0.22, dtScale); // fast response, still smooth
                        r._speedBlurAmt = cur + (target - cur) * smooth;
                        r._speedBlurDirX = (this.player.vx >= 0) ? 1 : -1;
                    }
                } catch (e) { if (typeof console !== 'undefined' && console.debug) console.debug('[Debug] Silently caught:', e); }

                // é•œå¤´å‰ç»ï¼šå¥”è·‘æ–¹å‘æ›´â€œçœ‹å¾—è§å‰æ–¹â€ï¼Œæ‰“æ€ª/æŒ–æ˜æ›´èˆ’æœï¼ˆå¸¦å¹³æ»‘ï¼Œä¸å¡é¡¿ï¼‰
                const lookStrength = (this.settings && typeof this.settings.lookAhead === 'number') ? this.settings.lookAhead : 1.0;
                const desiredLook = Utils.clamp(this.player.vx * 22 * lookStrength, -220 * lookStrength, 220 * lookStrength);
                const lookSmooth = 1 - Math.pow(1 - 0.12, dtScale);
                this._lookAheadX = (this._lookAheadX || 0) + (desiredLook - (this._lookAheadX || 0)) * lookSmooth;

                const targetX = this.player.cx() - this.renderer.w / 2 + this._lookAheadX;
                const targetY = this.player.cy() - this.renderer.h / 2;
                const maxX = this.world.w * CONFIG.TILE_SIZE - this.renderer.w;
                const maxY = this.world.h * CONFIG.TILE_SIZE - this.renderer.h;

                const baseCam = (this.settings && typeof this.settings.cameraSmooth === 'number') ? this.settings.cameraSmooth : 0.08;
                const camSmooth = 1 - Math.pow(1 - baseCam, dtScale);
                this.camera.x += (Utils.clamp(targetX, 0, maxX) - this.camera.x) * camSmooth;
                this.camera.y += (Utils.clamp(targetY, 0, maxY) - this.camera.y) * camSmooth;

                this._handleInteraction(input, dtScale);
                if (this.settings.particles) this.particles.update(dtScale);
                if (this._updateWeather) this._updateWeather(dtClamped);
                if (this.settings.ambient) this.ambientParticles.update(this.timeOfDay, this.weather);
                // æ›´æ–°æ‰è½ç‰©
                this.droppedItems.update(this.world, this.player, dt, (blockId, count) => {
                    const success = this._addToInventory(blockId, count);
                    if (success) {
                        // æ‹¾å–æˆåŠŸ
                        this.audio && this.audio.play('pickup');
                        // å‘å°„ç²’å­æ•ˆæœï¼ˆæŸ¥è¡¨é¿å…å¯¹è±¡æŸ¥æ‰¾ï¼‰
                        const col = BLOCK_COLOR[blockId] || '#ffeaa7';
                        this.particles.emit(this.player.cx(), this.player.cy() - 10, {
                            color: col,
                            count: 8,
                            speed: 2,
                            size: 3,
                            up: true,
                            gravity: 0.05,
                            glow: true
                        });
                    }
                    return success;
                });

                this.timeOfDay += dtClamped / CONFIG.DAY_LENGTH;
                if (this.timeOfDay >= 1) this.timeOfDay = 0;
                this.saveSystem.tickAutosave(dtClamped);

                this.ui.updateStats();
                this.ui.updateTime(this.timeOfDay);
            }

            _handleInteraction(input, dtScale = 1) {
                if (this._inputBlocked) {
                    this.miningProgress = 0;
                    this.miningTarget = null;
                    this.ui.hideMining();
                    return;
                }
                const worldX = input.mouseX + this.camera.x;
                const worldY = input.mouseY + this.camera.y;

                const ts = CONFIG.TILE_SIZE;
                let tileX = Math.floor(worldX / ts);
                let tileY = Math.floor(worldY / ts);
                if (this.isMobile && this.settings && this.settings.aimAssist) {
                    tileX = Math.floor((worldX + ts * 0.5) / ts);
                    tileY = Math.floor((worldY + ts * 0.5) / ts);
                }

                const dx = worldX - this.player.cx();
                const dy = worldY - this.player.cy();
                const reachPx = CONFIG.REACH_DISTANCE * CONFIG.TILE_SIZE;
                const inRange = (dx * dx + dy * dy) <= (reachPx * reachPx);

                if (tileX < 0 || tileX >= this.world.w || tileY < 0 || tileY >= this.world.h) { this.miningProgress = 0; this.miningTarget = null; this.ui && this.ui.hideMining && this.ui.hideMining(); return; }

                const item = this.player.getItem();
                const block = this.world.tiles[tileX][tileY];

                if (input.mouseLeft && inRange) {
                    if (block !== BLOCK.AIR && block !== BLOCK.BEDROCK) {
                        const hardness = BLOCK_HARDNESS[block];
                        const color = BLOCK_COLOR[block] || '#fff';
                        const glow = BLOCK_LIGHT[block] > 0;
                        const speed = (item && item.id === 'pickaxe' && typeof item.speed === 'number') ? item.speed : 0.4;

                        if (!this.miningTarget || this.miningTarget.x !== tileX || this.miningTarget.y !== tileY) {
                            this.miningTarget = { x: tileX, y: tileY };
                            this.miningProgress = 0;
                        }

                        this.miningProgress += speed * 0.02 * dtScale;

                        if (Math.random() < Math.min(1, 0.3 * dtScale)) {
                            this.particles.emit(tileX * CONFIG.TILE_SIZE + 8, tileY * CONFIG.TILE_SIZE + 8, {
                                color: color, count: 3, speed: 2.5, glow: glow
                            });
                        }

                        this.ui.showMining(
                            tileX * CONFIG.TILE_SIZE - this.camera.x + CONFIG.TILE_SIZE / 2,
                            tileY * CONFIG.TILE_SIZE - this.camera.y,
                            Math.min(1, this.miningProgress / hardness),
                            block
                        );

                        if (this.miningProgress >= hardness) {
                            // æŒ–æ˜æˆåŠŸï¼Œç”Ÿæˆæ‰è½ç‰©
                            const dropX = tileX * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - 6;
                            const dropY = tileY * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - 6;
                            if (block === BLOCK.TREASURE_CHEST && this._spawnTreasureChestLoot) {
                                this._spawnTreasureChestLoot(tileX, tileY, dropX, dropY);
                            } else {
                                this.droppedItems.spawn(dropX, dropY, block, 1);
                            }

                            this.world.tiles[tileX][tileY] = BLOCK.AIR;
                            this.saveSystem && this.saveSystem.markTile(tileX, tileY, BLOCK.AIR);
                            const hd = (BLOCK_DATA[block] && BLOCK_DATA[block].hardness) ? BLOCK_DATA[block].hardness : 1;
                            const vib = (hd <= 1) ? 5 : (hd <= 2) ? 12 : (hd <= 3) ? 20 : Math.min(35, Math.round(20 + (hd - 3) * 4));
                            this._haptic(vib);
                            this.audio && this.audio.play('mine');
                            this.particles.emit(tileX * CONFIG.TILE_SIZE + 8, tileY * CONFIG.TILE_SIZE + 8, {
                                color: color, count: 10, speed: 4, glow: glow
                            });
                            this.miningProgress = 0;
                            this.miningTarget = null;
                            this.ui.hideMining();
                            this._deferLightUpdate(tileX, tileY);
                            this._deferMinimapUpdate();
                        }
                    }
                } else {
                    this.miningProgress = 0;
                    this.miningTarget = null;
                    this.ui.hideMining();
                }

                if (input.mouseRight && inRange && !input.mouseLeft) {
                    const nowMs = performance.now();
                    const placeInterval = (this._perf && this._perf.level === 'low') ? (this._placeIntervalMs + 30) : this._placeIntervalMs;
                    if (nowMs >= (this._nextPlaceAt || 0) && item && typeof item.id === 'number' && typeof item.count === 'number' && item.count > 0 && item.id !== BLOCK.AIR) {
                        if (block === BLOCK.AIR || BLOCK_LIQUID[block]) {
                            const ts = CONFIG.TILE_SIZE;
                            const br = { x: tileX * ts, y: tileY * ts, w: ts, h: ts };
                            const pr = { x: this.player.x, y: this.player.y, w: this.player.w, h: this.player.h };

                            const collides = !(br.x + br.w < pr.x || br.x > pr.x + pr.w || br.y + br.h < pr.y || br.y > pr.y + pr.h);

                            if (!collides || item.id === BLOCK.TORCH) {
                                this.world.tiles[tileX][tileY] = item.id;
                                this._nextPlaceAt = nowMs + placeInterval;
                                this.saveSystem && this.saveSystem.markTile(tileX, tileY, item.id);
                                this._haptic(6);
                                this.audio && this.audio.play('place');

                                // æ¶ˆè€—ç‰©å“
                                item.count--;
                                if (item.count <= 0) {
                                    // ç‰©å“ç”¨å®Œï¼Œä»åº“å­˜ä¸­ç§»é™¤æˆ–è®¾ä¸ºç©º
                                    item.count = 0;
                                }

                                this.particles.emit(tileX * ts + 8, tileY * ts + 8, {
                                    color: BLOCK_COLOR[item.id] || '#fff', count: 5, speed: 2, up: true
                                });
                                this._deferLightUpdate(tileX, tileY);
                                this._deferMinimapUpdate();

                                // æ›´æ–°å¿«æ·æ UIæ˜¾ç¤ºï¼ˆåˆå¹¶åˆ°æ¯å¸§æœ€å¤šä¸€æ¬¡ï¼‰
                                this._deferHotbarUpdate();
                            }
                        }
                    }
                }
            }

            _deferLightUpdate(x, y) {
                const d = this._deferred;
                if (!d) return;
                d.light.push({x, y});
            }
            _deferHotbarUpdate() {
                const d = this._deferred;
                if (!d) return;
                d.hotbar = true;
            }
            _deferMinimapUpdate() {
                const d = this._deferred;
                if (!d) return;
                d.minimap = true;
            }
            _flushDeferredWork() {
                const d = this._deferred;
                if (!d) return;

                // å…‰ç…§æœ€é‡ï¼šä¼˜å…ˆåˆå¹¶ï¼Œä¸”æ¯å¸§æœ€å¤šä¸€æ¬¡
                if (d.light.length > 0) {
                    const interval = (typeof this._lightIntervalMs === 'number' && isFinite(this._lightIntervalMs)) ? this._lightIntervalMs : 0;
                    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

                    if (!interval || !this._lastLightUpdateAt || (now - this._lastLightUpdateAt) >= interval) {
                        const targets = d.light;
                        d.light = [];
                        this._lastLightUpdateAt = now;
                        // åˆå¹¶æ›´æ–°ï¼šå¦‚æœæ›´æ–°ç‚¹å¾ˆè¿‘ï¼Œå…¶å®å¯ä»¥ä¼˜åŒ–ï¼Œè¿™é‡Œç®€å•éå†
                        for(const target of targets) {
                            this._updateLight(target.x, target.y);
                        }
                    }
                }
                if (d.minimap) {
                    d.minimap = false;
                    this.minimap && this.minimap.invalidate();
                }
                if (d.hotbar) {
                    d.hotbar = false;
                    this.ui && this.ui.buildHotbar();
                }
            }

            _updateLight(x, y) {
                const r = 14;
                const w = this.world.w, h = this.world.h;
                const tiles = this.world.tiles;
                const light = this.world.light;

                let startX = x - r, endX = x + r;
                let startY = y - r, endY = y + r;

                if (startX < 0) startX = 0;
                if (startY < 0) startY = 0;
                if (endX >= w) endX = w - 1;
                if (endY >= h) endY = h - 1;

                // æ”¶é›†å…‰æºï¼ˆä¿æŒåŸæ‰«æé¡ºåºï¼šx å¤–å±‚ã€y å†…å±‚é€’å¢ï¼‰
                const srcX = this._lightSrcX;
                const srcY = this._lightSrcY;
                const srcL = this._lightSrcL;
                srcX.length = 0;
                srcY.length = 0;
                srcL.length = 0;

                // å¤ªé˜³å…‰ï¼šå¯¹æ¯åˆ—åªæ‰«ä¸€æ¬¡ï¼ˆåŸå®ç°ä¸ºæ¯æ ¼ä»é¡¶éƒ¨é‡æ‰«ï¼Œå¤æ‚åº¦é«˜ï¼‰
                const maxScanY = endY;
                const maxSun = CONFIG.LIGHT_LEVELS;

                for (let tx = startX; tx <= endX; tx++) {
                    let sun = maxSun;
                    const colTiles = tiles[tx];
                    const colLight = light[tx];

                    // éœ€è¦å…ˆæŠŠ startY ä¹‹ä¸Šçš„è¡°å‡ç´¯ç§¯å‡ºæ¥
                    for (let ty = 0; ty <= maxScanY; ty++) {
                        const id = colTiles[ty];

                        const decay = SUN_DECAY[id];
                        if (decay) sun = Math.max(0, sun - decay);

                        if (ty >= startY) {
                            const bl = BLOCK_LIGHT[id];
                            const v = sun > bl ? sun : bl;
                            colLight[ty] = v;

                            if (bl > 0) {
                                srcX.push(tx);
                                srcY.push(ty);
                                srcL.push(bl);
                            }
                        }
                    }
                }

                // ä»å…‰æºæ‰©æ•£ï¼ˆé¡ºåºä¸åŸå®ç°ä¸€è‡´ï¼‰
                for (let i = 0; i < srcX.length; i++) {
                    this._spreadLight(srcX[i], srcY[i], srcL[i]);
                }
            }

            _spreadLight(sx, sy, level) {
                const w = this.world.w, h = this.world.h;
                const tiles = this.world.tiles;
                const light = this.world.light;

                // å»¶è¿Ÿåˆå§‹åŒ–ï¼ˆworld åˆ›å»ºåæ‰æœ‰å°ºå¯¸ï¼‰
                if (!this._lightVisited || this._lightVisited.length !== w * h) {
                    this._lightVisited = new Uint32Array(w * h);
                    this._lightVisitMark = 1;
                }

                // æ¯æ¬¡æ‰©æ•£ä½¿ç”¨æ–°çš„ markï¼Œé¿å… visited.fill(0)
                let mark = (this._lightVisitMark + 1) >>> 0;
                if (mark === 0) { // æº¢å‡ºå›ç»•
                    this._lightVisited.fill(0);
                    mark = 1;
                }
                this._lightVisitMark = mark;

                const visited = this._lightVisited;
                const qx = this._lightQx;
                const qy = this._lightQy;
                const ql = this._lightQl;

                qx.length = 0;
                qy.length = 0;
                ql.length = 0;

                let head = 0;
                qx.push(sx);
                qy.push(sy);
                ql.push(level);

                while (head < qx.length) {
                    const x = qx[head];
                    const y = qy[head];
                    const l = ql[head];
                    head++;

                    if (l <= 0 || x < 0 || x >= w || y < 0 || y >= h) continue;

                    const idx = x + y * w;
                    if (visited[idx] === mark) continue;
                    visited[idx] = mark;

                    const colLight = light[x];
                    if (l > colLight[y]) colLight[y] = l;

                    const nl = l - (BLOCK_SOLID[tiles[x][y]] ? 2 : 1);
                    if (nl > 0) {
                        // push é¡ºåºä¸åŸå®ç°ä¸€è‡´ï¼šleft, right, up, down
                        qx.push(x - 1, x + 1, x, x);
                        qy.push(y, y, y - 1, y + 1);
                        ql.push(nl, nl, nl, nl);
                    }
                }
            }

            // å°†æ‰è½ç‰©æ·»åŠ åˆ°åº“å­˜ï¼Œè¿”å›æ˜¯å¦æˆåŠŸ

            _addToInventory(blockId, count = 1) {
                // åˆ†å±‚ï¼šå…¥åŒ…é€»è¾‘å§”æ‰˜ç»™ InventorySystemï¼ˆè¡Œä¸ºä¸å˜ï¼‰
                return this.services.inventory.add(blockId, count);
            }

            render() {
                const cam = this._renderCamera || this.camera;
                this.renderer.clear();
                if (this.renderer.renderBackgroundCached) {
                    this.renderer.renderBackgroundCached(cam, this.timeOfDay, false);
                } else {
                    this.renderer.renderSky(cam, this.timeOfDay);
                }

                // â”€â”€ Mountain Rendering Patch v2 (original render fallback) â”€â”€
                {
                    const gs = window.GAME_SETTINGS || this.settings || {};
                    const mtEnabled = (gs.bgMountains !== false) && (gs.__bgMountainsEffective !== false);
                    if (mtEnabled && typeof renderParallaxMountains === 'function') {
                        renderParallaxMountains(this.renderer, cam, this.timeOfDay);
                    }
                }

                this.renderer.renderWorld(this.world, cam, this.timeOfDay);

                // æ¸²æŸ“æ‰è½ç‰©
                this.droppedItems.render(this.renderer.ctx, cam, this.renderer.textures, this.timeOfDay);
                if (this.settings.particles) this.particles.render(this.renderer.ctx, cam);
                this.player.render(this.renderer.ctx, cam);

                const p = this.player;
                const ts = CONFIG.TILE_SIZE;

                const input = (this.isMobile && this.touchController && this._latestTouchInput) ? this._latestTouchInput : this.input;
                const sx = (typeof input.targetX === 'number') ? input.targetX : input.mouseX;
                const sy = (typeof input.targetY === 'number') ? input.targetY : input.mouseY;

                const safeSX = Number.isFinite(sx) ? sx : (p.cx() - cam.x);
                const safeSY = Number.isFinite(sy) ? sy : (p.cy() - cam.y);

                const worldX = safeSX + cam.x;
                const worldY = safeSY + cam.y;

                let tileX = Math.floor(worldX / ts);
                let tileY = Math.floor(worldY / ts);
                if (this.isMobile && this.settings && this.settings.aimAssist) {
                    tileX = Math.floor((worldX + ts * 0.5) / ts);
                    tileY = Math.floor((worldY + ts * 0.5) / ts);
                }
                const dx = worldX - this.player.cx();
                const dy = worldY - this.player.cy();
                const reachPx = CONFIG.REACH_DISTANCE * CONFIG.TILE_SIZE;
                const inRange = (dx * dx + dy * dy) <= (reachPx * reachPx);

                if (tileX >= 0 && tileX < this.world.w && tileY >= 0 && tileY < this.world.h) {
                    this.renderer.renderHighlight(tileX, tileY, cam, inRange);
                }
                // åæœŸå¢å¼ºï¼ˆåœ¨æ‰€æœ‰ä¸»ä½“ç»˜åˆ¶å®Œæˆåæ‰§è¡Œï¼‰
                if (this.renderer && this.renderer.postProcess) this.renderer.postProcess(this.timeOfDay);
                if (this.settings.minimap && minimapVisible) {
                    this.minimap.update();
                    if (this.minimap && typeof this.minimap.render === 'function') this.minimap.render(p.x, p.y);
                    else if (this.minimap && typeof this.minimap.renderPlayer === 'function') this.minimap.renderPlayer(p.x, p.y);
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //                                     å¯åŠ¨
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 19: Block Light LUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Generate BLOCK_LIGHT_LUT (darkness alpha per light level)
(() => {
    const levels = CONFIG.LIGHT_LEVELS || 16;
    const lut = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
        if (i >= levels) { lut[i] = 0; continue; }
        const ratio = i / levels;
        const alpha = 1 - ratio * ratio;
        lut[i] = alpha < 0.02 ? 0 : alpha;
    }
    window.BLOCK_LIGHT_LUT = lut;
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 20: Global Exports & Namespace
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.TU = window.TU || {};
Object.assign(window.TU, {
    EventManager, ParticlePool, Utils, DOM, UI_IDS, INPUT_KEYS, MOUSE_BUTTON, INVENTORY_LIMITS,
    GameSettings, Toast, FullscreenManager, AudioManager, SaveSystem,
    CONFIG, BLOCK, BLOCK_DATA, BLOCK_SOLID, BLOCK_LIQUID, BLOCK_TRANSPARENT, BLOCK_WALKABLE,
    BLOCK_MAX_ID, BLOCK_COLOR_PACKED, SUN_DECAY,
    Renderer, Game,
    SafeUtils
});

// Class aliases for patches that reference window.X
window.Game = Game;
window.Renderer = Renderer;
window.SaveSystem = SaveSystem;
window.Toast = Toast;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 21: Bootstrap
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('load', () => {
    try {
        const game = new Game();
        window.__GAME_INSTANCE__ = game;
        window.game = game;

        const p = game.init();
        if (p && typeof p.catch === 'function') {
            p.catch((e) => {
                SafeUtils.reportError(e, { phase: 'init' });
                console.error('[Boot] Init failed:', e);
            });
        }
    } catch (e) {
        SafeUtils.reportError(e, { phase: 'boot' });
        console.error('[Boot] Failed:', e);
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 22: Cleanup & Health Check
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('beforeunload', () => {
    if (window.TU && TU._worldWorkerClient && TU._worldWorkerClient.worker) {
        try { TU._worldWorkerClient.worker.terminate(); } catch {}
    }
    SafeUtils.disposeAll();
});

setInterval(() => {
    const game = window.__GAME_INSTANCE__ || window.game;
    if (!game) return;

    // Validate player position
    if (game.player && game.world) {
        const { x, y } = game.player;
        if (typeof x !== 'number' || typeof y !== 'number' || !isFinite(x) || !isFinite(y)) {
            console.error('[HealthCheck] Invalid player position, resetting');
            game.player.x = game.world.w * 16 / 2;
            game.player.y = game.world.h * 16 / 2;
        }
    }

    // Check for frozen game loop
    if (game._lastFrameTime && Date.now() - game._lastFrameTime > 10000) {
        console.error('[HealthCheck] Game loop appears frozen');
        if (typeof game.loop === 'function' && !game._rafRunning) {
            game._rafRunning = true;
            requestAnimationFrame((ts) => game.loop(ts));
        }
    }
}, 30000);

</script>

</body>

</html>